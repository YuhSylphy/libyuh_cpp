<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>yuh library: gtest-1.6.0/src/gtest.cc Source File</title>

<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">yuh library
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('df/d5b/gtest_8cc.html','../../');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">gtest-1.6.0/src/gtest.cc</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../df/d5b/gtest_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Copyright 2005, Google Inc.</span>
<a name="l00002"></a>00002 <span class="comment">// All rights reserved.</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">// Redistribution and use in source and binary forms, with or without</span>
<a name="l00005"></a>00005 <span class="comment">// modification, are permitted provided that the following conditions are</span>
<a name="l00006"></a>00006 <span class="comment">// met:</span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment">//     * Redistributions of source code must retain the above copyright</span>
<a name="l00009"></a>00009 <span class="comment">// notice, this list of conditions and the following disclaimer.</span>
<a name="l00010"></a>00010 <span class="comment">//     * Redistributions in binary form must reproduce the above</span>
<a name="l00011"></a>00011 <span class="comment">// copyright notice, this list of conditions and the following disclaimer</span>
<a name="l00012"></a>00012 <span class="comment">// in the documentation and/or other materials provided with the</span>
<a name="l00013"></a>00013 <span class="comment">// distribution.</span>
<a name="l00014"></a>00014 <span class="comment">//     * Neither the name of Google Inc. nor the names of its</span>
<a name="l00015"></a>00015 <span class="comment">// contributors may be used to endorse or promote products derived from</span>
<a name="l00016"></a>00016 <span class="comment">// this software without specific prior written permission.</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00019"></a>00019 <span class="comment">// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00020"></a>00020 <span class="comment">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00021"></a>00021 <span class="comment">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00022"></a>00022 <span class="comment">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00023"></a>00023 <span class="comment">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00024"></a>00024 <span class="comment">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00025"></a>00025 <span class="comment">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00026"></a>00026 <span class="comment">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00027"></a>00027 <span class="comment">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<a name="l00028"></a>00028 <span class="comment">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00029"></a>00029 <span class="comment">//</span>
<a name="l00030"></a>00030 <span class="comment">// Author: wan@google.com (Zhanyong Wan)</span>
<a name="l00031"></a>00031 <span class="comment">//</span>
<a name="l00032"></a>00032 <span class="comment">// The Google C++ Testing Framework (Google Test)</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;gtest/gtest.h&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="../../dc/dbe/gtest-spi_8h.html">gtest/gtest-spi.h</a>&quot;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;wchar.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;wctype.h&gt;</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;ostream&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="preprocessor">#if GTEST_OS_LINUX</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 <span class="comment">// TODO(kenton@google.com): Use autoconf to detect availability of</span>
<a name="l00053"></a>00053 <span class="comment">// gettimeofday().</span>
<a name="l00054"></a>00054 <span class="preprocessor"># define GTEST_HAS_GETTIMEOFDAY_ 1</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span>
<a name="l00056"></a>00056 <span class="preprocessor"># include &lt;fcntl.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00057"></a>00057 <span class="preprocessor"># include &lt;limits.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00058"></a>00058 <span class="preprocessor"># include &lt;sched.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00059"></a>00059 <span class="comment">// Declares vsnprintf().  This header is not available on Windows.</span>
<a name="l00060"></a>00060 <span class="preprocessor"># include &lt;strings.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00061"></a>00061 <span class="preprocessor"># include &lt;sys/mman.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00062"></a>00062 <span class="preprocessor"># include &lt;sys/time.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00063"></a>00063 <span class="preprocessor"># include &lt;unistd.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00064"></a>00064 <span class="preprocessor"># include &lt;string&gt;</span>
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="preprocessor">#elif GTEST_OS_SYMBIAN</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor"># define GTEST_HAS_GETTIMEOFDAY_ 1</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor"># include &lt;sys/time.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="preprocessor">#elif GTEST_OS_ZOS</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor"># define GTEST_HAS_GETTIMEOFDAY_ 1</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor"># include &lt;sys/time.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="comment">// On z/OS we additionally need strings.h for strcasecmp.</span>
<a name="l00075"></a>00075 <span class="preprocessor"># include &lt;strings.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="preprocessor">#elif GTEST_OS_WINDOWS_MOBILE  // We are on Windows CE.</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span>
<a name="l00079"></a>00079 <span class="preprocessor"># include &lt;windows.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="preprocessor">#elif GTEST_OS_WINDOWS  // We are on Windows proper.</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span>
<a name="l00083"></a>00083 <span class="preprocessor"># include &lt;io.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00084"></a>00084 <span class="preprocessor"># include &lt;sys/timeb.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00085"></a>00085 <span class="preprocessor"># include &lt;sys/types.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00086"></a>00086 <span class="preprocessor"># include &lt;sys/stat.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="preprocessor"># if GTEST_OS_WINDOWS_MINGW</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span><span class="comment">// MinGW has gettimeofday() but not _ftime64().</span>
<a name="l00090"></a>00090 <span class="comment">// TODO(kenton@google.com): Use autoconf to detect availability of</span>
<a name="l00091"></a>00091 <span class="comment">//   gettimeofday().</span>
<a name="l00092"></a>00092 <span class="comment">// TODO(kenton@google.com): There are other ways to get the time on</span>
<a name="l00093"></a>00093 <span class="comment">//   Windows, like GetTickCount() or GetSystemTimeAsFileTime().  MinGW</span>
<a name="l00094"></a>00094 <span class="comment">//   supports these.  consider using them instead.</span>
<a name="l00095"></a>00095 <span class="preprocessor">#  define GTEST_HAS_GETTIMEOFDAY_ 1</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#  include &lt;sys/time.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00097"></a>00097 <span class="preprocessor"># endif  // GTEST_OS_WINDOWS_MINGW</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span>
<a name="l00099"></a>00099 <span class="comment">// cpplint thinks that the header is already included, so we want to</span>
<a name="l00100"></a>00100 <span class="comment">// silence it.</span>
<a name="l00101"></a>00101 <span class="preprocessor"># include &lt;windows.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="preprocessor">#else</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span>
<a name="l00105"></a>00105 <span class="comment">// Assume other platforms have gettimeofday().</span>
<a name="l00106"></a>00106 <span class="comment">// TODO(kenton@google.com): Use autoconf to detect availability of</span>
<a name="l00107"></a>00107 <span class="comment">//   gettimeofday().</span>
<a name="l00108"></a><a class="code" href="../../df/d5b/gtest_8cc.html#a7c139c1711de5a69cbc934e8a082e4f9">00108</a> <span class="preprocessor"># define GTEST_HAS_GETTIMEOFDAY_ 1</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span>
<a name="l00110"></a>00110 <span class="comment">// cpplint thinks that the header is already included, so we want to</span>
<a name="l00111"></a>00111 <span class="comment">// silence it.</span>
<a name="l00112"></a>00112 <span class="preprocessor"># include &lt;sys/time.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00113"></a>00113 <span class="preprocessor"># include &lt;unistd.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="preprocessor">#endif  // GTEST_OS_LINUX</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>
<a name="l00117"></a>00117 <span class="preprocessor">#if GTEST_HAS_EXCEPTIONS</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="preprocessor"># include &lt;stdexcept&gt;</span>
<a name="l00119"></a>00119 <span class="preprocessor">#endif</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span>
<a name="l00121"></a>00121 <span class="preprocessor">#if GTEST_CAN_STREAM_RESULTS_</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="preprocessor"># include &lt;arpa/inet.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00123"></a>00123 <span class="preprocessor"># include &lt;netdb.h&gt;</span>  <span class="comment">// NOLINT</span>
<a name="l00124"></a>00124 <span class="preprocessor">#endif</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span>
<a name="l00126"></a>00126 <span class="comment">// Indicates that this translation unit is part of Google Test&#39;s</span>
<a name="l00127"></a>00127 <span class="comment">// implementation.  It must come before gtest-internal-inl.h is</span>
<a name="l00128"></a>00128 <span class="comment">// included, or there will be a compiler error.  This trick is to</span>
<a name="l00129"></a>00129 <span class="comment">// prevent a user from accidentally including gtest-internal-inl.h in</span>
<a name="l00130"></a>00130 <span class="comment">// his code.</span>
<a name="l00131"></a><a class="code" href="../../df/d5b/gtest_8cc.html#a83bd232fd1077579fada92c31bb7469f">00131</a> <span class="preprocessor">#define GTEST_IMPLEMENTATION_ 1</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="../../d0/da1/gtest-internal-inl_8h.html">src/gtest-internal-inl.h</a>&quot;</span>
<a name="l00133"></a>00133 <span class="preprocessor">#undef GTEST_IMPLEMENTATION_</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span>
<a name="l00135"></a>00135 <span class="preprocessor">#if GTEST_OS_WINDOWS</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span><span class="preprocessor"># define vsnprintf _vsnprintf</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="preprocessor">#endif  // GTEST_OS_WINDOWS</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span>
<a name="l00139"></a>00139 <span class="keyword">namespace </span>testing {
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="keyword">using</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab37ae76c997078f65ba28f35b3657151">internal::CountIf</a>;
<a name="l00142"></a>00142 <span class="keyword">using</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af699259a2b1e5e06250ed075b735b1f6">internal::ForEach</a>;
<a name="l00143"></a>00143 <span class="keyword">using</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a06b7c21a279eef9fbf0b8810af41e6b5">internal::GetElementOr</a>;
<a name="l00144"></a>00144 <span class="keyword">using</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a955e3f72f36c9db3a1165517010f52a3">internal::Shuffle</a>;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="comment">// Constants.</span>
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="comment">// A test whose test case name or test name matches this filter is</span>
<a name="l00149"></a>00149 <span class="comment">// disabled and not run.</span>
<a name="l00150"></a>00150 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="../../d0/d75/namespacetesting.html#a838f9d2c93a072f193aeb34809047179">kDisableTestFilter</a>[] = <span class="stringliteral">&quot;DISABLED_*:*/DISABLED_*&quot;</span>;
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="comment">// A test case whose name matches this filter is considered a death</span>
<a name="l00153"></a>00153 <span class="comment">// test case and will be run before test cases whose name doesn&#39;t</span>
<a name="l00154"></a>00154 <span class="comment">// match this filter.</span>
<a name="l00155"></a>00155 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="../../d0/d75/namespacetesting.html#abece2ad88f181d37c5c8fb3e9dd0675a">kDeathTestCaseFilter</a>[] = <span class="stringliteral">&quot;*DeathTest:*DeathTest/*&quot;</span>;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="comment">// A test filter that matches everything.</span>
<a name="l00158"></a>00158 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="../../d0/d75/namespacetesting.html#a1bf2eaf73b98e0bc07b11550f91986a1">kUniversalFilter</a>[] = <span class="stringliteral">&quot;*&quot;</span>;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 <span class="comment">// The default output file for XML output.</span>
<a name="l00161"></a>00161 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="../../d0/d75/namespacetesting.html#a770a114e153c518bc30b271458d7591a">kDefaultOutputFile</a>[] = <span class="stringliteral">&quot;test_detail.xml&quot;</span>;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">// The environment variable name for the test shard index.</span>
<a name="l00164"></a>00164 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="../../d0/d75/namespacetesting.html#a34e170fdd4ba4d2f80456cc37e2a8185">kTestShardIndex</a>[] = <span class="stringliteral">&quot;GTEST_SHARD_INDEX&quot;</span>;
<a name="l00165"></a>00165 <span class="comment">// The environment variable name for the total number of test shards.</span>
<a name="l00166"></a>00166 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="../../d0/d75/namespacetesting.html#a9d9ddd278cfbb5834dea812d0de529be">kTestTotalShards</a>[] = <span class="stringliteral">&quot;GTEST_TOTAL_SHARDS&quot;</span>;
<a name="l00167"></a>00167 <span class="comment">// The environment variable name for the test shard status file.</span>
<a name="l00168"></a>00168 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="../../d0/d75/namespacetesting.html#a9f1ab5ec024bf19381dff00e824f6ba7">kTestShardStatusFile</a>[] = <span class="stringliteral">&quot;GTEST_SHARD_STATUS_FILE&quot;</span>;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="keyword">namespace </span>internal {
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="comment">// The text used in failure messages to indicate the start of the</span>
<a name="l00173"></a>00173 <span class="comment">// stack trace.</span>
<a name="l00174"></a>00174 <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a735beafdf3dc508442f783a0269ca0f5">kStackTraceMarker</a>[] = <span class="stringliteral">&quot;\nStack trace:\n&quot;</span>;
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="comment">// g_help_flag is true iff the --help flag or an equivalent form is</span>
<a name="l00177"></a>00177 <span class="comment">// specified on the command line.</span>
<a name="l00178"></a>00178 <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a05b77c93e2ac596346466a00277288ca">g_help_flag</a> = <span class="keyword">false</span>;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 }  <span class="comment">// namespace internal</span>
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <a class="code" href="../../d0/d75/namespacetesting.html#a531ff780002eba452569e9460c1ef9d0">GTEST_DEFINE_bool_</a>(
<a name="l00183"></a>00183     also_run_disabled_tests,
<a name="l00184"></a>00184     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af17bf74326e1076c47455ef2618c1a1a">internal::BoolFromGTestEnv</a>(<span class="stringliteral">&quot;also_run_disabled_tests&quot;</span>, <span class="keyword">false</span>),
<a name="l00185"></a>00185     <span class="stringliteral">&quot;Run disabled tests too, in addition to the tests normally being run.&quot;</span>);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <a class="code" href="../../d0/d75/namespacetesting.html#a531ff780002eba452569e9460c1ef9d0">GTEST_DEFINE_bool_</a>(
<a name="l00188"></a>00188     break_on_failure,
<a name="l00189"></a>00189     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af17bf74326e1076c47455ef2618c1a1a">internal::BoolFromGTestEnv</a>(<span class="stringliteral">&quot;break_on_failure&quot;</span>, <span class="keyword">false</span>),
<a name="l00190"></a>00190     <span class="stringliteral">&quot;True iff a failed assertion should be a debugger break-point.&quot;</span>);
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <a class="code" href="../../d0/d75/namespacetesting.html#a531ff780002eba452569e9460c1ef9d0">GTEST_DEFINE_bool_</a>(
<a name="l00193"></a>00193     catch_exceptions,
<a name="l00194"></a>00194     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af17bf74326e1076c47455ef2618c1a1a">internal::BoolFromGTestEnv</a>(<span class="stringliteral">&quot;catch_exceptions&quot;</span>, <span class="keyword">true</span>),
<a name="l00195"></a>00195     <span class="stringliteral">&quot;True iff &quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a13d98c217176bd8722c395b9225fc19d">GTEST_NAME_</a>
<a name="l00196"></a>00196     <span class="stringliteral">&quot; should catch exceptions and treat them as test failures.&quot;</span>);
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 <a class="code" href="../../d0/d75/namespacetesting.html#ab239ee3e29f0fe79791cdce90600cbc0">GTEST_DEFINE_string_</a>(
<a name="l00199"></a>00199     color,
<a name="l00200"></a>00200     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0154be115eea16783f82d3642ff27940">internal::StringFromGTestEnv</a>(<span class="stringliteral">&quot;color&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>),
<a name="l00201"></a>00201     <span class="stringliteral">&quot;Whether to use colors in the output.  Valid values: yes, no, &quot;</span>
<a name="l00202"></a>00202     <span class="stringliteral">&quot;and auto.  &#39;auto&#39; means to use colors if the output is &quot;</span>
<a name="l00203"></a>00203     <span class="stringliteral">&quot;being sent to a terminal and the TERM environment variable &quot;</span>
<a name="l00204"></a>00204     <span class="stringliteral">&quot;is set to xterm, xterm-color, xterm-256color, linux or cygwin.&quot;</span>);
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <a class="code" href="../../d0/d75/namespacetesting.html#ab239ee3e29f0fe79791cdce90600cbc0">GTEST_DEFINE_string_</a>(
<a name="l00207"></a>00207     filter,
<a name="l00208"></a>00208     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0154be115eea16783f82d3642ff27940">internal::StringFromGTestEnv</a>(<span class="stringliteral">&quot;filter&quot;</span>, <a class="code" href="../../d0/d75/namespacetesting.html#a1bf2eaf73b98e0bc07b11550f91986a1">kUniversalFilter</a>),
<a name="l00209"></a>00209     <span class="stringliteral">&quot;A colon-separated list of glob (not regex) patterns &quot;</span>
<a name="l00210"></a>00210     <span class="stringliteral">&quot;for filtering the tests to run, optionally followed by a &quot;</span>
<a name="l00211"></a>00211     <span class="stringliteral">&quot;&#39;-&#39; and a : separated list of negative patterns (tests to &quot;</span>
<a name="l00212"></a>00212     <span class="stringliteral">&quot;exclude).  A test is run if it matches one of the positive &quot;</span>
<a name="l00213"></a>00213     <span class="stringliteral">&quot;patterns and does not match any of the negative patterns.&quot;</span>);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <a class="code" href="../../d0/d75/namespacetesting.html#a531ff780002eba452569e9460c1ef9d0">GTEST_DEFINE_bool_</a>(list_tests, <span class="keyword">false</span>,
<a name="l00216"></a>00216                    <span class="stringliteral">&quot;List all tests without running them.&quot;</span>);
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 <a class="code" href="../../d0/d75/namespacetesting.html#ab239ee3e29f0fe79791cdce90600cbc0">GTEST_DEFINE_string_</a>(
<a name="l00219"></a>00219     <a class="code" href="../../d6/dc2/namespacegtest__output__test.html#acf316e258896197f4e917a6547e49532">output</a>,
<a name="l00220"></a>00220     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0154be115eea16783f82d3642ff27940">internal::StringFromGTestEnv</a>(<span class="stringliteral">&quot;output&quot;</span>, <span class="stringliteral">&quot;&quot;</span>),
<a name="l00221"></a>00221     <span class="stringliteral">&quot;A format (currently must be \&quot;xml\&quot;), optionally followed &quot;</span>
<a name="l00222"></a>00222     <span class="stringliteral">&quot;by a colon and an output file name or directory. A directory &quot;</span>
<a name="l00223"></a>00223     <span class="stringliteral">&quot;is indicated by a trailing pathname separator. &quot;</span>
<a name="l00224"></a>00224     <span class="stringliteral">&quot;Examples: \&quot;xml:filename.xml\&quot;, \&quot;xml::directoryname/\&quot;. &quot;</span>
<a name="l00225"></a>00225     <span class="stringliteral">&quot;If a directory is specified, output files will be created &quot;</span>
<a name="l00226"></a>00226     <span class="stringliteral">&quot;within that directory, with file-names based on the test &quot;</span>
<a name="l00227"></a>00227     <span class="stringliteral">&quot;executable&#39;s name and, if necessary, made unique by adding &quot;</span>
<a name="l00228"></a>00228     <span class="stringliteral">&quot;digits.&quot;</span>);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <a class="code" href="../../d0/d75/namespacetesting.html#a531ff780002eba452569e9460c1ef9d0">GTEST_DEFINE_bool_</a>(
<a name="l00231"></a>00231     print_time,
<a name="l00232"></a>00232     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af17bf74326e1076c47455ef2618c1a1a">internal::BoolFromGTestEnv</a>(<span class="stringliteral">&quot;print_time&quot;</span>, <span class="keyword">true</span>),
<a name="l00233"></a>00233     <span class="stringliteral">&quot;True iff &quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a13d98c217176bd8722c395b9225fc19d">GTEST_NAME_</a>
<a name="l00234"></a>00234     <span class="stringliteral">&quot; should display elapsed time in text output.&quot;</span>);
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <a class="code" href="../../d0/d75/namespacetesting.html#a61bb802d0fec79227ae5d0d57d6d0960">GTEST_DEFINE_int32_</a>(
<a name="l00237"></a>00237     random_seed,
<a name="l00238"></a>00238     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a960e275ac93c373f223887e57ec54381">internal::Int32FromGTestEnv</a>(<span class="stringliteral">&quot;random_seed&quot;</span>, 0),
<a name="l00239"></a>00239     <span class="stringliteral">&quot;Random number seed to use when shuffling test orders.  Must be in range &quot;</span>
<a name="l00240"></a>00240     <span class="stringliteral">&quot;[1, 99999], or 0 to use a seed based on the current time.&quot;</span>);
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 <a class="code" href="../../d0/d75/namespacetesting.html#a61bb802d0fec79227ae5d0d57d6d0960">GTEST_DEFINE_int32_</a>(
<a name="l00243"></a>00243     repeat,
<a name="l00244"></a>00244     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a960e275ac93c373f223887e57ec54381">internal::Int32FromGTestEnv</a>(<span class="stringliteral">&quot;repeat&quot;</span>, 1),
<a name="l00245"></a>00245     <span class="stringliteral">&quot;How many times to repeat each test.  Specify a negative number &quot;</span>
<a name="l00246"></a>00246     <span class="stringliteral">&quot;for repeating forever.  Useful for shaking out flaky tests.&quot;</span>);
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <a class="code" href="../../d0/d75/namespacetesting.html#a531ff780002eba452569e9460c1ef9d0">GTEST_DEFINE_bool_</a>(
<a name="l00249"></a>00249     show_internal_stack_frames, <span class="keyword">false</span>,
<a name="l00250"></a>00250     <span class="stringliteral">&quot;True iff &quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a13d98c217176bd8722c395b9225fc19d">GTEST_NAME_</a> <span class="stringliteral">&quot; should include internal stack frames when &quot;</span>
<a name="l00251"></a>00251     <span class="stringliteral">&quot;printing test failure stack traces.&quot;</span>);
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 <a class="code" href="../../d0/d75/namespacetesting.html#a531ff780002eba452569e9460c1ef9d0">GTEST_DEFINE_bool_</a>(
<a name="l00254"></a>00254     shuffle,
<a name="l00255"></a>00255     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af17bf74326e1076c47455ef2618c1a1a">internal::BoolFromGTestEnv</a>(<span class="stringliteral">&quot;shuffle&quot;</span>, <span class="keyword">false</span>),
<a name="l00256"></a>00256     <span class="stringliteral">&quot;True iff &quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a13d98c217176bd8722c395b9225fc19d">GTEST_NAME_</a>
<a name="l00257"></a>00257     <span class="stringliteral">&quot; should randomize tests&#39; order on every run.&quot;</span>);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <a class="code" href="../../d0/d75/namespacetesting.html#a61bb802d0fec79227ae5d0d57d6d0960">GTEST_DEFINE_int32_</a>(
<a name="l00260"></a>00260     stack_trace_depth,
<a name="l00261"></a>00261     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a960e275ac93c373f223887e57ec54381">internal::Int32FromGTestEnv</a>(<span class="stringliteral">&quot;stack_trace_depth&quot;</span>, <a class="code" href="../../d0/d75/namespacetesting.html#af923b7f5ce597d321ccd3f7e62afb270">kMaxStackTraceDepth</a>),
<a name="l00262"></a>00262     <span class="stringliteral">&quot;The maximum number of stack frames to print when an &quot;</span>
<a name="l00263"></a>00263     <span class="stringliteral">&quot;assertion fails.  The valid range is 0 through 100, inclusive.&quot;</span>);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 <a class="code" href="../../d0/d75/namespacetesting.html#ab239ee3e29f0fe79791cdce90600cbc0">GTEST_DEFINE_string_</a>(
<a name="l00266"></a>00266     stream_result_to,
<a name="l00267"></a>00267     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0154be115eea16783f82d3642ff27940">internal::StringFromGTestEnv</a>(<span class="stringliteral">&quot;stream_result_to&quot;</span>, <span class="stringliteral">&quot;&quot;</span>),
<a name="l00268"></a>00268     <span class="stringliteral">&quot;This flag specifies the host name and the port number on which to stream &quot;</span>
<a name="l00269"></a>00269     <span class="stringliteral">&quot;test results. Example: \&quot;localhost:555\&quot;. The flag is effective only on &quot;</span>
<a name="l00270"></a>00270     <span class="stringliteral">&quot;Linux.&quot;</span>);
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <a class="code" href="../../d0/d75/namespacetesting.html#a531ff780002eba452569e9460c1ef9d0">GTEST_DEFINE_bool_</a>(
<a name="l00273"></a>00273     throw_on_failure,
<a name="l00274"></a>00274     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af17bf74326e1076c47455ef2618c1a1a">internal::BoolFromGTestEnv</a>(<span class="stringliteral">&quot;throw_on_failure&quot;</span>, <span class="keyword">false</span>),
<a name="l00275"></a>00275     <span class="stringliteral">&quot;When this flag is specified, a failed assertion will throw an exception &quot;</span>
<a name="l00276"></a>00276     <span class="stringliteral">&quot;if exceptions are enabled or exit the program with a non-zero code &quot;</span>
<a name="l00277"></a>00277     <span class="stringliteral">&quot;otherwise.&quot;</span>);
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="keyword">namespace </span>internal {
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="comment">// Generates a random number from [0, range), using a Linear</span>
<a name="l00282"></a>00282 <span class="comment">// Congruential Generator (LCG).  Crashes if &#39;range&#39; is 0 or greater</span>
<a name="l00283"></a>00283 <span class="comment">// than kMaxRange.</span>
<a name="l00284"></a>00284 <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a> <a class="code" href="../../dc/d5a/classtesting_1_1internal_1_1Random.html#aeee93742520cd3aec74fc709afea415e">Random::Generate</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a> range) {
<a name="l00285"></a>00285   <span class="comment">// These constants are the same as are used in glibc&#39;s rand(3).</span>
<a name="l00286"></a>00286   <a class="code" href="../../dc/d5a/classtesting_1_1internal_1_1Random.html#a4cb6bfa4b3d348765b3b6f2038b6393b">state_</a> = (1103515245U*<a class="code" href="../../dc/d5a/classtesting_1_1internal_1_1Random.html#a4cb6bfa4b3d348765b3b6f2038b6393b">state_</a> + 12345U) % <a class="code" href="../../dc/d5a/classtesting_1_1internal_1_1Random.html#ada5e9bee8921dfbbe2b6ef1661995016">kMaxRange</a>;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#ab54343f0a36dc4cb0ce8a478dd7847b8">GTEST_CHECK_</a>(range &gt; 0)
<a name="l00289"></a>00289       &lt;&lt; <span class="stringliteral">&quot;Cannot generate a number in the range [0, 0).&quot;</span>;
<a name="l00290"></a>00290   <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#ab54343f0a36dc4cb0ce8a478dd7847b8">GTEST_CHECK_</a>(range &lt;= <a class="code" href="../../dc/d5a/classtesting_1_1internal_1_1Random.html#ada5e9bee8921dfbbe2b6ef1661995016">kMaxRange</a>)
<a name="l00291"></a>00291       &lt;&lt; <span class="stringliteral">&quot;Generation of a number in [0, &quot;</span> &lt;&lt; range &lt;&lt; <span class="stringliteral">&quot;) was requested, &quot;</span>
<a name="l00292"></a>00292       &lt;&lt; <span class="stringliteral">&quot;but this can only generate numbers in [0, &quot;</span> &lt;&lt; <a class="code" href="../../dc/d5a/classtesting_1_1internal_1_1Random.html#ada5e9bee8921dfbbe2b6ef1661995016">kMaxRange</a> &lt;&lt; <span class="stringliteral">&quot;).&quot;</span>;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294   <span class="comment">// Converting via modulus introduces a bit of downward bias, but</span>
<a name="l00295"></a>00295   <span class="comment">// it&#39;s simple, and a linear congruential generator isn&#39;t too good</span>
<a name="l00296"></a>00296   <span class="comment">// to begin with.</span>
<a name="l00297"></a>00297   <span class="keywordflow">return</span> <a class="code" href="../../dc/d5a/classtesting_1_1internal_1_1Random.html#a4cb6bfa4b3d348765b3b6f2038b6393b">state_</a> % range;
<a name="l00298"></a>00298 }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 <span class="comment">// GTestIsInitialized() returns true iff the user has initialized</span>
<a name="l00301"></a>00301 <span class="comment">// Google Test.  Useful for catching the user mistake of not initializing</span>
<a name="l00302"></a>00302 <span class="comment">// Google Test before calling RUN_ALL_TESTS().</span>
<a name="l00303"></a>00303 <span class="comment">//</span>
<a name="l00304"></a>00304 <span class="comment">// A user must call testing::InitGoogleTest() to initialize Google</span>
<a name="l00305"></a>00305 <span class="comment">// Test.  g_init_gtest_count is set to the number of times</span>
<a name="l00306"></a>00306 <span class="comment">// InitGoogleTest() has been called.  We don&#39;t protect this variable</span>
<a name="l00307"></a>00307 <span class="comment">// under a mutex as it is only accessed in the main thread.</span>
<a name="l00308"></a>00308 <span class="keywordtype">int</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5d56c8e20bffcfc3a4c2c1805f815ab5">g_init_gtest_count</a> = 0;
<a name="l00309"></a>00309 <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0554a55a03dae7d40e8ba569dac7848f">GTestIsInitialized</a>() { <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5d56c8e20bffcfc3a4c2c1805f815ab5">g_init_gtest_count</a> != 0; }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="comment">// Iterates over a vector of TestCases, keeping a running sum of the</span>
<a name="l00312"></a>00312 <span class="comment">// results of calling a given int-returning method on each.</span>
<a name="l00313"></a>00313 <span class="comment">// Returns the sum.</span>
<a name="l00314"></a>00314 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9be4a7736e0e7d8754551c6a827c376d">SumOverTestCaseList</a>(<span class="keyword">const</span> std::vector&lt;TestCase*&gt;&amp; case_list,
<a name="l00315"></a>00315                                <span class="keywordtype">int</span> (<a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>::*method)() <span class="keyword">const</span>) {
<a name="l00316"></a>00316   <span class="keywordtype">int</span> sum = 0;
<a name="l00317"></a>00317   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; case_list.size(); i++) {
<a name="l00318"></a>00318     sum += (case_list[i]-&gt;*method)();
<a name="l00319"></a>00319   }
<a name="l00320"></a>00320   <span class="keywordflow">return</span> sum;
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="comment">// Returns true iff the test case passed.</span>
<a name="l00324"></a>00324 <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac961033179851d1a8ff0e009ddeece03">TestCasePassed</a>(<span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>* test_case) {
<a name="l00325"></a>00325   <span class="keywordflow">return</span> test_case-&gt;should_run() &amp;&amp; test_case-&gt;Passed();
<a name="l00326"></a>00326 }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="comment">// Returns true iff the test case failed.</span>
<a name="l00329"></a>00329 <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9cc56cc516fd6f9e3e1d7ab2183e5b2c">TestCaseFailed</a>(<span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>* test_case) {
<a name="l00330"></a>00330   <span class="keywordflow">return</span> test_case-&gt;should_run() &amp;&amp; test_case-&gt;Failed();
<a name="l00331"></a>00331 }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 <span class="comment">// Returns true iff test_case contains at least one test that should</span>
<a name="l00334"></a>00334 <span class="comment">// run.</span>
<a name="l00335"></a>00335 <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a122ad0eb3b65d677feb96b46ee9c6848">ShouldRunTestCase</a>(<span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>* test_case) {
<a name="l00336"></a>00336   <span class="keywordflow">return</span> test_case-&gt;should_run();
<a name="l00337"></a>00337 }
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="comment">// AssertHelper constructor.</span>
<a name="l00340"></a>00340 <a class="code" href="../../d7/d85/classtesting_1_1internal_1_1AssertHelper.html#ad2f02ef373bd4828ea059b997adf2ded">AssertHelper::AssertHelper</a>(<a class="code" href="../../d9/d98/classtesting_1_1TestPartResult.html#a1d1cfd8ffb84e947f82999c682b666a7">TestPartResult::Type</a> type,
<a name="l00341"></a>00341                            <span class="keyword">const</span> <span class="keywordtype">char</span>* file,
<a name="l00342"></a>00342                            <span class="keywordtype">int</span> line,
<a name="l00343"></a>00343                            <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="../../d6/dc2/namespacegtest__output__test.html#a536593b2a92b75b5c370d337feb4f615">message</a>)
<a name="l00344"></a>00344     : data_(<span class="keyword">new</span> AssertHelperData(type, file, line, message)) {
<a name="l00345"></a>00345 }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <a class="code" href="../../d7/d85/classtesting_1_1internal_1_1AssertHelper.html#a8b4957313ec967080674296be5b6e1bc">AssertHelper::~AssertHelper</a>() {
<a name="l00348"></a>00348   <span class="keyword">delete</span> <a class="code" href="../../d7/d85/classtesting_1_1internal_1_1AssertHelper.html#acb74cc67a1b0371db63e76b73ebf3a13">data_</a>;
<a name="l00349"></a>00349 }
<a name="l00350"></a>00350 
<a name="l00351"></a>00351 <span class="comment">// Message assignment, for assertion streaming support.</span>
<a name="l00352"></a>00352 <span class="keywordtype">void</span> <a class="code" href="../../d7/d85/classtesting_1_1internal_1_1AssertHelper.html#ad4e11743a05a2239e6e73b711c89e6d3">AssertHelper::operator=</a>(<span class="keyword">const</span> Message&amp; message)<span class="keyword"> const </span>{
<a name="l00353"></a>00353   <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#ad200090b11104aca39f25043701886cf">UnitTest::GetInstance</a>()-&gt;
<a name="l00354"></a>00354     AddTestPartResult(<a class="code" href="../../d7/d85/classtesting_1_1internal_1_1AssertHelper.html#acb74cc67a1b0371db63e76b73ebf3a13">data_</a>-&gt;<a class="code" href="../../da/d69/structtesting_1_1internal_1_1AssertHelper_1_1AssertHelperData.html#a411db9f4276ebb3fa7c47dd0ed5488ec">type</a>, <a class="code" href="../../d7/d85/classtesting_1_1internal_1_1AssertHelper.html#acb74cc67a1b0371db63e76b73ebf3a13">data_</a>-&gt;<a class="code" href="../../da/d69/structtesting_1_1internal_1_1AssertHelper_1_1AssertHelperData.html#aec64e701957578ef33343a1d705f9ecd">file</a>, <a class="code" href="../../d7/d85/classtesting_1_1internal_1_1AssertHelper.html#acb74cc67a1b0371db63e76b73ebf3a13">data_</a>-&gt;<a class="code" href="../../da/d69/structtesting_1_1internal_1_1AssertHelper_1_1AssertHelperData.html#ad42b220b1bf90b42fe461c4201c064a5">line</a>,
<a name="l00355"></a>00355                       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a92cc3c0f16012ce7143a5c3256c00a29">AppendUserMessage</a>(<a class="code" href="../../d7/d85/classtesting_1_1internal_1_1AssertHelper.html#acb74cc67a1b0371db63e76b73ebf3a13">data_</a>-&gt;<a class="code" href="../../da/d69/structtesting_1_1internal_1_1AssertHelper_1_1AssertHelperData.html#ad7d3cf03eb90f4520fac971afce980b6">message</a>, message),
<a name="l00356"></a>00356                       <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#ad200090b11104aca39f25043701886cf">UnitTest::GetInstance</a>()-&gt;<a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a7fc0e26510d98598fc6632b7e66a281d">impl</a>()
<a name="l00357"></a>00357                       -&gt;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a131dbc639dae87df46e7f92daad7c183">CurrentOsStackTraceExceptTop</a>(1)
<a name="l00358"></a>00358                       <span class="comment">// Skips the stack frame for this function itself.</span>
<a name="l00359"></a>00359                       );  <span class="comment">// NOLINT</span>
<a name="l00360"></a>00360 }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="comment">// Mutex for linked pointers.</span>
<a name="l00363"></a>00363 <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a05969f8c5401ec62be3a1f077c592c59">GTEST_DEFINE_STATIC_MUTEX_</a>(g_linked_ptr_mutex);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 <span class="comment">// Application pathname gotten in InitGoogleTest.</span>
<a name="l00366"></a>00366 String <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a00eb28c08b6a4da5387d466add2f742a">g_executable_path</a>;
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 <span class="comment">// Returns the current application&#39;s name, removing directory path if that</span>
<a name="l00369"></a>00369 <span class="comment">// is present.</span>
<a name="l00370"></a>00370 FilePath <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a4fc348184f2bc16ec2270cffb38de5dc">GetCurrentExecutableName</a>() {
<a name="l00371"></a>00371   FilePath result;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="preprocessor">#if GTEST_OS_WINDOWS</span>
<a name="l00374"></a>00374 <span class="preprocessor"></span>  result.<a class="code" href="../../de/dea/classtesting_1_1internal_1_1FilePath.html#a42b263db98b0796b43578baca9ba991d">Set</a>(FilePath(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a00eb28c08b6a4da5387d466add2f742a">g_executable_path</a>).RemoveExtension(<span class="stringliteral">&quot;exe&quot;</span>));
<a name="l00375"></a>00375 <span class="preprocessor">#else</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span>  result.Set(FilePath(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a00eb28c08b6a4da5387d466add2f742a">g_executable_path</a>));
<a name="l00377"></a>00377 <span class="preprocessor">#endif  // GTEST_OS_WINDOWS</span>
<a name="l00378"></a>00378 <span class="preprocessor"></span>
<a name="l00379"></a>00379   <span class="keywordflow">return</span> result.RemoveDirectoryName();
<a name="l00380"></a>00380 }
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 <span class="comment">// Functions for processing the gtest_output flag.</span>
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 <span class="comment">// Returns the output format, or &quot;&quot; for normal printed output.</span>
<a name="l00385"></a>00385 String <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#ab74136cb3ba94d7dbbda58ac081d9da2">UnitTestOptions::GetOutputFormat</a>() {
<a name="l00386"></a>00386   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> gtest_output_flag = <a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(<a class="code" href="../../d6/dc2/namespacegtest__output__test.html#acf316e258896197f4e917a6547e49532">output</a>).c_str();
<a name="l00387"></a>00387   <span class="keywordflow">if</span> (gtest_output_flag == NULL) <span class="keywordflow">return</span> String(<span class="stringliteral">&quot;&quot;</span>);
<a name="l00388"></a>00388 
<a name="l00389"></a>00389   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> colon = strchr(gtest_output_flag, <span class="charliteral">&#39;:&#39;</span>);
<a name="l00390"></a>00390   <span class="keywordflow">return</span> (colon == NULL) ?
<a name="l00391"></a>00391       String(gtest_output_flag) :
<a name="l00392"></a>00392       String(gtest_output_flag, colon - gtest_output_flag);
<a name="l00393"></a>00393 }
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 <span class="comment">// Returns the name of the requested output file, or the default if none</span>
<a name="l00396"></a>00396 <span class="comment">// was explicitly specified.</span>
<a name="l00397"></a>00397 String <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a765b1715a62bfdb0eaa4063b516dbc84">UnitTestOptions::GetAbsolutePathToOutputFile</a>() {
<a name="l00398"></a>00398   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> gtest_output_flag = <a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(<a class="code" href="../../d6/dc2/namespacegtest__output__test.html#acf316e258896197f4e917a6547e49532">output</a>).c_str();
<a name="l00399"></a>00399   <span class="keywordflow">if</span> (gtest_output_flag == NULL)
<a name="l00400"></a>00400     <span class="keywordflow">return</span> String(<span class="stringliteral">&quot;&quot;</span>);
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> colon = strchr(gtest_output_flag, <span class="charliteral">&#39;:&#39;</span>);
<a name="l00403"></a>00403   <span class="keywordflow">if</span> (colon == NULL)
<a name="l00404"></a>00404     <span class="keywordflow">return</span> String(<a class="code" href="../../de/dea/classtesting_1_1internal_1_1FilePath.html#ae8c11e9d5d51f4266c6507aeb34ba55b">internal::FilePath::ConcatPaths</a>(
<a name="l00405"></a>00405                internal::FilePath(
<a name="l00406"></a>00406                    <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#ad200090b11104aca39f25043701886cf">UnitTest::GetInstance</a>()-&gt;original_working_dir()),
<a name="l00407"></a>00407                internal::FilePath(<a class="code" href="../../d0/d75/namespacetesting.html#a770a114e153c518bc30b271458d7591a">kDefaultOutputFile</a>)).ToString() );
<a name="l00408"></a>00408 
<a name="l00409"></a>00409   internal::FilePath output_name(colon + 1);
<a name="l00410"></a>00410   <span class="keywordflow">if</span> (!output_name.IsAbsolutePath())
<a name="l00411"></a>00411     <span class="comment">// TODO(wan@google.com): on Windows \some\path is not an absolute</span>
<a name="l00412"></a>00412     <span class="comment">// path (as its meaning depends on the current drive), yet the</span>
<a name="l00413"></a>00413     <span class="comment">// following logic for turning it into an absolute path is wrong.</span>
<a name="l00414"></a>00414     <span class="comment">// Fix it.</span>
<a name="l00415"></a>00415     output_name = <a class="code" href="../../de/dea/classtesting_1_1internal_1_1FilePath.html#ae8c11e9d5d51f4266c6507aeb34ba55b">internal::FilePath::ConcatPaths</a>(
<a name="l00416"></a>00416         internal::FilePath(<a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#ad200090b11104aca39f25043701886cf">UnitTest::GetInstance</a>()-&gt;original_working_dir()),
<a name="l00417"></a>00417         internal::FilePath(colon + 1));
<a name="l00418"></a>00418 
<a name="l00419"></a>00419   <span class="keywordflow">if</span> (!output_name.IsDirectory())
<a name="l00420"></a>00420     <span class="keywordflow">return</span> output_name.<a class="code" href="../../de/dea/classtesting_1_1internal_1_1FilePath.html#abf9cb98d5859802d6b90f01feda7b3ff">ToString</a>();
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   internal::FilePath result(<a class="code" href="../../de/dea/classtesting_1_1internal_1_1FilePath.html#a01f72e14ad442c88e941571cb65228f4">internal::FilePath::GenerateUniqueFileName</a>(
<a name="l00423"></a>00423       output_name, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a4fc348184f2bc16ec2270cffb38de5dc">internal::GetCurrentExecutableName</a>(),
<a name="l00424"></a>00424       <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#ab74136cb3ba94d7dbbda58ac081d9da2">GetOutputFormat</a>().c_str()));
<a name="l00425"></a>00425   <span class="keywordflow">return</span> result.ToString();
<a name="l00426"></a>00426 }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 <span class="comment">// Returns true iff the wildcard pattern matches the string.  The</span>
<a name="l00429"></a>00429 <span class="comment">// first &#39;:&#39; or &#39;\0&#39; character in pattern marks the end of it.</span>
<a name="l00430"></a>00430 <span class="comment">//</span>
<a name="l00431"></a>00431 <span class="comment">// This recursive algorithm isn&#39;t very efficient, but is clear and</span>
<a name="l00432"></a>00432 <span class="comment">// works well enough for matching test names, which are short.</span>
<a name="l00433"></a>00433 <span class="keywordtype">bool</span> <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a6ee16a491a18920bed2d8e1c5a6be381">UnitTestOptions::PatternMatchesString</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *pattern,
<a name="l00434"></a>00434                                            <span class="keyword">const</span> <span class="keywordtype">char</span> *str) {
<a name="l00435"></a>00435   <span class="keywordflow">switch</span> (*pattern) {
<a name="l00436"></a>00436     <span class="keywordflow">case</span> <span class="charliteral">&#39;\0&#39;</span>:
<a name="l00437"></a>00437     <span class="keywordflow">case</span> <span class="charliteral">&#39;:&#39;</span>:  <span class="comment">// Either &#39;:&#39; or &#39;\0&#39; marks the end of the pattern.</span>
<a name="l00438"></a>00438       <span class="keywordflow">return</span> *str == <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00439"></a>00439     <span class="keywordflow">case</span> <span class="charliteral">&#39;?&#39;</span>:  <span class="comment">// Matches any single character.</span>
<a name="l00440"></a>00440       <span class="keywordflow">return</span> *str != <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a6ee16a491a18920bed2d8e1c5a6be381">PatternMatchesString</a>(pattern + 1, str + 1);
<a name="l00441"></a>00441     <span class="keywordflow">case</span> <span class="charliteral">&#39;*&#39;</span>:  <span class="comment">// Matches any string (possibly empty) of characters.</span>
<a name="l00442"></a>00442       <span class="keywordflow">return</span> (*str != <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a6ee16a491a18920bed2d8e1c5a6be381">PatternMatchesString</a>(pattern, str + 1)) ||
<a name="l00443"></a>00443           <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a6ee16a491a18920bed2d8e1c5a6be381">PatternMatchesString</a>(pattern + 1, str);
<a name="l00444"></a>00444     <span class="keywordflow">default</span>:  <span class="comment">// Non-special character.  Matches itself.</span>
<a name="l00445"></a>00445       <span class="keywordflow">return</span> *pattern == *str &amp;&amp;
<a name="l00446"></a>00446           <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a6ee16a491a18920bed2d8e1c5a6be381">PatternMatchesString</a>(pattern + 1, str + 1);
<a name="l00447"></a>00447   }
<a name="l00448"></a>00448 }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450 <span class="keywordtype">bool</span> <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a2668b814cce76871ca391416634bd020">UnitTestOptions::MatchesFilter</a>(<span class="keyword">const</span> String&amp; name, <span class="keyword">const</span> <span class="keywordtype">char</span>* filter) {
<a name="l00451"></a>00451   <span class="keyword">const</span> <span class="keywordtype">char</span> *cur_pattern = filter;
<a name="l00452"></a>00452   <span class="keywordflow">for</span> (;;) {
<a name="l00453"></a>00453     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a6ee16a491a18920bed2d8e1c5a6be381">PatternMatchesString</a>(cur_pattern, name.c_str())) {
<a name="l00454"></a>00454       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00455"></a>00455     }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457     <span class="comment">// Finds the next pattern in the filter.</span>
<a name="l00458"></a>00458     cur_pattern = strchr(cur_pattern, <span class="charliteral">&#39;:&#39;</span>);
<a name="l00459"></a>00459 
<a name="l00460"></a>00460     <span class="comment">// Returns if no more pattern can be found.</span>
<a name="l00461"></a>00461     <span class="keywordflow">if</span> (cur_pattern == NULL) {
<a name="l00462"></a>00462       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00463"></a>00463     }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465     <span class="comment">// Skips the pattern separater (the &#39;:&#39; character).</span>
<a name="l00466"></a>00466     cur_pattern++;
<a name="l00467"></a>00467   }
<a name="l00468"></a>00468 }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 <span class="comment">// TODO(keithray): move String function implementations to gtest-string.cc.</span>
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 <span class="comment">// Returns true iff the user-specified filter matches the test case</span>
<a name="l00473"></a>00473 <span class="comment">// name and the test name.</span>
<a name="l00474"></a>00474 <span class="keywordtype">bool</span> <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a5729694202f5ce85701d892a6c65f921">UnitTestOptions::FilterMatchesTest</a>(<span class="keyword">const</span> String &amp;test_case_name,
<a name="l00475"></a>00475                                         <span class="keyword">const</span> String &amp;test_name) {
<a name="l00476"></a>00476   <span class="keyword">const</span> String&amp; full_name = <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;%s.%s&quot;</span>,
<a name="l00477"></a>00477                                            test_case_name.c_str(),
<a name="l00478"></a>00478                                            test_name.c_str());
<a name="l00479"></a>00479 
<a name="l00480"></a>00480   <span class="comment">// Split --gtest_filter at &#39;-&#39;, if there is one, to separate into</span>
<a name="l00481"></a>00481   <span class="comment">// positive filter and negative filter portions</span>
<a name="l00482"></a>00482   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> p = <a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(filter).c_str();
<a name="l00483"></a>00483   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> dash = strchr(p, <span class="charliteral">&#39;-&#39;</span>);
<a name="l00484"></a>00484   String positive;
<a name="l00485"></a>00485   String negative;
<a name="l00486"></a>00486   <span class="keywordflow">if</span> (dash == NULL) {
<a name="l00487"></a>00487     positive = <a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(filter).c_str();  <span class="comment">// Whole string is a positive filter</span>
<a name="l00488"></a>00488     negative = String(<span class="stringliteral">&quot;&quot;</span>);
<a name="l00489"></a>00489   } <span class="keywordflow">else</span> {
<a name="l00490"></a>00490     positive = String(p, dash - p);  <span class="comment">// Everything up to the dash</span>
<a name="l00491"></a>00491     negative = String(dash+1);       <span class="comment">// Everything after the dash</span>
<a name="l00492"></a>00492     <span class="keywordflow">if</span> (positive.empty()) {
<a name="l00493"></a>00493       <span class="comment">// Treat &#39;-test1&#39; as the same as &#39;*-test1&#39;</span>
<a name="l00494"></a>00494       positive = <a class="code" href="../../d0/d75/namespacetesting.html#a1bf2eaf73b98e0bc07b11550f91986a1">kUniversalFilter</a>;
<a name="l00495"></a>00495     }
<a name="l00496"></a>00496   }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498   <span class="comment">// A filter is a colon-separated list of patterns.  It matches a</span>
<a name="l00499"></a>00499   <span class="comment">// test if any pattern in it matches the test.</span>
<a name="l00500"></a>00500   <span class="keywordflow">return</span> (<a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a2668b814cce76871ca391416634bd020">MatchesFilter</a>(full_name, positive.c_str()) &amp;&amp;
<a name="l00501"></a>00501           !<a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a2668b814cce76871ca391416634bd020">MatchesFilter</a>(full_name, negative.c_str()));
<a name="l00502"></a>00502 }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="preprocessor">#if GTEST_HAS_SEH</span>
<a name="l00505"></a>00505 <span class="preprocessor"></span><span class="comment">// Returns EXCEPTION_EXECUTE_HANDLER if Google Test should handle the</span>
<a name="l00506"></a>00506 <span class="comment">// given SEH exception, or EXCEPTION_CONTINUE_SEARCH otherwise.</span>
<a name="l00507"></a>00507 <span class="comment">// This function is useful as an __except condition.</span>
<a name="l00508"></a>00508 <span class="keywordtype">int</span> UnitTestOptions::GTestShouldProcessSEH(DWORD exception_code) {
<a name="l00509"></a>00509   <span class="comment">// Google Test should handle a SEH exception if:</span>
<a name="l00510"></a>00510   <span class="comment">//   1. the user wants it to, AND</span>
<a name="l00511"></a>00511   <span class="comment">//   2. this is not a breakpoint exception, AND</span>
<a name="l00512"></a>00512   <span class="comment">//   3. this is not a C++ exception (VC++ implements them via SEH,</span>
<a name="l00513"></a>00513   <span class="comment">//      apparently).</span>
<a name="l00514"></a>00514   <span class="comment">//</span>
<a name="l00515"></a>00515   <span class="comment">// SEH exception code for C++ exceptions.</span>
<a name="l00516"></a>00516   <span class="comment">// (see http://support.microsoft.com/kb/185294 for more information).</span>
<a name="l00517"></a>00517   <span class="keyword">const</span> DWORD kCxxExceptionCode = 0xe06d7363;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519   <span class="keywordtype">bool</span> should_handle = <span class="keyword">true</span>;
<a name="l00520"></a>00520 
<a name="l00521"></a>00521   <span class="keywordflow">if</span> (!<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(catch_exceptions))
<a name="l00522"></a>00522     should_handle = <span class="keyword">false</span>;
<a name="l00523"></a>00523   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exception_code == EXCEPTION_BREAKPOINT)
<a name="l00524"></a>00524     should_handle = <span class="keyword">false</span>;
<a name="l00525"></a>00525   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exception_code == kCxxExceptionCode)
<a name="l00526"></a>00526     should_handle = <span class="keyword">false</span>;
<a name="l00527"></a>00527 
<a name="l00528"></a>00528   <span class="keywordflow">return</span> should_handle ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;
<a name="l00529"></a>00529 }
<a name="l00530"></a>00530 <span class="preprocessor">#endif  // GTEST_HAS_SEH</span>
<a name="l00531"></a>00531 <span class="preprocessor"></span>
<a name="l00532"></a>00532 }  <span class="comment">// namespace internal</span>
<a name="l00533"></a>00533 
<a name="l00534"></a>00534 <span class="comment">// The c&#39;tor sets this object as the test part result reporter used by</span>
<a name="l00535"></a>00535 <span class="comment">// Google Test.  The &#39;result&#39; parameter specifies where to report the</span>
<a name="l00536"></a>00536 <span class="comment">// results. Intercepts only failures from the current thread.</span>
<a name="l00537"></a>00537 <a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#af5c28bc39bc95da0223fc3f926419aa2">ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter</a>(
<a name="l00538"></a>00538     TestPartResultArray* result)
<a name="l00539"></a>00539     : intercept_mode_(INTERCEPT_ONLY_CURRENT_THREAD),
<a name="l00540"></a>00540       result_(result) {
<a name="l00541"></a>00541   Init();
<a name="l00542"></a>00542 }
<a name="l00543"></a>00543 
<a name="l00544"></a>00544 <span class="comment">// The c&#39;tor sets this object as the test part result reporter used by</span>
<a name="l00545"></a>00545 <span class="comment">// Google Test.  The &#39;result&#39; parameter specifies where to report the</span>
<a name="l00546"></a>00546 <span class="comment">// results.</span>
<a name="l00547"></a>00547 <a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#af5c28bc39bc95da0223fc3f926419aa2">ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter</a>(
<a name="l00548"></a>00548     InterceptMode intercept_mode, TestPartResultArray* result)
<a name="l00549"></a>00549     : intercept_mode_(intercept_mode),
<a name="l00550"></a>00550       result_(result) {
<a name="l00551"></a>00551   Init();
<a name="l00552"></a>00552 }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="keywordtype">void</span> <a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#a1e3b6d38df0786ccf7f938d60e386aae">ScopedFakeTestPartResultReporter::Init</a>() {
<a name="l00555"></a>00555   internal::UnitTestImpl* <span class="keyword">const</span> impl = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3ae874a4030c4aa27d77d67bf08d9e1d">internal::GetUnitTestImpl</a>();
<a name="l00556"></a>00556   <span class="keywordflow">if</span> (<a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#ac41a6872b1cb8a2d43546199dd59ae6e">intercept_mode_</a> == <a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#a1d75549697022f869ab9d184916077d2a9f8eed77d71d4d09bcf22eab90bf2a29">INTERCEPT_ALL_THREADS</a>) {
<a name="l00557"></a>00557     <a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#a6931c672d50d49d040805ae729d9ac1c">old_reporter_</a> = impl-&gt;GetGlobalTestPartResultReporter();
<a name="l00558"></a>00558     impl-&gt;SetGlobalTestPartResultReporter(<span class="keyword">this</span>);
<a name="l00559"></a>00559   } <span class="keywordflow">else</span> {
<a name="l00560"></a>00560     <a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#a6931c672d50d49d040805ae729d9ac1c">old_reporter_</a> = impl-&gt;GetTestPartResultReporterForCurrentThread();
<a name="l00561"></a>00561     impl-&gt;SetTestPartResultReporterForCurrentThread(<span class="keyword">this</span>);
<a name="l00562"></a>00562   }
<a name="l00563"></a>00563 }
<a name="l00564"></a>00564 
<a name="l00565"></a>00565 <span class="comment">// The d&#39;tor restores the test part result reporter used by Google Test</span>
<a name="l00566"></a>00566 <span class="comment">// before.</span>
<a name="l00567"></a>00567 <a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#ad424dbca5099cec78b6aa2ca4c3aac75">ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter</a>() {
<a name="l00568"></a>00568   internal::UnitTestImpl* <span class="keyword">const</span> impl = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3ae874a4030c4aa27d77d67bf08d9e1d">internal::GetUnitTestImpl</a>();
<a name="l00569"></a>00569   <span class="keywordflow">if</span> (<a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#ac41a6872b1cb8a2d43546199dd59ae6e">intercept_mode_</a> == <a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#a1d75549697022f869ab9d184916077d2a9f8eed77d71d4d09bcf22eab90bf2a29">INTERCEPT_ALL_THREADS</a>) {
<a name="l00570"></a>00570     impl-&gt;SetGlobalTestPartResultReporter(<a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#a6931c672d50d49d040805ae729d9ac1c">old_reporter_</a>);
<a name="l00571"></a>00571   } <span class="keywordflow">else</span> {
<a name="l00572"></a>00572     impl-&gt;SetTestPartResultReporterForCurrentThread(<a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#a6931c672d50d49d040805ae729d9ac1c">old_reporter_</a>);
<a name="l00573"></a>00573   }
<a name="l00574"></a>00574 }
<a name="l00575"></a>00575 
<a name="l00576"></a>00576 <span class="comment">// Increments the test part result count and remembers the result.</span>
<a name="l00577"></a>00577 <span class="comment">// This method is from the TestPartResultReporterInterface interface.</span>
<a name="l00578"></a>00578 <span class="keywordtype">void</span> <a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#acd54d55b39f168c91b6370be62cef448">ScopedFakeTestPartResultReporter::ReportTestPartResult</a>(
<a name="l00579"></a>00579     <span class="keyword">const</span> TestPartResult&amp; result) {
<a name="l00580"></a>00580   <a class="code" href="../../df/d0c/classtesting_1_1ScopedFakeTestPartResultReporter.html#a520bca09fbdcb2a2a36fea6b1c438b53">result_</a>-&gt;<a class="code" href="../../dc/dce/classtesting_1_1TestPartResultArray.html#a3a9ecce0ea05e8ce5e1d3dbb2b8e1f97">Append</a>(result);
<a name="l00581"></a>00581 }
<a name="l00582"></a>00582 
<a name="l00583"></a>00583 <span class="keyword">namespace </span>internal {
<a name="l00584"></a>00584 
<a name="l00585"></a>00585 <span class="comment">// Returns the type ID of ::testing::Test.  We should always call this</span>
<a name="l00586"></a>00586 <span class="comment">// instead of GetTypeId&lt; ::testing::Test&gt;() to get the type ID of</span>
<a name="l00587"></a>00587 <span class="comment">// testing::Test.  This is to work around a suspected linker bug when</span>
<a name="l00588"></a>00588 <span class="comment">// using Google Test as a framework on Mac OS X.  The bug causes</span>
<a name="l00589"></a>00589 <span class="comment">// GetTypeId&lt; ::testing::Test&gt;() to return different values depending</span>
<a name="l00590"></a>00590 <span class="comment">// on whether the call is from the Google Test framework itself or</span>
<a name="l00591"></a>00591 <span class="comment">// from user test code.  GetTestTypeId() is guaranteed to always</span>
<a name="l00592"></a>00592 <span class="comment">// return the same value, as it always calls GetTypeId&lt;&gt;() from the</span>
<a name="l00593"></a>00593 <span class="comment">// gtest.cc, which is within the Google Test framework.</span>
<a name="l00594"></a>00594 <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac8e91f0c6a06c0361dc3152ddfeb2342">TypeId</a> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3e7f71e983859c908bae4ec8d593ff58">GetTestTypeId</a>() {
<a name="l00595"></a>00595   <span class="keywordflow">return</span> GetTypeId&lt;Test&gt;();
<a name="l00596"></a>00596 }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 <span class="comment">// The value of GetTestTypeId() as seen from within the Google Test</span>
<a name="l00599"></a>00599 <span class="comment">// library.  This is solely for testing GetTestTypeId().</span>
<a name="l00600"></a>00600 <span class="keyword">extern</span> <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac8e91f0c6a06c0361dc3152ddfeb2342">TypeId</a> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3117ae1f8725f2828385dd7d9fb91ffc">kTestTypeIdInGoogleTest</a> = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3e7f71e983859c908bae4ec8d593ff58">GetTestTypeId</a>();
<a name="l00601"></a>00601 
<a name="l00602"></a>00602 <span class="comment">// This predicate-formatter checks that &#39;results&#39; contains a test part</span>
<a name="l00603"></a>00603 <span class="comment">// failure of the given type and that the failure message contains the</span>
<a name="l00604"></a>00604 <span class="comment">// given substring.</span>
<a name="l00605"></a>00605 AssertionResult <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a7a411c778e3dd9249e6c518dabc21ca4">HasOneFailure</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="comment">/* results_expr */</span>,
<a name="l00606"></a>00606                               <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="comment">/* type_expr */</span>,
<a name="l00607"></a>00607                               <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="comment">/* substr_expr */</span>,
<a name="l00608"></a>00608                               <span class="keyword">const</span> TestPartResultArray&amp; results,
<a name="l00609"></a>00609                               <a class="code" href="../../d9/d98/classtesting_1_1TestPartResult.html#a1d1cfd8ffb84e947f82999c682b666a7">TestPartResult::Type</a> type,
<a name="l00610"></a>00610                               <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; substr) {
<a name="l00611"></a>00611   <span class="keyword">const</span> String expected(type == <a class="code" href="../../d9/d98/classtesting_1_1TestPartResult.html#a1d1cfd8ffb84e947f82999c682b666a7a902a473edef7eeb3e0499901a220ecfd">TestPartResult::kFatalFailure</a> ?
<a name="l00612"></a>00612                         <span class="stringliteral">&quot;1 fatal failure&quot;</span> :
<a name="l00613"></a>00613                         <span class="stringliteral">&quot;1 non-fatal failure&quot;</span>);
<a name="l00614"></a>00614   Message msg;
<a name="l00615"></a>00615   <span class="keywordflow">if</span> (results.size() != 1) {
<a name="l00616"></a>00616     msg &lt;&lt; <span class="stringliteral">&quot;Expected: &quot;</span> &lt;&lt; expected &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>
<a name="l00617"></a>00617         &lt;&lt; <span class="stringliteral">&quot;  Actual: &quot;</span> &lt;&lt; results.size() &lt;&lt; <span class="stringliteral">&quot; failures&quot;</span>;
<a name="l00618"></a>00618     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; results.size(); i++) {
<a name="l00619"></a>00619       msg &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; results.GetTestPartResult(i);
<a name="l00620"></a>00620     }
<a name="l00621"></a>00621     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>() &lt;&lt; msg;
<a name="l00622"></a>00622   }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624   <span class="keyword">const</span> TestPartResult&amp; r = results.GetTestPartResult(0);
<a name="l00625"></a>00625   <span class="keywordflow">if</span> (r.type() != type) {
<a name="l00626"></a>00626     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>() &lt;&lt; <span class="stringliteral">&quot;Expected: &quot;</span> &lt;&lt; expected &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>
<a name="l00627"></a>00627                               &lt;&lt; <span class="stringliteral">&quot;  Actual:\n&quot;</span>
<a name="l00628"></a>00628                               &lt;&lt; r;
<a name="l00629"></a>00629   }
<a name="l00630"></a>00630 
<a name="l00631"></a>00631   <span class="keywordflow">if</span> (strstr(r.message(), substr.c_str()) == NULL) {
<a name="l00632"></a>00632     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>() &lt;&lt; <span class="stringliteral">&quot;Expected: &quot;</span> &lt;&lt; expected &lt;&lt; <span class="stringliteral">&quot; containing \&quot;&quot;</span>
<a name="l00633"></a>00633                               &lt;&lt; substr &lt;&lt; <span class="stringliteral">&quot;\&quot;\n&quot;</span>
<a name="l00634"></a>00634                               &lt;&lt; <span class="stringliteral">&quot;  Actual:\n&quot;</span>
<a name="l00635"></a>00635                               &lt;&lt; r;
<a name="l00636"></a>00636   }
<a name="l00637"></a>00637 
<a name="l00638"></a>00638   <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l00639"></a>00639 }
<a name="l00640"></a>00640 
<a name="l00641"></a>00641 <span class="comment">// The constructor of SingleFailureChecker remembers where to look up</span>
<a name="l00642"></a>00642 <span class="comment">// test part results, what type of failure we expect, and what</span>
<a name="l00643"></a>00643 <span class="comment">// substring the failure message should contain.</span>
<a name="l00644"></a>00644 <a class="code" href="../../d8/d07/classtesting_1_1internal_1_1SingleFailureChecker.html#a7bcb284c71b50648c3ca4c3e7b22d8fe">SingleFailureChecker:: SingleFailureChecker</a>(
<a name="l00645"></a>00645     <span class="keyword">const</span> TestPartResultArray* results,
<a name="l00646"></a>00646     <a class="code" href="../../d9/d98/classtesting_1_1TestPartResult.html#a1d1cfd8ffb84e947f82999c682b666a7">TestPartResult::Type</a> type,
<a name="l00647"></a>00647     <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; substr)
<a name="l00648"></a>00648     : results_(results),
<a name="l00649"></a>00649       type_(type),
<a name="l00650"></a>00650       substr_(substr) {}
<a name="l00651"></a>00651 
<a name="l00652"></a>00652 <span class="comment">// The destructor of SingleFailureChecker verifies that the given</span>
<a name="l00653"></a>00653 <span class="comment">// TestPartResultArray contains exactly one failure that has the given</span>
<a name="l00654"></a>00654 <span class="comment">// type and contains the given substring.  If that&#39;s not the case, a</span>
<a name="l00655"></a>00655 <span class="comment">// non-fatal failure will be generated.</span>
<a name="l00656"></a>00656 <a class="code" href="../../d8/d07/classtesting_1_1internal_1_1SingleFailureChecker.html#a800e9d220e8d92357360adbe84be2736">SingleFailureChecker::~SingleFailureChecker</a>() {
<a name="l00657"></a>00657   <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a7285708fa5d37d6d8ed5b5e59da08bae">EXPECT_PRED_FORMAT3</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a7a411c778e3dd9249e6c518dabc21ca4">HasOneFailure</a>, *<a class="code" href="../../d8/d07/classtesting_1_1internal_1_1SingleFailureChecker.html#a014e6c17ef59640f4a9607cfe331a628">results_</a>, <a class="code" href="../../d8/d07/classtesting_1_1internal_1_1SingleFailureChecker.html#a3155cc24deee3978aed78a25da6180da">type_</a>, <a class="code" href="../../d8/d07/classtesting_1_1internal_1_1SingleFailureChecker.html#a6d511a37e5638d646986452a9b195d23">substr_</a>);
<a name="l00658"></a>00658 }
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 <a class="code" href="../../d1/d1c/classtesting_1_1internal_1_1DefaultGlobalTestPartResultReporter.html#af6608da1bb27c0d120ff1683800e1e82">DefaultGlobalTestPartResultReporter::DefaultGlobalTestPartResultReporter</a>(
<a name="l00661"></a>00661     UnitTestImpl* unit_test) : unit_test_(unit_test) {}
<a name="l00662"></a>00662 
<a name="l00663"></a>00663 <span class="keywordtype">void</span> <a class="code" href="../../d1/d1c/classtesting_1_1internal_1_1DefaultGlobalTestPartResultReporter.html#acd54d55b39f168c91b6370be62cef448">DefaultGlobalTestPartResultReporter::ReportTestPartResult</a>(
<a name="l00664"></a>00664     <span class="keyword">const</span> TestPartResult&amp; result) {
<a name="l00665"></a>00665   <a class="code" href="../../d1/d1c/classtesting_1_1internal_1_1DefaultGlobalTestPartResultReporter.html#a82c5334452afe614170bbc7ee736969c">unit_test_</a>-&gt;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a385bee93ae6043262a860574aa59ba1a">current_test_result</a>()-&gt;<a class="code" href="../../d6/d6e/classtesting_1_1TestResult.html#a3fac5d4edaec29072c5e9d735434471a">AddTestPartResult</a>(result);
<a name="l00666"></a>00666   <a class="code" href="../../d1/d1c/classtesting_1_1internal_1_1DefaultGlobalTestPartResultReporter.html#a82c5334452afe614170bbc7ee736969c">unit_test_</a>-&gt;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a371c481b63deeb0ecd47f42b4720480b">listeners</a>()-&gt;<a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#af7cfacdf90b4ba59566c16d95ee5d6cc">repeater</a>()-&gt;<a class="code" href="../../d0/d51/classtesting_1_1TestEventListener.html#a6897200761af7db2d3212d5d3c1571d9">OnTestPartResult</a>(result);
<a name="l00667"></a>00667 }
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 <a class="code" href="../../d6/d16/classtesting_1_1internal_1_1DefaultPerThreadTestPartResultReporter.html#a49af24a9082840cd2f2880a83f51e540">DefaultPerThreadTestPartResultReporter::DefaultPerThreadTestPartResultReporter</a>(
<a name="l00670"></a>00670     UnitTestImpl* unit_test) : unit_test_(unit_test) {}
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 <span class="keywordtype">void</span> <a class="code" href="../../d6/d16/classtesting_1_1internal_1_1DefaultPerThreadTestPartResultReporter.html#acd54d55b39f168c91b6370be62cef448">DefaultPerThreadTestPartResultReporter::ReportTestPartResult</a>(
<a name="l00673"></a>00673     <span class="keyword">const</span> TestPartResult&amp; result) {
<a name="l00674"></a>00674   <a class="code" href="../../d6/d16/classtesting_1_1internal_1_1DefaultPerThreadTestPartResultReporter.html#a82c5334452afe614170bbc7ee736969c">unit_test_</a>-&gt;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a95cd925236936aab4dd3604aaeae9b15">GetGlobalTestPartResultReporter</a>()-&gt;<a class="code" href="../../df/d70/classtesting_1_1TestPartResultReporterInterface.html#a49d731c71005e51d8531193f29efb71f">ReportTestPartResult</a>(result);
<a name="l00675"></a>00675 }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 <span class="comment">// Returns the global test part result reporter.</span>
<a name="l00678"></a>00678 TestPartResultReporterInterface*
<a name="l00679"></a>00679 <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a95cd925236936aab4dd3604aaeae9b15">UnitTestImpl::GetGlobalTestPartResultReporter</a>() {
<a name="l00680"></a>00680   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0ceb93bd27638edfa3ced2469951fd99">internal::MutexLock</a> lock(&amp;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a44a033b8d726114e3fb407ec77c9e409">global_test_part_result_reporter_mutex_</a>);
<a name="l00681"></a>00681   <span class="keywordflow">return</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a733fa2b39275ffbabc99d121d88dff5c">global_test_part_result_repoter_</a>;
<a name="l00682"></a>00682 }
<a name="l00683"></a>00683 
<a name="l00684"></a>00684 <span class="comment">// Sets the global test part result reporter.</span>
<a name="l00685"></a>00685 <span class="keywordtype">void</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a5d379c4ca61275c92e23f8605a67c918">UnitTestImpl::SetGlobalTestPartResultReporter</a>(
<a name="l00686"></a>00686     TestPartResultReporterInterface* reporter) {
<a name="l00687"></a>00687   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0ceb93bd27638edfa3ced2469951fd99">internal::MutexLock</a> lock(&amp;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a44a033b8d726114e3fb407ec77c9e409">global_test_part_result_reporter_mutex_</a>);
<a name="l00688"></a>00688   <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a733fa2b39275ffbabc99d121d88dff5c">global_test_part_result_repoter_</a> = reporter;
<a name="l00689"></a>00689 }
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 <span class="comment">// Returns the test part result reporter for the current thread.</span>
<a name="l00692"></a>00692 TestPartResultReporterInterface*
<a name="l00693"></a>00693 <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a300e589a3266a50b3c75dc14cc9673ed">UnitTestImpl::GetTestPartResultReporterForCurrentThread</a>() {
<a name="l00694"></a>00694   <span class="keywordflow">return</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a2f151c72a75fa55edeca99b3deb451e4">per_thread_test_part_result_reporter_</a>.<a class="code" href="../../d4/d47/classtesting_1_1internal_1_1ThreadLocal.html#a5483146ccae665a5ac9dbe92d47d6f0e">get</a>();
<a name="l00695"></a>00695 }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 <span class="comment">// Sets the test part result reporter for the current thread.</span>
<a name="l00698"></a>00698 <span class="keywordtype">void</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab71b8e31b6a6f77a3c80e76f1a17336c">UnitTestImpl::SetTestPartResultReporterForCurrentThread</a>(
<a name="l00699"></a>00699     TestPartResultReporterInterface* reporter) {
<a name="l00700"></a>00700   <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a2f151c72a75fa55edeca99b3deb451e4">per_thread_test_part_result_reporter_</a>.<a class="code" href="../../d4/d47/classtesting_1_1internal_1_1ThreadLocal.html#a0f806efa754adc9f722b43aabba42dd4">set</a>(reporter);
<a name="l00701"></a>00701 }
<a name="l00702"></a>00702 
<a name="l00703"></a>00703 <span class="comment">// Gets the number of successful test cases.</span>
<a name="l00704"></a>00704 <span class="keywordtype">int</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a846de5ff509b207bca6a55237d035a1f">UnitTestImpl::successful_test_case_count</a>()<span class="keyword"> const </span>{
<a name="l00705"></a>00705   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab37ae76c997078f65ba28f35b3657151">CountIf</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac961033179851d1a8ff0e009ddeece03">TestCasePassed</a>);
<a name="l00706"></a>00706 }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708 <span class="comment">// Gets the number of failed test cases.</span>
<a name="l00709"></a>00709 <span class="keywordtype">int</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a48f76adebf95bff36f0026f0a66c7057">UnitTestImpl::failed_test_case_count</a>()<span class="keyword"> const </span>{
<a name="l00710"></a>00710   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab37ae76c997078f65ba28f35b3657151">CountIf</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9cc56cc516fd6f9e3e1d7ab2183e5b2c">TestCaseFailed</a>);
<a name="l00711"></a>00711 }
<a name="l00712"></a>00712 
<a name="l00713"></a>00713 <span class="comment">// Gets the number of all test cases.</span>
<a name="l00714"></a>00714 <span class="keywordtype">int</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#aba8c18261c58f301e1e80049a0781d84">UnitTestImpl::total_test_case_count</a>()<span class="keyword"> const </span>{
<a name="l00715"></a>00715   <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>.size());
<a name="l00716"></a>00716 }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718 <span class="comment">// Gets the number of all test cases that contain at least one test</span>
<a name="l00719"></a>00719 <span class="comment">// that should run.</span>
<a name="l00720"></a>00720 <span class="keywordtype">int</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#adf212bae576e88dfb77bd114f01bc117">UnitTestImpl::test_case_to_run_count</a>()<span class="keyword"> const </span>{
<a name="l00721"></a>00721   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab37ae76c997078f65ba28f35b3657151">CountIf</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a122ad0eb3b65d677feb96b46ee9c6848">ShouldRunTestCase</a>);
<a name="l00722"></a>00722 }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 <span class="comment">// Gets the number of successful tests.</span>
<a name="l00725"></a>00725 <span class="keywordtype">int</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab955f67bc1fe8ef62a7e72906ccece2a">UnitTestImpl::successful_test_count</a>()<span class="keyword"> const </span>{
<a name="l00726"></a>00726   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9be4a7736e0e7d8754551c6a827c376d">SumOverTestCaseList</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>, &amp;<a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html#ab955f67bc1fe8ef62a7e72906ccece2a">TestCase::successful_test_count</a>);
<a name="l00727"></a>00727 }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729 <span class="comment">// Gets the number of failed tests.</span>
<a name="l00730"></a>00730 <span class="keywordtype">int</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#afd8bbd35c7ee99960abb321cfdff3119">UnitTestImpl::failed_test_count</a>()<span class="keyword"> const </span>{
<a name="l00731"></a>00731   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9be4a7736e0e7d8754551c6a827c376d">SumOverTestCaseList</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>, &amp;<a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html#afd8bbd35c7ee99960abb321cfdff3119">TestCase::failed_test_count</a>);
<a name="l00732"></a>00732 }
<a name="l00733"></a>00733 
<a name="l00734"></a>00734 <span class="comment">// Gets the number of disabled tests.</span>
<a name="l00735"></a>00735 <span class="keywordtype">int</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a10ec677118627074973fc20c9271b204">UnitTestImpl::disabled_test_count</a>()<span class="keyword"> const </span>{
<a name="l00736"></a>00736   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9be4a7736e0e7d8754551c6a827c376d">SumOverTestCaseList</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>, &amp;<a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html#a10ec677118627074973fc20c9271b204">TestCase::disabled_test_count</a>);
<a name="l00737"></a>00737 }
<a name="l00738"></a>00738 
<a name="l00739"></a>00739 <span class="comment">// Gets the number of all tests.</span>
<a name="l00740"></a>00740 <span class="keywordtype">int</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a0eb7286957aeb126d9926c33407a15a3">UnitTestImpl::total_test_count</a>()<span class="keyword"> const </span>{
<a name="l00741"></a>00741   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9be4a7736e0e7d8754551c6a827c376d">SumOverTestCaseList</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>, &amp;<a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html#a0eb7286957aeb126d9926c33407a15a3">TestCase::total_test_count</a>);
<a name="l00742"></a>00742 }
<a name="l00743"></a>00743 
<a name="l00744"></a>00744 <span class="comment">// Gets the number of tests that should run.</span>
<a name="l00745"></a>00745 <span class="keywordtype">int</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#aa6eccf86072f4f8ddd0bea30dfd45912">UnitTestImpl::test_to_run_count</a>()<span class="keyword"> const </span>{
<a name="l00746"></a>00746   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9be4a7736e0e7d8754551c6a827c376d">SumOverTestCaseList</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>, &amp;<a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html#aa6eccf86072f4f8ddd0bea30dfd45912">TestCase::test_to_run_count</a>);
<a name="l00747"></a>00747 }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749 <span class="comment">// Returns the current OS stack trace as a String.</span>
<a name="l00750"></a>00750 <span class="comment">//</span>
<a name="l00751"></a>00751 <span class="comment">// The maximum number of stack frames to be included is specified by</span>
<a name="l00752"></a>00752 <span class="comment">// the gtest_stack_trace_depth flag.  The skip_count parameter</span>
<a name="l00753"></a>00753 <span class="comment">// specifies the number of top frames to be skipped, which doesn&#39;t</span>
<a name="l00754"></a>00754 <span class="comment">// count against the number of frames to be included.</span>
<a name="l00755"></a>00755 <span class="comment">//</span>
<a name="l00756"></a>00756 <span class="comment">// For example, if Foo() calls Bar(), which in turn calls</span>
<a name="l00757"></a>00757 <span class="comment">// CurrentOsStackTraceExceptTop(1), Foo() will be included in the</span>
<a name="l00758"></a>00758 <span class="comment">// trace but Bar() and CurrentOsStackTraceExceptTop() won&#39;t.</span>
<a name="l00759"></a>00759 String <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a131dbc639dae87df46e7f92daad7c183">UnitTestImpl::CurrentOsStackTraceExceptTop</a>(<span class="keywordtype">int</span> skip_count) {
<a name="l00760"></a>00760   (void)skip_count;
<a name="l00761"></a>00761   <span class="keywordflow">return</span> String(<span class="stringliteral">&quot;&quot;</span>);
<a name="l00762"></a>00762 }
<a name="l00763"></a>00763 
<a name="l00764"></a>00764 <span class="comment">// Returns the current time in milliseconds.</span>
<a name="l00765"></a>00765 <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9e0fb32f592d143f031a3431366adae0">TimeInMillis</a> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae0c6fd4543c65945515c42d6f43cc138">GetTimeInMillis</a>() {
<a name="l00766"></a>00766 <span class="preprocessor">#if GTEST_OS_WINDOWS_MOBILE || defined(__BORLANDC__)</span>
<a name="l00767"></a>00767 <span class="preprocessor"></span>  <span class="comment">// Difference between 1970-01-01 and 1601-01-01 in milliseconds.</span>
<a name="l00768"></a>00768   <span class="comment">// http://analogous.blogspot.com/2005/04/epoch.html</span>
<a name="l00769"></a>00769   <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9e0fb32f592d143f031a3431366adae0">TimeInMillis</a> kJavaEpochToWinFileTimeDelta =
<a name="l00770"></a>00770     <span class="keyword">static_cast&lt;</span><a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9e0fb32f592d143f031a3431366adae0">TimeInMillis</a><span class="keyword">&gt;</span>(116444736UL) * 100000UL;
<a name="l00771"></a>00771   <span class="keyword">const</span> DWORD kTenthMicrosInMilliSecond = 10000;
<a name="l00772"></a>00772 
<a name="l00773"></a>00773   SYSTEMTIME now_systime;
<a name="l00774"></a>00774   FILETIME now_filetime;
<a name="l00775"></a>00775   ULARGE_INTEGER now_int64;
<a name="l00776"></a>00776   <span class="comment">// TODO(kenton@google.com): Shouldn&#39;t this just use</span>
<a name="l00777"></a>00777   <span class="comment">//   GetSystemTimeAsFileTime()?</span>
<a name="l00778"></a>00778   GetSystemTime(&amp;now_systime);
<a name="l00779"></a>00779   <span class="keywordflow">if</span> (SystemTimeToFileTime(&amp;now_systime, &amp;now_filetime)) {
<a name="l00780"></a>00780     now_int64.LowPart = now_filetime.dwLowDateTime;
<a name="l00781"></a>00781     now_int64.HighPart = now_filetime.dwHighDateTime;
<a name="l00782"></a>00782     now_int64.QuadPart = (now_int64.QuadPart / kTenthMicrosInMilliSecond) -
<a name="l00783"></a>00783       kJavaEpochToWinFileTimeDelta;
<a name="l00784"></a>00784     <span class="keywordflow">return</span> now_int64.QuadPart;
<a name="l00785"></a>00785   }
<a name="l00786"></a>00786   <span class="keywordflow">return</span> 0;
<a name="l00787"></a>00787 <span class="preprocessor">#elif GTEST_OS_WINDOWS &amp;&amp; !GTEST_HAS_GETTIMEOFDAY_</span>
<a name="l00788"></a>00788 <span class="preprocessor"></span>  __timeb64 now;
<a name="l00789"></a>00789 
<a name="l00790"></a>00790 <span class="preprocessor"># ifdef _MSC_VER</span>
<a name="l00791"></a>00791 <span class="preprocessor"></span>
<a name="l00792"></a>00792   <span class="comment">// MSVC 8 deprecates _ftime64(), so we want to suppress warning 4996</span>
<a name="l00793"></a>00793   <span class="comment">// (deprecated function) there.</span>
<a name="l00794"></a>00794   <span class="comment">// TODO(kenton@google.com): Use GetTickCount()?  Or use</span>
<a name="l00795"></a>00795   <span class="comment">//   SystemTimeToFileTime()</span>
<a name="l00796"></a>00796 <span class="preprocessor">#  pragma warning(push)          // Saves the current warning state.</span>
<a name="l00797"></a>00797 <span class="preprocessor"></span><span class="preprocessor">#  pragma warning(disable:4996)  // Temporarily disables warning 4996.</span>
<a name="l00798"></a>00798 <span class="preprocessor"></span>  _ftime64(&amp;now);
<a name="l00799"></a>00799 <span class="preprocessor">#  pragma warning(pop)           // Restores the warning state.</span>
<a name="l00800"></a>00800 <span class="preprocessor"></span><span class="preprocessor"># else</span>
<a name="l00801"></a>00801 <span class="preprocessor"></span>
<a name="l00802"></a>00802   _ftime64(&amp;now);
<a name="l00803"></a>00803 
<a name="l00804"></a>00804 <span class="preprocessor"># endif  // _MSC_VER</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span>
<a name="l00806"></a>00806   <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9e0fb32f592d143f031a3431366adae0">TimeInMillis</a><span class="keyword">&gt;</span>(now.time) * 1000 + now.millitm;
<a name="l00807"></a>00807 #elif <a class="code" href="../../df/d5b/gtest_8cc.html#a7c139c1711de5a69cbc934e8a082e4f9">GTEST_HAS_GETTIMEOFDAY_</a>
<a name="l00808"></a>00808   <span class="keyword">struct</span> timeval now;
<a name="l00809"></a>00809   gettimeofday(&amp;now, NULL);
<a name="l00810"></a>00810   <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9e0fb32f592d143f031a3431366adae0">TimeInMillis</a><span class="keyword">&gt;</span>(now.tv_sec) * 1000 + now.tv_usec / 1000;
<a name="l00811"></a>00811 #<span class="keywordflow">else</span>
<a name="l00812"></a>00812 # error <span class="stringliteral">&quot;Don&#39;t know how to get the current time on your system.&quot;</span>
<a name="l00813"></a>00813 #endif
<a name="l00814"></a>00814 }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816 <span class="comment">// Utilities</span>
<a name="l00817"></a>00817 
<a name="l00818"></a>00818 <span class="comment">// class String</span>
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 <span class="comment">// Returns the input enclosed in double quotes if it&#39;s not NULL;</span>
<a name="l00821"></a>00821 <span class="comment">// otherwise returns &quot;(null)&quot;.  For example, &quot;\&quot;Hello\&quot;&quot; is returned</span>
<a name="l00822"></a>00822 <span class="comment">// for input &quot;Hello&quot;.</span>
<a name="l00823"></a>00823 <span class="comment">//</span>
<a name="l00824"></a>00824 <span class="comment">// This is useful for printing a C string in the syntax of a literal.</span>
<a name="l00825"></a>00825 <span class="comment">//</span>
<a name="l00826"></a>00826 <span class="comment">// Known issue: escape sequences are not handled yet.</span>
<a name="l00827"></a>00827 String <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a682efb26ffa6dca7101971c318382d5c">String::ShowCStringQuoted</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* c_str) {
<a name="l00828"></a>00828   <span class="keywordflow">return</span> c_str ? <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;\&quot;%s\&quot;&quot;</span>, c_str) : <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8db865e64c3c3f65ec6a0b6fd8c09a94">String</a>(<span class="stringliteral">&quot;(null)&quot;</span>);
<a name="l00829"></a>00829 }
<a name="l00830"></a>00830 
<a name="l00831"></a>00831 <span class="comment">// Copies at most length characters from str into a newly-allocated</span>
<a name="l00832"></a>00832 <span class="comment">// piece of memory of size length+1.  The memory is allocated with new[].</span>
<a name="l00833"></a>00833 <span class="comment">// A terminating null byte is written to the memory, and a pointer to it</span>
<a name="l00834"></a>00834 <span class="comment">// is returned.  If str is NULL, NULL is returned.</span>
<a name="l00835"></a>00835 <span class="keyword">static</span> <span class="keywordtype">char</span>* <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a574775e3e17e34fd6bd1cc8b4516a499">CloneString</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">size_t</span> length) {
<a name="l00836"></a>00836   <span class="keywordflow">if</span> (str == NULL) {
<a name="l00837"></a>00837     <span class="keywordflow">return</span> NULL;
<a name="l00838"></a>00838   } <span class="keywordflow">else</span> {
<a name="l00839"></a>00839     <span class="keywordtype">char</span>* <span class="keyword">const</span> clone = <span class="keyword">new</span> <span class="keywordtype">char</span>[length + 1];
<a name="l00840"></a>00840     <a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#a261b7136efb272312daa5c1f82e88c79">posix::StrNCpy</a>(clone, str, length);
<a name="l00841"></a>00841     clone[length] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00842"></a>00842     <span class="keywordflow">return</span> clone;
<a name="l00843"></a>00843   }
<a name="l00844"></a>00844 }
<a name="l00845"></a>00845 
<a name="l00846"></a>00846 <span class="comment">// Clones a 0-terminated C string, allocating memory using new.  The</span>
<a name="l00847"></a>00847 <span class="comment">// caller is responsible for deleting[] the return value.  Returns the</span>
<a name="l00848"></a>00848 <span class="comment">// cloned string, or NULL if the input is NULL.</span>
<a name="l00849"></a>00849 <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a122ac37f647b23428fb20f527ed5e2b2">String::CloneCString</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* c_str) {
<a name="l00850"></a>00850   <span class="keywordflow">return</span> (c_str == NULL) ?
<a name="l00851"></a>00851                     NULL : <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a574775e3e17e34fd6bd1cc8b4516a499">CloneString</a>(c_str, strlen(c_str));
<a name="l00852"></a>00852 }
<a name="l00853"></a>00853 
<a name="l00854"></a>00854 <span class="preprocessor">#if GTEST_OS_WINDOWS_MOBILE</span>
<a name="l00855"></a>00855 <span class="preprocessor"></span><span class="comment">// Creates a UTF-16 wide string from the given ANSI string, allocating</span>
<a name="l00856"></a>00856 <span class="comment">// memory using new. The caller is responsible for deleting the return</span>
<a name="l00857"></a>00857 <span class="comment">// value using delete[]. Returns the wide string, or NULL if the</span>
<a name="l00858"></a>00858 <span class="comment">// input is NULL.</span>
<a name="l00859"></a>00859 LPCWSTR String::AnsiToUtf16(<span class="keyword">const</span> <span class="keywordtype">char</span>* ansi) {
<a name="l00860"></a>00860   <span class="keywordflow">if</span> (!ansi) <span class="keywordflow">return</span> NULL;
<a name="l00861"></a>00861   <span class="keyword">const</span> <span class="keywordtype">int</span> length = strlen(ansi);
<a name="l00862"></a>00862   <span class="keyword">const</span> <span class="keywordtype">int</span> unicode_length =
<a name="l00863"></a>00863       MultiByteToWideChar(CP_ACP, 0, ansi, length,
<a name="l00864"></a>00864                           NULL, 0);
<a name="l00865"></a>00865   WCHAR* unicode = <span class="keyword">new</span> WCHAR[unicode_length + 1];
<a name="l00866"></a>00866   MultiByteToWideChar(CP_ACP, 0, ansi, length,
<a name="l00867"></a>00867                       unicode, unicode_length);
<a name="l00868"></a>00868   unicode[unicode_length] = 0;
<a name="l00869"></a>00869   <span class="keywordflow">return</span> unicode;
<a name="l00870"></a>00870 }
<a name="l00871"></a>00871 
<a name="l00872"></a>00872 <span class="comment">// Creates an ANSI string from the given wide string, allocating</span>
<a name="l00873"></a>00873 <span class="comment">// memory using new. The caller is responsible for deleting the return</span>
<a name="l00874"></a>00874 <span class="comment">// value using delete[]. Returns the ANSI string, or NULL if the</span>
<a name="l00875"></a>00875 <span class="comment">// input is NULL.</span>
<a name="l00876"></a>00876 <span class="keyword">const</span> <span class="keywordtype">char</span>* String::Utf16ToAnsi(LPCWSTR utf16_str)  {
<a name="l00877"></a>00877   <span class="keywordflow">if</span> (!utf16_str) <span class="keywordflow">return</span> NULL;
<a name="l00878"></a>00878   <span class="keyword">const</span> <span class="keywordtype">int</span> ansi_length =
<a name="l00879"></a>00879       WideCharToMultiByte(CP_ACP, 0, utf16_str, -1,
<a name="l00880"></a>00880                           NULL, 0, NULL, NULL);
<a name="l00881"></a>00881   <span class="keywordtype">char</span>* ansi = <span class="keyword">new</span> <span class="keywordtype">char</span>[ansi_length + 1];
<a name="l00882"></a>00882   WideCharToMultiByte(CP_ACP, 0, utf16_str, -1,
<a name="l00883"></a>00883                       ansi, ansi_length, NULL, NULL);
<a name="l00884"></a>00884   ansi[ansi_length] = 0;
<a name="l00885"></a>00885   <span class="keywordflow">return</span> ansi;
<a name="l00886"></a>00886 }
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 <span class="preprocessor">#endif  // GTEST_OS_WINDOWS_MOBILE</span>
<a name="l00889"></a>00889 <span class="preprocessor"></span>
<a name="l00890"></a>00890 <span class="comment">// Compares two C strings.  Returns true iff they have the same content.</span>
<a name="l00891"></a>00891 <span class="comment">//</span>
<a name="l00892"></a>00892 <span class="comment">// Unlike strcmp(), this function can handle NULL argument(s).  A NULL</span>
<a name="l00893"></a>00893 <span class="comment">// C string is considered different to any non-NULL C string,</span>
<a name="l00894"></a>00894 <span class="comment">// including the empty string.</span>
<a name="l00895"></a>00895 <span class="keywordtype">bool</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#ac1abc71678dbb1323757df95de3c5a46">String::CStringEquals</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * lhs, <span class="keyword">const</span> <span class="keywordtype">char</span> * rhs) {
<a name="l00896"></a>00896   <span class="keywordflow">if</span> ( lhs == NULL ) <span class="keywordflow">return</span> rhs == NULL;
<a name="l00897"></a>00897 
<a name="l00898"></a>00898   <span class="keywordflow">if</span> ( rhs == NULL ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00899"></a>00899 
<a name="l00900"></a>00900   <span class="keywordflow">return</span> strcmp(lhs, rhs) == 0;
<a name="l00901"></a>00901 }
<a name="l00902"></a>00902 
<a name="l00903"></a>00903 <span class="preprocessor">#if GTEST_HAS_STD_WSTRING || GTEST_HAS_GLOBAL_WSTRING</span>
<a name="l00904"></a>00904 <span class="preprocessor"></span>
<a name="l00905"></a>00905 <span class="comment">// Converts an array of wide chars to a narrow string using the UTF-8</span>
<a name="l00906"></a>00906 <span class="comment">// encoding, and streams the result to the given Message object.</span>
<a name="l00907"></a>00907 <span class="keyword">static</span> <span class="keywordtype">void</span> StreamWideCharsToMessage(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* wstr, <span class="keywordtype">size_t</span> length,
<a name="l00908"></a>00908                                      Message* msg) {
<a name="l00909"></a>00909   <span class="comment">// TODO(wan): consider allowing a testing::String object to</span>
<a name="l00910"></a>00910   <span class="comment">// contain &#39;\0&#39;.  This will make it behave more like std::string,</span>
<a name="l00911"></a>00911   <span class="comment">// and will allow ToUtf8String() to return the correct encoding</span>
<a name="l00912"></a>00912   <span class="comment">// for &#39;\0&#39; s.t. we can get rid of the conditional here (and in</span>
<a name="l00913"></a>00913   <span class="comment">// several other places).</span>
<a name="l00914"></a>00914   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i != length; ) {  <span class="comment">// NOLINT</span>
<a name="l00915"></a>00915     <span class="keywordflow">if</span> (wstr[i] != L<span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00916"></a>00916       *msg &lt;&lt; WideStringToUtf8(wstr + i, static_cast&lt;int&gt;(length - i));
<a name="l00917"></a>00917       <span class="keywordflow">while</span> (i != length &amp;&amp; wstr[i] != L<span class="charliteral">&#39;\0&#39;</span>)
<a name="l00918"></a>00918         i++;
<a name="l00919"></a>00919     } <span class="keywordflow">else</span> {
<a name="l00920"></a>00920       *msg &lt;&lt; <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00921"></a>00921       i++;
<a name="l00922"></a>00922     }
<a name="l00923"></a>00923   }
<a name="l00924"></a>00924 }
<a name="l00925"></a>00925 
<a name="l00926"></a>00926 <span class="preprocessor">#endif  // GTEST_HAS_STD_WSTRING || GTEST_HAS_GLOBAL_WSTRING</span>
<a name="l00927"></a>00927 <span class="preprocessor"></span>
<a name="l00928"></a>00928 }  <span class="comment">// namespace internal</span>
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 <span class="preprocessor">#if GTEST_HAS_STD_WSTRING</span>
<a name="l00931"></a>00931 <span class="preprocessor"></span><span class="comment">// Converts the given wide string to a narrow string using the UTF-8</span>
<a name="l00932"></a>00932 <span class="comment">// encoding, and streams the result to this Message object.</span>
<a name="l00933"></a>00933 Message&amp; <a class="code" href="../../d3/d98/classtesting_1_1Message.html#a173f6d370f2730877bbf104ceb93f461">Message::operator &lt;&lt;</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a393885eea6349a55ca3640cccbe912a6">const ::std::wstring</a>&amp; wstr) {
<a name="l00934"></a>00934   internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), <span class="keyword">this</span>);
<a name="l00935"></a>00935   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00936"></a>00936 }
<a name="l00937"></a>00937 <span class="preprocessor">#endif  // GTEST_HAS_STD_WSTRING</span>
<a name="l00938"></a>00938 <span class="preprocessor"></span>
<a name="l00939"></a>00939 <span class="preprocessor">#if GTEST_HAS_GLOBAL_WSTRING</span>
<a name="l00940"></a>00940 <span class="preprocessor"></span><span class="comment">// Converts the given wide string to a narrow string using the UTF-8</span>
<a name="l00941"></a>00941 <span class="comment">// encoding, and streams the result to this Message object.</span>
<a name="l00942"></a>00942 Message&amp; <a class="code" href="../../d3/d98/classtesting_1_1Message.html#a173f6d370f2730877bbf104ceb93f461">Message::operator &lt;&lt;</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a393885eea6349a55ca3640cccbe912a6">const ::wstring</a>&amp; wstr) {
<a name="l00943"></a>00943   internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), <span class="keyword">this</span>);
<a name="l00944"></a>00944   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00945"></a>00945 }
<a name="l00946"></a>00946 <span class="preprocessor">#endif  // GTEST_HAS_GLOBAL_WSTRING</span>
<a name="l00947"></a>00947 <span class="preprocessor"></span>
<a name="l00948"></a>00948 <span class="comment">// AssertionResult constructors.</span>
<a name="l00949"></a>00949 <span class="comment">// Used in EXPECT_TRUE/FALSE(assertion_result).</span>
<a name="l00950"></a>00950 <a class="code" href="../../dd/d5f/classtesting_1_1AssertionResult.html#adfc7c37883985778a3d3f4f8cf0fecf1">AssertionResult::AssertionResult</a>(<span class="keyword">const</span> AssertionResult&amp; other)
<a name="l00951"></a>00951     : success_(other.success_),
<a name="l00952"></a>00952       message_(other.message_.get() != NULL ?
<a name="l00953"></a>00953                <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9882e571372fc19a02d2b2949e1f1557">new ::std::string</a>(*other.message_) :
<a name="l00954"></a>00954                <span class="keyword">static_cast&lt;</span> ::<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9882e571372fc19a02d2b2949e1f1557">std::string</a>*<span class="keyword">&gt;</span>(NULL)) {
<a name="l00955"></a>00955 }
<a name="l00956"></a>00956 
<a name="l00957"></a>00957 <span class="comment">// Returns the assertion&#39;s negation. Used with EXPECT/ASSERT_FALSE.</span>
<a name="l00958"></a>00958 AssertionResult <a class="code" href="../../dd/d5f/classtesting_1_1AssertionResult.html#a8569a100f4db8e2861d390326b1b9794">AssertionResult::operator!</a>()<span class="keyword"> const </span>{
<a name="l00959"></a>00959   <a class="code" href="../../dd/d5f/classtesting_1_1AssertionResult.html#adfc7c37883985778a3d3f4f8cf0fecf1">AssertionResult</a> negation(!<a class="code" href="../../dd/d5f/classtesting_1_1AssertionResult.html#af269425d62c74663296db74fb636833d">success_</a>);
<a name="l00960"></a>00960   <span class="keywordflow">if</span> (<a class="code" href="../../dd/d5f/classtesting_1_1AssertionResult.html#a9933c5cd488d58e22fbf84f7c4c96707">message_</a>.<a class="code" href="../../de/d6a/classtesting_1_1internal_1_1scoped__ptr.html#a07f851191ad3a7c5c1598ef14f710f96">get</a>() != NULL)
<a name="l00961"></a>00961     negation &lt;&lt; *<a class="code" href="../../dd/d5f/classtesting_1_1AssertionResult.html#a9933c5cd488d58e22fbf84f7c4c96707">message_</a>;
<a name="l00962"></a>00962   <span class="keywordflow">return</span> negation;
<a name="l00963"></a>00963 }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 <span class="comment">// Makes a successful assertion result.</span>
<a name="l00966"></a>00966 AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>() {
<a name="l00967"></a>00967   <span class="keywordflow">return</span> AssertionResult(<span class="keyword">true</span>);
<a name="l00968"></a>00968 }
<a name="l00969"></a>00969 
<a name="l00970"></a>00970 <span class="comment">// Makes a failed assertion result.</span>
<a name="l00971"></a>00971 AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>() {
<a name="l00972"></a>00972   <span class="keywordflow">return</span> AssertionResult(<span class="keyword">false</span>);
<a name="l00973"></a>00973 }
<a name="l00974"></a>00974 
<a name="l00975"></a>00975 <span class="comment">// Makes a failed assertion result with the given failure message.</span>
<a name="l00976"></a>00976 <span class="comment">// Deprecated; use AssertionFailure() &lt;&lt; message.</span>
<a name="l00977"></a>00977 AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>(<span class="keyword">const</span> Message&amp; <a class="code" href="../../d6/dc2/namespacegtest__output__test.html#a536593b2a92b75b5c370d337feb4f615">message</a>) {
<a name="l00978"></a>00978   <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>() &lt;&lt; <a class="code" href="../../d6/dc2/namespacegtest__output__test.html#a536593b2a92b75b5c370d337feb4f615">message</a>;
<a name="l00979"></a>00979 }
<a name="l00980"></a>00980 
<a name="l00981"></a>00981 <span class="keyword">namespace </span>internal {
<a name="l00982"></a>00982 
<a name="l00983"></a>00983 <span class="comment">// Constructs and returns the message for an equality assertion</span>
<a name="l00984"></a>00984 <span class="comment">// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.</span>
<a name="l00985"></a>00985 <span class="comment">//</span>
<a name="l00986"></a>00986 <span class="comment">// The first four parameters are the expressions used in the assertion</span>
<a name="l00987"></a>00987 <span class="comment">// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)</span>
<a name="l00988"></a>00988 <span class="comment">// where foo is 5 and bar is 6, we have:</span>
<a name="l00989"></a>00989 <span class="comment">//</span>
<a name="l00990"></a>00990 <span class="comment">//   expected_expression: &quot;foo&quot;</span>
<a name="l00991"></a>00991 <span class="comment">//   actual_expression:   &quot;bar&quot;</span>
<a name="l00992"></a>00992 <span class="comment">//   expected_value:      &quot;5&quot;</span>
<a name="l00993"></a>00993 <span class="comment">//   actual_value:        &quot;6&quot;</span>
<a name="l00994"></a>00994 <span class="comment">//</span>
<a name="l00995"></a>00995 <span class="comment">// The ignoring_case parameter is true iff the assertion is a</span>
<a name="l00996"></a>00996 <span class="comment">// *_STRCASEEQ*.  When it&#39;s true, the string &quot; (ignoring case)&quot; will</span>
<a name="l00997"></a>00997 <span class="comment">// be inserted into the message.</span>
<a name="l00998"></a>00998 AssertionResult <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a1b32471fa3a4994b5e41120a349162ca">EqFailure</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l00999"></a>00999                           <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01000"></a>01000                           <span class="keyword">const</span> String&amp; expected_value,
<a name="l01001"></a>01001                           <span class="keyword">const</span> String&amp; actual_value,
<a name="l01002"></a>01002                           <span class="keywordtype">bool</span> ignoring_case) {
<a name="l01003"></a>01003   Message msg;
<a name="l01004"></a>01004   msg &lt;&lt; <span class="stringliteral">&quot;Value of: &quot;</span> &lt;&lt; actual_expression;
<a name="l01005"></a>01005   <span class="keywordflow">if</span> (actual_value != actual_expression) {
<a name="l01006"></a>01006     msg &lt;&lt; <span class="stringliteral">&quot;\n  Actual: &quot;</span> &lt;&lt; actual_value;
<a name="l01007"></a>01007   }
<a name="l01008"></a>01008 
<a name="l01009"></a>01009   msg &lt;&lt; <span class="stringliteral">&quot;\nExpected: &quot;</span> &lt;&lt; expected_expression;
<a name="l01010"></a>01010   <span class="keywordflow">if</span> (ignoring_case) {
<a name="l01011"></a>01011     msg &lt;&lt; <span class="stringliteral">&quot; (ignoring case)&quot;</span>;
<a name="l01012"></a>01012   }
<a name="l01013"></a>01013   <span class="keywordflow">if</span> (expected_value != expected_expression) {
<a name="l01014"></a>01014     msg &lt;&lt; <span class="stringliteral">&quot;\nWhich is: &quot;</span> &lt;&lt; expected_value;
<a name="l01015"></a>01015   }
<a name="l01016"></a>01016 
<a name="l01017"></a>01017   <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>() &lt;&lt; msg;
<a name="l01018"></a>01018 }
<a name="l01019"></a>01019 
<a name="l01020"></a>01020 <span class="comment">// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.</span>
<a name="l01021"></a>01021 String <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab5e2ffddf04d86a4faa0253b8e1fe67e">GetBoolAssertionFailureMessage</a>(<span class="keyword">const</span> AssertionResult&amp; assertion_result,
<a name="l01022"></a>01022                                       <span class="keyword">const</span> <span class="keywordtype">char</span>* expression_text,
<a name="l01023"></a>01023                                       <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_predicate_value,
<a name="l01024"></a>01024                                       <span class="keyword">const</span> <span class="keywordtype">char</span>* expected_predicate_value) {
<a name="l01025"></a>01025   <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_message = assertion_result.message();
<a name="l01026"></a>01026   Message msg;
<a name="l01027"></a>01027   msg &lt;&lt; <span class="stringliteral">&quot;Value of: &quot;</span> &lt;&lt; expression_text
<a name="l01028"></a>01028       &lt;&lt; <span class="stringliteral">&quot;\n  Actual: &quot;</span> &lt;&lt; actual_predicate_value;
<a name="l01029"></a>01029   <span class="keywordflow">if</span> (actual_message[0] != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l01030"></a>01030     msg &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; actual_message &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
<a name="l01031"></a>01031   msg &lt;&lt; <span class="stringliteral">&quot;\nExpected: &quot;</span> &lt;&lt; expected_predicate_value;
<a name="l01032"></a>01032   <span class="keywordflow">return</span> msg.GetString();
<a name="l01033"></a>01033 }
<a name="l01034"></a>01034 
<a name="l01035"></a>01035 <span class="comment">// Helper function for implementing ASSERT_NEAR.</span>
<a name="l01036"></a>01036 AssertionResult <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a44c08eb9054d3bf89ac3e7ac0549929f">DoubleNearPredFormat</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr1,
<a name="l01037"></a>01037                                      <span class="keyword">const</span> <span class="keywordtype">char</span>* expr2,
<a name="l01038"></a>01038                                      <span class="keyword">const</span> <span class="keywordtype">char</span>* abs_error_expr,
<a name="l01039"></a>01039                                      <span class="keywordtype">double</span> val1,
<a name="l01040"></a>01040                                      <span class="keywordtype">double</span> val2,
<a name="l01041"></a>01041                                      <span class="keywordtype">double</span> abs_error) {
<a name="l01042"></a>01042   <span class="keyword">const</span> <span class="keywordtype">double</span> diff = fabs(val1 - val2);
<a name="l01043"></a>01043   <span class="keywordflow">if</span> (diff &lt;= abs_error) <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01044"></a>01044 
<a name="l01045"></a>01045   <span class="comment">// TODO(wan): do not print the value of an expression if it&#39;s</span>
<a name="l01046"></a>01046   <span class="comment">// already a literal.</span>
<a name="l01047"></a>01047   <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>()
<a name="l01048"></a>01048       &lt;&lt; <span class="stringliteral">&quot;The difference between &quot;</span> &lt;&lt; expr1 &lt;&lt; <span class="stringliteral">&quot; and &quot;</span> &lt;&lt; expr2
<a name="l01049"></a>01049       &lt;&lt; <span class="stringliteral">&quot; is &quot;</span> &lt;&lt; diff &lt;&lt; <span class="stringliteral">&quot;, which exceeds &quot;</span> &lt;&lt; abs_error_expr &lt;&lt; <span class="stringliteral">&quot;, where\n&quot;</span>
<a name="l01050"></a>01050       &lt;&lt; expr1 &lt;&lt; <span class="stringliteral">&quot; evaluates to &quot;</span> &lt;&lt; val1 &lt;&lt; <span class="stringliteral">&quot;,\n&quot;</span>
<a name="l01051"></a>01051       &lt;&lt; expr2 &lt;&lt; <span class="stringliteral">&quot; evaluates to &quot;</span> &lt;&lt; val2 &lt;&lt; <span class="stringliteral">&quot;, and\n&quot;</span>
<a name="l01052"></a>01052       &lt;&lt; abs_error_expr &lt;&lt; <span class="stringliteral">&quot; evaluates to &quot;</span> &lt;&lt; abs_error &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;
<a name="l01053"></a>01053 }
<a name="l01054"></a>01054 
<a name="l01055"></a>01055 
<a name="l01056"></a>01056 <span class="comment">// Helper template for implementing FloatLE() and DoubleLE().</span>
<a name="l01057"></a>01057 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> RawType&gt;
<a name="l01058"></a>01058 AssertionResult <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a27094d26e2f0cf4bcf02d6b8e3382f70">FloatingPointLE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr1,
<a name="l01059"></a>01059                                 <span class="keyword">const</span> <span class="keywordtype">char</span>* expr2,
<a name="l01060"></a>01060                                 RawType val1,
<a name="l01061"></a>01061                                 RawType val2) {
<a name="l01062"></a>01062   <span class="comment">// Returns success if val1 is less than val2,</span>
<a name="l01063"></a>01063   <span class="keywordflow">if</span> (val1 &lt; val2) {
<a name="l01064"></a>01064     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01065"></a>01065   }
<a name="l01066"></a>01066 
<a name="l01067"></a>01067   <span class="comment">// or if val1 is almost equal to val2.</span>
<a name="l01068"></a>01068   <span class="keyword">const</span> FloatingPoint&lt;RawType&gt; lhs(val1), rhs(val2);
<a name="l01069"></a>01069   <span class="keywordflow">if</span> (lhs.AlmostEquals(rhs)) {
<a name="l01070"></a>01070     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01071"></a>01071   }
<a name="l01072"></a>01072 
<a name="l01073"></a>01073   <span class="comment">// Note that the above two checks will both fail if either val1 or</span>
<a name="l01074"></a>01074   <span class="comment">// val2 is NaN, as the IEEE floating-point standard requires that</span>
<a name="l01075"></a>01075   <span class="comment">// any predicate involving a NaN must return false.</span>
<a name="l01076"></a>01076 
<a name="l01077"></a>01077   ::std::stringstream val1_ss;
<a name="l01078"></a>01078   val1_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)
<a name="l01079"></a>01079           &lt;&lt; val1;
<a name="l01080"></a>01080 
<a name="l01081"></a>01081   ::std::stringstream val2_ss;
<a name="l01082"></a>01082   val2_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)
<a name="l01083"></a>01083           &lt;&lt; val2;
<a name="l01084"></a>01084 
<a name="l01085"></a>01085   <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>()
<a name="l01086"></a>01086       &lt;&lt; <span class="stringliteral">&quot;Expected: (&quot;</span> &lt;&lt; expr1 &lt;&lt; <span class="stringliteral">&quot;) &lt;= (&quot;</span> &lt;&lt; expr2 &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>
<a name="l01087"></a>01087       &lt;&lt; <span class="stringliteral">&quot;  Actual: &quot;</span> &lt;&lt; <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#abf99dee8db2ca5a9bc512dd6cc34f048">StringStreamToString</a>(&amp;val1_ss) &lt;&lt; <span class="stringliteral">&quot; vs &quot;</span>
<a name="l01088"></a>01088       &lt;&lt; <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#abf99dee8db2ca5a9bc512dd6cc34f048">StringStreamToString</a>(&amp;val2_ss);
<a name="l01089"></a>01089 }
<a name="l01090"></a>01090 
<a name="l01091"></a>01091 }  <span class="comment">// namespace internal</span>
<a name="l01092"></a>01092 
<a name="l01093"></a>01093 <span class="comment">// Asserts that val1 is less than, or almost equal to, val2.  Fails</span>
<a name="l01094"></a>01094 <span class="comment">// otherwise.  In particular, it fails if either val1 or val2 is NaN.</span>
<a name="l01095"></a>01095 AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#a23a2d15c37bf756a5baf67922ad35172">FloatLE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr1, <span class="keyword">const</span> <span class="keywordtype">char</span>* expr2,
<a name="l01096"></a>01096                         <span class="keywordtype">float</span> val1, <span class="keywordtype">float</span> val2) {
<a name="l01097"></a>01097   <span class="keywordflow">return</span> internal::FloatingPointLE&lt;float&gt;(expr1, expr2, val1, val2);
<a name="l01098"></a>01098 }
<a name="l01099"></a>01099 
<a name="l01100"></a>01100 <span class="comment">// Asserts that val1 is less than, or almost equal to, val2.  Fails</span>
<a name="l01101"></a>01101 <span class="comment">// otherwise.  In particular, it fails if either val1 or val2 is NaN.</span>
<a name="l01102"></a>01102 AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#aa02480b781912f18f8b22ab91a905d58">DoubleLE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr1, <span class="keyword">const</span> <span class="keywordtype">char</span>* expr2,
<a name="l01103"></a>01103                          <span class="keywordtype">double</span> val1, <span class="keywordtype">double</span> val2) {
<a name="l01104"></a>01104   <span class="keywordflow">return</span> internal::FloatingPointLE&lt;double&gt;(expr1, expr2, val1, val2);
<a name="l01105"></a>01105 }
<a name="l01106"></a>01106 
<a name="l01107"></a>01107 <span class="keyword">namespace </span>internal {
<a name="l01108"></a>01108 
<a name="l01109"></a>01109 <span class="comment">// The helper function for {ASSERT|EXPECT}_EQ with int or enum</span>
<a name="l01110"></a>01110 <span class="comment">// arguments.</span>
<a name="l01111"></a>01111 AssertionResult <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab3ac33c050b73adde43e78111448805f">CmpHelperEQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01112"></a>01112                             <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01113"></a>01113                             <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae8f73370150f905887720532fa9f572e">BiggestInt</a> expected,
<a name="l01114"></a>01114                             <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae8f73370150f905887720532fa9f572e">BiggestInt</a> actual) {
<a name="l01115"></a>01115   <span class="keywordflow">if</span> (expected == actual) {
<a name="l01116"></a>01116     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01117"></a>01117   }
<a name="l01118"></a>01118 
<a name="l01119"></a>01119   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a1b32471fa3a4994b5e41120a349162ca">EqFailure</a>(expected_expression,
<a name="l01120"></a>01120                    actual_expression,
<a name="l01121"></a>01121                    <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af9be1d3d9bbec168d911b750d1d00c5f">FormatForComparisonFailureMessage</a>(expected, actual),
<a name="l01122"></a>01122                    <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af9be1d3d9bbec168d911b750d1d00c5f">FormatForComparisonFailureMessage</a>(actual, expected),
<a name="l01123"></a>01123                    <span class="keyword">false</span>);
<a name="l01124"></a>01124 }
<a name="l01125"></a>01125 
<a name="l01126"></a>01126 <span class="comment">// A macro for implementing the helper functions needed to implement</span>
<a name="l01127"></a>01127 <span class="comment">// ASSERT_?? and EXPECT_?? with integer or enum arguments.  It is here</span>
<a name="l01128"></a>01128 <span class="comment">// just to avoid copy-and-paste of similar code.</span>
<a name="l01129"></a><a class="code" href="../../df/d5b/gtest_8cc.html#a4a5b6fbde5dd05e05dd6846ac5e5c18e">01129</a> <span class="preprocessor">#define GTEST_IMPL_CMP_HELPER_(op_name, op)\</span>
<a name="l01130"></a>01130 <span class="preprocessor">AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \</span>
<a name="l01131"></a>01131 <span class="preprocessor">                                   BiggestInt val1, BiggestInt val2) {\</span>
<a name="l01132"></a>01132 <span class="preprocessor">  if (val1 op val2) {\</span>
<a name="l01133"></a>01133 <span class="preprocessor">    return AssertionSuccess();\</span>
<a name="l01134"></a>01134 <span class="preprocessor">  } else {\</span>
<a name="l01135"></a>01135 <span class="preprocessor">    return AssertionFailure() \</span>
<a name="l01136"></a>01136 <span class="preprocessor">        &lt;&lt; &quot;Expected: (&quot; &lt;&lt; expr1 &lt;&lt; &quot;) &quot; #op &quot; (&quot; &lt;&lt; expr2\</span>
<a name="l01137"></a>01137 <span class="preprocessor">        &lt;&lt; &quot;), actual: &quot; &lt;&lt; FormatForComparisonFailureMessage(val1, val2)\</span>
<a name="l01138"></a>01138 <span class="preprocessor">        &lt;&lt; &quot; vs &quot; &lt;&lt; FormatForComparisonFailureMessage(val2, val1);\</span>
<a name="l01139"></a>01139 <span class="preprocessor">  }\</span>
<a name="l01140"></a>01140 <span class="preprocessor">}</span>
<a name="l01141"></a>01141 <span class="preprocessor"></span>
<a name="l01142"></a>01142 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_NE with int or</span>
<a name="l01143"></a>01143 <span class="comment">// enum arguments.</span>
<a name="l01144"></a>01144 <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac8cf80686ba04b6eebb157617c2ca1f7">GTEST_IMPL_CMP_HELPER_</a>(NE, !=)
<a name="l01145"></a>01145 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_LE with int or</span>
<a name="l01146"></a>01146 <span class="comment">// enum arguments.</span>
<a name="l01147"></a>01147 <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac8cf80686ba04b6eebb157617c2ca1f7">GTEST_IMPL_CMP_HELPER_</a>(LE, &lt;=)
<a name="l01148"></a>01148 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_LT with int or</span>
<a name="l01149"></a>01149 <span class="comment">// enum arguments.</span>
<a name="l01150"></a>01150 <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac8cf80686ba04b6eebb157617c2ca1f7">GTEST_IMPL_CMP_HELPER_</a>(LT, &lt; )
<a name="l01151"></a>01151 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_GE with int or</span>
<a name="l01152"></a>01152 <span class="comment">// enum arguments.</span>
<a name="l01153"></a>01153 <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac8cf80686ba04b6eebb157617c2ca1f7">GTEST_IMPL_CMP_HELPER_</a>(GE, &gt;=)
<a name="l01154"></a>01154 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_GT with int or</span>
<a name="l01155"></a>01155 <span class="comment">// enum arguments.</span>
<a name="l01156"></a>01156 <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac8cf80686ba04b6eebb157617c2ca1f7">GTEST_IMPL_CMP_HELPER_</a>(GT, &gt; )
<a name="l01157"></a>01157 
<a name="l01158"></a>01158 <span class="preprocessor">#undef GTEST_IMPL_CMP_HELPER_</span>
<a name="l01159"></a>01159 <span class="preprocessor"></span>
<a name="l01160"></a>01160 <span class="comment">// The helper function for {ASSERT|EXPECT}_STREQ.</span>
<a name="l01161"></a>01161 AssertionResult <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#aac3ea8412a9d5f786b992a2b06aeb353">CmpHelperSTREQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01162"></a>01162                                <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01163"></a>01163                                <span class="keyword">const</span> <span class="keywordtype">char</span>* expected,
<a name="l01164"></a>01164                                <span class="keyword">const</span> <span class="keywordtype">char</span>* actual) {
<a name="l01165"></a>01165   <span class="keywordflow">if</span> (<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#ac1abc71678dbb1323757df95de3c5a46">String::CStringEquals</a>(expected, actual)) {
<a name="l01166"></a>01166     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01167"></a>01167   }
<a name="l01168"></a>01168 
<a name="l01169"></a>01169   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a1b32471fa3a4994b5e41120a349162ca">EqFailure</a>(expected_expression,
<a name="l01170"></a>01170                    actual_expression,
<a name="l01171"></a>01171                    <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a682efb26ffa6dca7101971c318382d5c">String::ShowCStringQuoted</a>(expected),
<a name="l01172"></a>01172                    <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a682efb26ffa6dca7101971c318382d5c">String::ShowCStringQuoted</a>(actual),
<a name="l01173"></a>01173                    <span class="keyword">false</span>);
<a name="l01174"></a>01174 }
<a name="l01175"></a>01175 
<a name="l01176"></a>01176 <span class="comment">// The helper function for {ASSERT|EXPECT}_STRCASEEQ.</span>
<a name="l01177"></a>01177 AssertionResult <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#aa5c3543f39545113a66c5b4d8f829fc6">CmpHelperSTRCASEEQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01178"></a>01178                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01179"></a>01179                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* expected,
<a name="l01180"></a>01180                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* actual) {
<a name="l01181"></a>01181   <span class="keywordflow">if</span> (<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a74c3f7f7cf90cc53c995dde20883d922">String::CaseInsensitiveCStringEquals</a>(expected, actual)) {
<a name="l01182"></a>01182     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01183"></a>01183   }
<a name="l01184"></a>01184 
<a name="l01185"></a>01185   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a1b32471fa3a4994b5e41120a349162ca">EqFailure</a>(expected_expression,
<a name="l01186"></a>01186                    actual_expression,
<a name="l01187"></a>01187                    <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a682efb26ffa6dca7101971c318382d5c">String::ShowCStringQuoted</a>(expected),
<a name="l01188"></a>01188                    <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a682efb26ffa6dca7101971c318382d5c">String::ShowCStringQuoted</a>(actual),
<a name="l01189"></a>01189                    <span class="keyword">true</span>);
<a name="l01190"></a>01190 }
<a name="l01191"></a>01191 
<a name="l01192"></a>01192 <span class="comment">// The helper function for {ASSERT|EXPECT}_STRNE.</span>
<a name="l01193"></a>01193 AssertionResult <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a24dfe04b51cda2637868440f0e6a7110">CmpHelperSTRNE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s1_expression,
<a name="l01194"></a>01194                                <span class="keyword">const</span> <span class="keywordtype">char</span>* s2_expression,
<a name="l01195"></a>01195                                <span class="keyword">const</span> <span class="keywordtype">char</span>* s1,
<a name="l01196"></a>01196                                <span class="keyword">const</span> <span class="keywordtype">char</span>* s2) {
<a name="l01197"></a>01197   <span class="keywordflow">if</span> (!<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#ac1abc71678dbb1323757df95de3c5a46">String::CStringEquals</a>(s1, s2)) {
<a name="l01198"></a>01198     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01199"></a>01199   } <span class="keywordflow">else</span> {
<a name="l01200"></a>01200     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>() &lt;&lt; <span class="stringliteral">&quot;Expected: (&quot;</span> &lt;&lt; s1_expression &lt;&lt; <span class="stringliteral">&quot;) != (&quot;</span>
<a name="l01201"></a>01201                               &lt;&lt; s2_expression &lt;&lt; <span class="stringliteral">&quot;), actual: \&quot;&quot;</span>
<a name="l01202"></a>01202                               &lt;&lt; s1 &lt;&lt; <span class="stringliteral">&quot;\&quot; vs \&quot;&quot;</span> &lt;&lt; s2 &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l01203"></a>01203   }
<a name="l01204"></a>01204 }
<a name="l01205"></a>01205 
<a name="l01206"></a>01206 <span class="comment">// The helper function for {ASSERT|EXPECT}_STRCASENE.</span>
<a name="l01207"></a>01207 AssertionResult <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a87ee06a47690ee4681d40e1bf6a4a3c5">CmpHelperSTRCASENE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s1_expression,
<a name="l01208"></a>01208                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* s2_expression,
<a name="l01209"></a>01209                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* s1,
<a name="l01210"></a>01210                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* s2) {
<a name="l01211"></a>01211   <span class="keywordflow">if</span> (!<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a74c3f7f7cf90cc53c995dde20883d922">String::CaseInsensitiveCStringEquals</a>(s1, s2)) {
<a name="l01212"></a>01212     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01213"></a>01213   } <span class="keywordflow">else</span> {
<a name="l01214"></a>01214     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>()
<a name="l01215"></a>01215         &lt;&lt; <span class="stringliteral">&quot;Expected: (&quot;</span> &lt;&lt; s1_expression &lt;&lt; <span class="stringliteral">&quot;) != (&quot;</span>
<a name="l01216"></a>01216         &lt;&lt; s2_expression &lt;&lt; <span class="stringliteral">&quot;) (ignoring case), actual: \&quot;&quot;</span>
<a name="l01217"></a>01217         &lt;&lt; s1 &lt;&lt; <span class="stringliteral">&quot;\&quot; vs \&quot;&quot;</span> &lt;&lt; s2 &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l01218"></a>01218   }
<a name="l01219"></a>01219 }
<a name="l01220"></a>01220 
<a name="l01221"></a>01221 }  <span class="comment">// namespace internal</span>
<a name="l01222"></a>01222 
<a name="l01223"></a>01223 <span class="keyword">namespace </span>{
<a name="l01224"></a>01224 
<a name="l01225"></a>01225 <span class="comment">// Helper functions for implementing IsSubString() and IsNotSubstring().</span>
<a name="l01226"></a>01226 
<a name="l01227"></a>01227 <span class="comment">// This group of overloaded functions return true iff needle is a</span>
<a name="l01228"></a>01228 <span class="comment">// substring of haystack.  NULL is considered a substring of itself</span>
<a name="l01229"></a>01229 <span class="comment">// only.</span>
<a name="l01230"></a>01230 
<a name="l01231"></a>01231 <span class="keywordtype">bool</span> IsSubstringPred(<span class="keyword">const</span> <span class="keywordtype">char</span>* needle, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack) {
<a name="l01232"></a>01232   <span class="keywordflow">if</span> (needle == NULL || haystack == NULL)
<a name="l01233"></a>01233     <span class="keywordflow">return</span> needle == haystack;
<a name="l01234"></a>01234 
<a name="l01235"></a>01235   <span class="keywordflow">return</span> strstr(haystack, needle) != NULL;
<a name="l01236"></a>01236 }
<a name="l01237"></a>01237 
<a name="l01238"></a>01238 <span class="keywordtype">bool</span> IsSubstringPred(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* needle, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* haystack) {
<a name="l01239"></a>01239   <span class="keywordflow">if</span> (needle == NULL || haystack == NULL)
<a name="l01240"></a>01240     <span class="keywordflow">return</span> needle == haystack;
<a name="l01241"></a>01241 
<a name="l01242"></a>01242   <span class="keywordflow">return</span> wcsstr(haystack, needle) != NULL;
<a name="l01243"></a>01243 }
<a name="l01244"></a>01244 
<a name="l01245"></a>01245 <span class="comment">// StringType here can be either ::std::string or ::std::wstring.</span>
<a name="l01246"></a>01246 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> StringType&gt;
<a name="l01247"></a>01247 <span class="keywordtype">bool</span> IsSubstringPred(<span class="keyword">const</span> StringType&amp; needle,
<a name="l01248"></a>01248                      <span class="keyword">const</span> StringType&amp; haystack) {
<a name="l01249"></a>01249   <span class="keywordflow">return</span> haystack.find(needle) != StringType::npos;
<a name="l01250"></a>01250 }
<a name="l01251"></a>01251 
<a name="l01252"></a>01252 <span class="comment">// This function implements either IsSubstring() or IsNotSubstring(),</span>
<a name="l01253"></a>01253 <span class="comment">// depending on the value of the expected_to_be_substring parameter.</span>
<a name="l01254"></a>01254 <span class="comment">// StringType here can be const char*, const wchar_t*, ::std::string,</span>
<a name="l01255"></a>01255 <span class="comment">// or ::std::wstring.</span>
<a name="l01256"></a>01256 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> StringType&gt;
<a name="l01257"></a>01257 AssertionResult IsSubstringImpl(
<a name="l01258"></a>01258     <span class="keywordtype">bool</span> expected_to_be_substring,
<a name="l01259"></a>01259     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01260"></a>01260     <span class="keyword">const</span> StringType&amp; needle, <span class="keyword">const</span> StringType&amp; haystack) {
<a name="l01261"></a>01261   <span class="keywordflow">if</span> (IsSubstringPred(needle, haystack) == expected_to_be_substring)
<a name="l01262"></a>01262     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01263"></a>01263 
<a name="l01264"></a>01264   <span class="keyword">const</span> <span class="keywordtype">bool</span> is_wide_string = <span class="keyword">sizeof</span>(needle[0]) &gt; 1;
<a name="l01265"></a>01265   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> begin_string_quote = is_wide_string ? <span class="stringliteral">&quot;L\&quot;&quot;</span> : <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l01266"></a>01266   <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>()
<a name="l01267"></a>01267       &lt;&lt; <span class="stringliteral">&quot;Value of: &quot;</span> &lt;&lt; needle_expr &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>
<a name="l01268"></a>01268       &lt;&lt; <span class="stringliteral">&quot;  Actual: &quot;</span> &lt;&lt; begin_string_quote &lt;&lt; needle &lt;&lt; <span class="stringliteral">&quot;\&quot;\n&quot;</span>
<a name="l01269"></a>01269       &lt;&lt; <span class="stringliteral">&quot;Expected: &quot;</span> &lt;&lt; (expected_to_be_substring ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;not &quot;</span>)
<a name="l01270"></a>01270       &lt;&lt; <span class="stringliteral">&quot;a substring of &quot;</span> &lt;&lt; haystack_expr &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>
<a name="l01271"></a>01271       &lt;&lt; <span class="stringliteral">&quot;Which is: &quot;</span> &lt;&lt; begin_string_quote &lt;&lt; haystack &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l01272"></a>01272 }
<a name="l01273"></a>01273 
<a name="l01274"></a>01274 }  <span class="comment">// namespace</span>
<a name="l01275"></a>01275 
<a name="l01276"></a>01276 <span class="comment">// IsSubstring() and IsNotSubstring() check whether needle is a</span>
<a name="l01277"></a>01277 <span class="comment">// substring of haystack (NULL is considered a substring of itself</span>
<a name="l01278"></a>01278 <span class="comment">// only), and return an appropriate error message when they fail.</span>
<a name="l01279"></a>01279 
<a name="l01280"></a>01280 AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#aa47c8fed5266f284499c1c82dd0e167e">IsSubstring</a>(
<a name="l01281"></a>01281     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01282"></a>01282     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack) {
<a name="l01283"></a>01283   <span class="keywordflow">return</span> IsSubstringImpl(<span class="keyword">true</span>, needle_expr, haystack_expr, needle, haystack);
<a name="l01284"></a>01284 }
<a name="l01285"></a>01285 
<a name="l01286"></a>01286 AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#aa47c8fed5266f284499c1c82dd0e167e">IsSubstring</a>(
<a name="l01287"></a>01287     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01288"></a>01288     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* needle, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* haystack) {
<a name="l01289"></a>01289   <span class="keywordflow">return</span> IsSubstringImpl(<span class="keyword">true</span>, needle_expr, haystack_expr, needle, haystack);
<a name="l01290"></a>01290 }
<a name="l01291"></a>01291 
<a name="l01292"></a>01292 AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#aeb4296c0ab6b8b4bb90dd7b28369f601">IsNotSubstring</a>(
<a name="l01293"></a>01293     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01294"></a>01294     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack) {
<a name="l01295"></a>01295   <span class="keywordflow">return</span> IsSubstringImpl(<span class="keyword">false</span>, needle_expr, haystack_expr, needle, haystack);
<a name="l01296"></a>01296 }
<a name="l01297"></a>01297 
<a name="l01298"></a>01298 AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#aeb4296c0ab6b8b4bb90dd7b28369f601">IsNotSubstring</a>(
<a name="l01299"></a>01299     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01300"></a>01300     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* needle, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* haystack) {
<a name="l01301"></a>01301   <span class="keywordflow">return</span> IsSubstringImpl(<span class="keyword">false</span>, needle_expr, haystack_expr, needle, haystack);
<a name="l01302"></a>01302 }
<a name="l01303"></a>01303 
<a name="l01304"></a>01304 AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#aa47c8fed5266f284499c1c82dd0e167e">IsSubstring</a>(
<a name="l01305"></a>01305     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01306"></a>01306     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9882e571372fc19a02d2b2949e1f1557">const ::std::string</a>&amp; needle, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9882e571372fc19a02d2b2949e1f1557">const ::std::string</a>&amp; haystack) {
<a name="l01307"></a>01307   <span class="keywordflow">return</span> IsSubstringImpl(<span class="keyword">true</span>, needle_expr, haystack_expr, needle, haystack);
<a name="l01308"></a>01308 }
<a name="l01309"></a>01309 
<a name="l01310"></a>01310 AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#aeb4296c0ab6b8b4bb90dd7b28369f601">IsNotSubstring</a>(
<a name="l01311"></a>01311     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01312"></a>01312     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9882e571372fc19a02d2b2949e1f1557">const ::std::string</a>&amp; needle, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9882e571372fc19a02d2b2949e1f1557">const ::std::string</a>&amp; haystack) {
<a name="l01313"></a>01313   <span class="keywordflow">return</span> IsSubstringImpl(<span class="keyword">false</span>, needle_expr, haystack_expr, needle, haystack);
<a name="l01314"></a>01314 }
<a name="l01315"></a>01315 
<a name="l01316"></a>01316 <span class="preprocessor">#if GTEST_HAS_STD_WSTRING</span>
<a name="l01317"></a>01317 <span class="preprocessor"></span>AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#aa47c8fed5266f284499c1c82dd0e167e">IsSubstring</a>(
<a name="l01318"></a>01318     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01319"></a>01319     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a393885eea6349a55ca3640cccbe912a6">const ::std::wstring</a>&amp; needle, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a393885eea6349a55ca3640cccbe912a6">const ::std::wstring</a>&amp; haystack) {
<a name="l01320"></a>01320   <span class="keywordflow">return</span> IsSubstringImpl(<span class="keyword">true</span>, needle_expr, haystack_expr, needle, haystack);
<a name="l01321"></a>01321 }
<a name="l01322"></a>01322 
<a name="l01323"></a>01323 AssertionResult <a class="code" href="../../d0/d75/namespacetesting.html#aeb4296c0ab6b8b4bb90dd7b28369f601">IsNotSubstring</a>(
<a name="l01324"></a>01324     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01325"></a>01325     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a393885eea6349a55ca3640cccbe912a6">const ::std::wstring</a>&amp; needle, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a393885eea6349a55ca3640cccbe912a6">const ::std::wstring</a>&amp; haystack) {
<a name="l01326"></a>01326   <span class="keywordflow">return</span> IsSubstringImpl(<span class="keyword">false</span>, needle_expr, haystack_expr, needle, haystack);
<a name="l01327"></a>01327 }
<a name="l01328"></a>01328 <span class="preprocessor">#endif  // GTEST_HAS_STD_WSTRING</span>
<a name="l01329"></a>01329 <span class="preprocessor"></span>
<a name="l01330"></a>01330 <span class="keyword">namespace </span>internal {
<a name="l01331"></a>01331 
<a name="l01332"></a>01332 <span class="preprocessor">#if GTEST_OS_WINDOWS</span>
<a name="l01333"></a>01333 <span class="preprocessor"></span>
<a name="l01334"></a>01334 <span class="keyword">namespace </span>{
<a name="l01335"></a>01335 
<a name="l01336"></a>01336 <span class="comment">// Helper function for IsHRESULT{SuccessFailure} predicates</span>
<a name="l01337"></a>01337 AssertionResult HRESULTFailureHelper(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr,
<a name="l01338"></a>01338                                      <span class="keyword">const</span> <span class="keywordtype">char</span>* expected,
<a name="l01339"></a>01339                                      <span class="keywordtype">long</span> hr) {  <span class="comment">// NOLINT</span>
<a name="l01340"></a>01340 <span class="preprocessor"># if GTEST_OS_WINDOWS_MOBILE</span>
<a name="l01341"></a>01341 <span class="preprocessor"></span>
<a name="l01342"></a>01342   <span class="comment">// Windows CE doesn&#39;t support FormatMessage.</span>
<a name="l01343"></a>01343   <span class="keyword">const</span> <span class="keywordtype">char</span> error_text[] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l01344"></a>01344 
<a name="l01345"></a>01345 <span class="preprocessor"># else</span>
<a name="l01346"></a>01346 <span class="preprocessor"></span>
<a name="l01347"></a>01347   <span class="comment">// Looks up the human-readable system message for the HRESULT code</span>
<a name="l01348"></a>01348   <span class="comment">// and since we&#39;re not passing any params to FormatMessage, we don&#39;t</span>
<a name="l01349"></a>01349   <span class="comment">// want inserts expanded.</span>
<a name="l01350"></a>01350   <span class="keyword">const</span> DWORD kFlags = FORMAT_MESSAGE_FROM_SYSTEM |
<a name="l01351"></a>01351                        FORMAT_MESSAGE_IGNORE_INSERTS;
<a name="l01352"></a>01352   <span class="keyword">const</span> DWORD kBufSize = 4096;  <span class="comment">// String::Format can&#39;t exceed this length.</span>
<a name="l01353"></a>01353   <span class="comment">// Gets the system&#39;s human readable message string for this HRESULT.</span>
<a name="l01354"></a>01354   <span class="keywordtype">char</span> error_text[kBufSize] = { <span class="charliteral">&#39;\0&#39;</span> };
<a name="l01355"></a>01355   DWORD message_length = ::FormatMessageA(kFlags,
<a name="l01356"></a>01356                                           0,  <span class="comment">// no source, we&#39;re asking system</span>
<a name="l01357"></a>01357                                           hr,  <span class="comment">// the error</span>
<a name="l01358"></a>01358                                           0,  <span class="comment">// no line width restrictions</span>
<a name="l01359"></a>01359                                           error_text,  <span class="comment">// output buffer</span>
<a name="l01360"></a>01360                                           kBufSize,  <span class="comment">// buf size</span>
<a name="l01361"></a>01361                                           NULL);  <span class="comment">// no arguments for inserts</span>
<a name="l01362"></a>01362   <span class="comment">// Trims tailing white space (FormatMessage leaves a trailing cr-lf)</span>
<a name="l01363"></a>01363   <span class="keywordflow">for</span> (; message_length &amp;&amp; <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac2774601e1c8d09df5179723a5cecf69">IsSpace</a>(error_text[message_length - 1]);
<a name="l01364"></a>01364           --message_length) {
<a name="l01365"></a>01365     error_text[message_length - 1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01366"></a>01366   }
<a name="l01367"></a>01367 
<a name="l01368"></a>01368 <span class="preprocessor"># endif  // GTEST_OS_WINDOWS_MOBILE</span>
<a name="l01369"></a>01369 <span class="preprocessor"></span>
<a name="l01370"></a>01370   <span class="keyword">const</span> String error_hex(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;0x%08X &quot;</span>, hr));
<a name="l01371"></a>01371   <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">return ::testing::AssertionFailure</a>()
<a name="l01372"></a>01372       &lt;&lt; <span class="stringliteral">&quot;Expected: &quot;</span> &lt;&lt; expr &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; expected &lt;&lt; <span class="stringliteral">&quot;.\n&quot;</span>
<a name="l01373"></a>01373       &lt;&lt; <span class="stringliteral">&quot;  Actual: &quot;</span> &lt;&lt; error_hex &lt;&lt; error_text &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01374"></a>01374 }
<a name="l01375"></a>01375 
<a name="l01376"></a>01376 }  <span class="comment">// namespace</span>
<a name="l01377"></a>01377 
<a name="l01378"></a>01378 AssertionResult IsHRESULTSuccess(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr, <span class="keywordtype">long</span> hr) {  <span class="comment">// NOLINT</span>
<a name="l01379"></a>01379   <span class="keywordflow">if</span> (SUCCEEDED(hr)) {
<a name="l01380"></a>01380     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01381"></a>01381   }
<a name="l01382"></a>01382   <span class="keywordflow">return</span> HRESULTFailureHelper(expr, <span class="stringliteral">&quot;succeeds&quot;</span>, hr);
<a name="l01383"></a>01383 }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385 AssertionResult IsHRESULTFailure(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr, <span class="keywordtype">long</span> hr) {  <span class="comment">// NOLINT</span>
<a name="l01386"></a>01386   <span class="keywordflow">if</span> (FAILED(hr)) {
<a name="l01387"></a>01387     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01388"></a>01388   }
<a name="l01389"></a>01389   <span class="keywordflow">return</span> HRESULTFailureHelper(expr, <span class="stringliteral">&quot;fails&quot;</span>, hr);
<a name="l01390"></a>01390 }
<a name="l01391"></a>01391 
<a name="l01392"></a>01392 <span class="preprocessor">#endif  // GTEST_OS_WINDOWS</span>
<a name="l01393"></a>01393 <span class="preprocessor"></span>
<a name="l01394"></a>01394 <span class="comment">// Utility functions for encoding Unicode text (wide strings) in</span>
<a name="l01395"></a>01395 <span class="comment">// UTF-8.</span>
<a name="l01396"></a>01396 
<a name="l01397"></a>01397 <span class="comment">// A Unicode code-point can have upto 21 bits, and is encoded in UTF-8</span>
<a name="l01398"></a>01398 <span class="comment">// like this:</span>
<a name="l01399"></a>01399 <span class="comment">//</span>
<a name="l01400"></a>01400 <span class="comment">// Code-point length   Encoding</span>
<a name="l01401"></a>01401 <span class="comment">//   0 -  7 bits       0xxxxxxx</span>
<a name="l01402"></a>01402 <span class="comment">//   8 - 11 bits       110xxxxx 10xxxxxx</span>
<a name="l01403"></a>01403 <span class="comment">//  12 - 16 bits       1110xxxx 10xxxxxx 10xxxxxx</span>
<a name="l01404"></a>01404 <span class="comment">//  17 - 21 bits       11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span>
<a name="l01405"></a>01405 
<a name="l01406"></a>01406 <span class="comment">// The maximum code-point a one-byte UTF-8 sequence can represent.</span>
<a name="l01407"></a>01407 <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a842ee44b2d352fa626e9c0cc37486e34">kMaxCodePoint1</a> = (<span class="keyword">static_cast&lt;</span><a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a><span class="keyword">&gt;</span>(1) &lt;&lt;  7) - 1;
<a name="l01408"></a>01408 
<a name="l01409"></a>01409 <span class="comment">// The maximum code-point a two-byte UTF-8 sequence can represent.</span>
<a name="l01410"></a>01410 <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af814f29030620a69d0c9e71c5d942990">kMaxCodePoint2</a> = (<span class="keyword">static_cast&lt;</span><a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a><span class="keyword">&gt;</span>(1) &lt;&lt; (5 + 6)) - 1;
<a name="l01411"></a>01411 
<a name="l01412"></a>01412 <span class="comment">// The maximum code-point a three-byte UTF-8 sequence can represent.</span>
<a name="l01413"></a>01413 <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a47b4e6ab732c706ac60eb6be97424da9">kMaxCodePoint3</a> = (<span class="keyword">static_cast&lt;</span><a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a><span class="keyword">&gt;</span>(1) &lt;&lt; (4 + 2*6)) - 1;
<a name="l01414"></a>01414 
<a name="l01415"></a>01415 <span class="comment">// The maximum code-point a four-byte UTF-8 sequence can represent.</span>
<a name="l01416"></a>01416 <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#acea916a3388da016d05faccd72e51f18">kMaxCodePoint4</a> = (<span class="keyword">static_cast&lt;</span><a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a><span class="keyword">&gt;</span>(1) &lt;&lt; (3 + 3*6)) - 1;
<a name="l01417"></a>01417 
<a name="l01418"></a>01418 <span class="comment">// Chops off the n lowest bits from a bit pattern.  Returns the n</span>
<a name="l01419"></a>01419 <span class="comment">// lowest bits.  As a side effect, the original bit pattern will be</span>
<a name="l01420"></a>01420 <span class="comment">// shifted to the right by n bits.</span>
<a name="l01421"></a>01421 <span class="keyword">inline</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae5b8a7eede03981fb212e2a48bccea26">ChopLowBits</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a>* bits, <span class="keywordtype">int</span> n) {
<a name="l01422"></a>01422   <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a> low_bits = *bits &amp; ((<span class="keyword">static_cast&lt;</span><a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a><span class="keyword">&gt;</span>(1) &lt;&lt; n) - 1);
<a name="l01423"></a>01423   *bits &gt;&gt;= n;
<a name="l01424"></a>01424   <span class="keywordflow">return</span> low_bits;
<a name="l01425"></a>01425 }
<a name="l01426"></a>01426 
<a name="l01427"></a>01427 <span class="comment">// Converts a Unicode code point to a narrow string in UTF-8 encoding.</span>
<a name="l01428"></a>01428 <span class="comment">// code_point parameter is of type UInt32 because wchar_t may not be</span>
<a name="l01429"></a>01429 <span class="comment">// wide enough to contain a code point.</span>
<a name="l01430"></a>01430 <span class="comment">// The output buffer str must containt at least 32 characters.</span>
<a name="l01431"></a>01431 <span class="comment">// The function returns the address of the output buffer.</span>
<a name="l01432"></a>01432 <span class="comment">// If the code_point is not a valid Unicode code point</span>
<a name="l01433"></a>01433 <span class="comment">// (i.e. outside of Unicode range U+0 to U+10FFFF) it will be output</span>
<a name="l01434"></a>01434 <span class="comment">// as &#39;(Invalid Unicode 0xXXXXXXXX)&#39;.</span>
<a name="l01435"></a>01435 <span class="keywordtype">char</span>* <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae994812b6d35cea374d4f9754afc1659">CodePointToUtf8</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a> code_point, <span class="keywordtype">char</span>* str) {
<a name="l01436"></a>01436   <span class="keywordflow">if</span> (code_point &lt;= <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a842ee44b2d352fa626e9c0cc37486e34">kMaxCodePoint1</a>) {
<a name="l01437"></a>01437     str[1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01438"></a>01438     str[0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(code_point);                          <span class="comment">// 0xxxxxxx</span>
<a name="l01439"></a>01439   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code_point &lt;= <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af814f29030620a69d0c9e71c5d942990">kMaxCodePoint2</a>) {
<a name="l01440"></a>01440     str[2] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01441"></a>01441     str[1] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0x80 | <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae5b8a7eede03981fb212e2a48bccea26">ChopLowBits</a>(&amp;code_point, 6));  <span class="comment">// 10xxxxxx</span>
<a name="l01442"></a>01442     str[0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0xC0 | code_point);                   <span class="comment">// 110xxxxx</span>
<a name="l01443"></a>01443   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code_point &lt;= <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a47b4e6ab732c706ac60eb6be97424da9">kMaxCodePoint3</a>) {
<a name="l01444"></a>01444     str[3] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01445"></a>01445     str[2] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0x80 | <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae5b8a7eede03981fb212e2a48bccea26">ChopLowBits</a>(&amp;code_point, 6));  <span class="comment">// 10xxxxxx</span>
<a name="l01446"></a>01446     str[1] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0x80 | <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae5b8a7eede03981fb212e2a48bccea26">ChopLowBits</a>(&amp;code_point, 6));  <span class="comment">// 10xxxxxx</span>
<a name="l01447"></a>01447     str[0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0xE0 | code_point);                   <span class="comment">// 1110xxxx</span>
<a name="l01448"></a>01448   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code_point &lt;= <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#acea916a3388da016d05faccd72e51f18">kMaxCodePoint4</a>) {
<a name="l01449"></a>01449     str[4] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01450"></a>01450     str[3] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0x80 | <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae5b8a7eede03981fb212e2a48bccea26">ChopLowBits</a>(&amp;code_point, 6));  <span class="comment">// 10xxxxxx</span>
<a name="l01451"></a>01451     str[2] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0x80 | <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae5b8a7eede03981fb212e2a48bccea26">ChopLowBits</a>(&amp;code_point, 6));  <span class="comment">// 10xxxxxx</span>
<a name="l01452"></a>01452     str[1] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0x80 | <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae5b8a7eede03981fb212e2a48bccea26">ChopLowBits</a>(&amp;code_point, 6));  <span class="comment">// 10xxxxxx</span>
<a name="l01453"></a>01453     str[0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0xF0 | code_point);                   <span class="comment">// 11110xxx</span>
<a name="l01454"></a>01454   } <span class="keywordflow">else</span> {
<a name="l01455"></a>01455     <span class="comment">// The longest string String::Format can produce when invoked</span>
<a name="l01456"></a>01456     <span class="comment">// with these parameters is 28 character long (not including</span>
<a name="l01457"></a>01457     <span class="comment">// the terminating nul character). We are asking for 32 character</span>
<a name="l01458"></a>01458     <span class="comment">// buffer just in case. This is also enough for strncpy to</span>
<a name="l01459"></a>01459     <span class="comment">// null-terminate the destination string.</span>
<a name="l01460"></a>01460     <a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#a261b7136efb272312daa5c1f82e88c79">posix::StrNCpy</a>(
<a name="l01461"></a>01461         str, <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;(Invalid Unicode 0x%X)&quot;</span>, code_point).c_str(), 32);
<a name="l01462"></a>01462     str[31] = <span class="charliteral">&#39;\0&#39;</span>;  <span class="comment">// Makes sure no change in the format to strncpy leaves</span>
<a name="l01463"></a>01463                      <span class="comment">// the result unterminated.</span>
<a name="l01464"></a>01464   }
<a name="l01465"></a>01465   <span class="keywordflow">return</span> str;
<a name="l01466"></a>01466 }
<a name="l01467"></a>01467 
<a name="l01468"></a>01468 <span class="comment">// The following two functions only make sense if the the system</span>
<a name="l01469"></a>01469 <span class="comment">// uses UTF-16 for wide string encoding. All supported systems</span>
<a name="l01470"></a>01470 <span class="comment">// with 16 bit wchar_t (Windows, Cygwin, Symbian OS) do use UTF-16.</span>
<a name="l01471"></a>01471 
<a name="l01472"></a>01472 <span class="comment">// Determines if the arguments constitute UTF-16 surrogate pair</span>
<a name="l01473"></a>01473 <span class="comment">// and thus should be combined into a single Unicode code point</span>
<a name="l01474"></a>01474 <span class="comment">// using CreateCodePointFromUtf16SurrogatePair.</span>
<a name="l01475"></a>01475 <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5295827a346d31a82436982e915b70fb">IsUtf16SurrogatePair</a>(<span class="keywordtype">wchar_t</span> first, <span class="keywordtype">wchar_t</span> second) {
<a name="l01476"></a>01476   <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(wchar_t) == 2 &amp;&amp;
<a name="l01477"></a>01477       (first &amp; 0xFC00) == 0xD800 &amp;&amp; (second &amp; 0xFC00) == 0xDC00;
<a name="l01478"></a>01478 }
<a name="l01479"></a>01479 
<a name="l01480"></a>01480 <span class="comment">// Creates a Unicode code point from UTF16 surrogate pair.</span>
<a name="l01481"></a>01481 <span class="keyword">inline</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5148378e34622f080776dafb62a40a44">CreateCodePointFromUtf16SurrogatePair</a>(<span class="keywordtype">wchar_t</span> first,
<a name="l01482"></a>01482                                                     <span class="keywordtype">wchar_t</span> second) {
<a name="l01483"></a>01483   <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a> mask = (1 &lt;&lt; 10) - 1;
<a name="l01484"></a>01484   <span class="keywordflow">return</span> (<span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>) == 2) ?
<a name="l01485"></a>01485       (((first &amp; mask) &lt;&lt; 10) | (second &amp; mask)) + 0x10000 :
<a name="l01486"></a>01486       <span class="comment">// This function should not be called when the condition is</span>
<a name="l01487"></a>01487       <span class="comment">// false, but we provide a sensible default in case it is.</span>
<a name="l01488"></a>01488       <span class="keyword">static_cast&lt;</span><a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a><span class="keyword">&gt;</span>(first);
<a name="l01489"></a>01489 }
<a name="l01490"></a>01490 
<a name="l01491"></a>01491 <span class="comment">// Converts a wide string to a narrow string in UTF-8 encoding.</span>
<a name="l01492"></a>01492 <span class="comment">// The wide string is assumed to have the following encoding:</span>
<a name="l01493"></a>01493 <span class="comment">//   UTF-16 if sizeof(wchar_t) == 2 (on Windows, Cygwin, Symbian OS)</span>
<a name="l01494"></a>01494 <span class="comment">//   UTF-32 if sizeof(wchar_t) == 4 (on Linux)</span>
<a name="l01495"></a>01495 <span class="comment">// Parameter str points to a null-terminated wide string.</span>
<a name="l01496"></a>01496 <span class="comment">// Parameter num_chars may additionally limit the number</span>
<a name="l01497"></a>01497 <span class="comment">// of wchar_t characters processed. -1 is used when the entire string</span>
<a name="l01498"></a>01498 <span class="comment">// should be processed.</span>
<a name="l01499"></a>01499 <span class="comment">// If the string contains code points that are not valid Unicode code points</span>
<a name="l01500"></a>01500 <span class="comment">// (i.e. outside of Unicode range U+0 to U+10FFFF) they will be output</span>
<a name="l01501"></a>01501 <span class="comment">// as &#39;(Invalid Unicode 0xXXXXXXXX)&#39;. If the string is in UTF16 encoding</span>
<a name="l01502"></a>01502 <span class="comment">// and contains invalid UTF-16 surrogate pairs, values in those pairs</span>
<a name="l01503"></a>01503 <span class="comment">// will be encoded as individual Unicode characters from Basic Normal Plane.</span>
<a name="l01504"></a>01504 String <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a1a297845a586bbc4f853032571736af2">WideStringToUtf8</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* str, <span class="keywordtype">int</span> num_chars) {
<a name="l01505"></a>01505   <span class="keywordflow">if</span> (num_chars == -1)
<a name="l01506"></a>01506     num_chars = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(wcslen(str));
<a name="l01507"></a>01507 
<a name="l01508"></a>01508   ::std::stringstream stream;
<a name="l01509"></a>01509   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_chars; ++i) {
<a name="l01510"></a>01510     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a> unicode_code_point;
<a name="l01511"></a>01511 
<a name="l01512"></a>01512     <span class="keywordflow">if</span> (str[i] == L<span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01513"></a>01513       <span class="keywordflow">break</span>;
<a name="l01514"></a>01514     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i + 1 &lt; num_chars &amp;&amp; <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5295827a346d31a82436982e915b70fb">IsUtf16SurrogatePair</a>(str[i], str[i + 1])) {
<a name="l01515"></a>01515       unicode_code_point = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5148378e34622f080776dafb62a40a44">CreateCodePointFromUtf16SurrogatePair</a>(str[i],
<a name="l01516"></a>01516                                                                  str[i + 1]);
<a name="l01517"></a>01517       i++;
<a name="l01518"></a>01518     } <span class="keywordflow">else</span> {
<a name="l01519"></a>01519       unicode_code_point = <span class="keyword">static_cast&lt;</span><a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a03df445d5850459574de6ffb6f57ae95">UInt32</a><span class="keyword">&gt;</span>(str[i]);
<a name="l01520"></a>01520     }
<a name="l01521"></a>01521 
<a name="l01522"></a>01522     <span class="keywordtype">char</span> buffer[32];  <span class="comment">// CodePointToUtf8 requires a buffer this big.</span>
<a name="l01523"></a>01523     stream &lt;&lt; <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae994812b6d35cea374d4f9754afc1659">CodePointToUtf8</a>(unicode_code_point, buffer);
<a name="l01524"></a>01524   }
<a name="l01525"></a>01525   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#abf99dee8db2ca5a9bc512dd6cc34f048">StringStreamToString</a>(&amp;stream);
<a name="l01526"></a>01526 }
<a name="l01527"></a>01527 
<a name="l01528"></a>01528 <span class="comment">// Converts a wide C string to a String using the UTF-8 encoding.</span>
<a name="l01529"></a>01529 <span class="comment">// NULL will be converted to &quot;(null)&quot;.</span>
<a name="l01530"></a>01530 String <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a350a83c2a7b5b7510072a0fd9f322471">String::ShowWideCString</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span> * wide_c_str) {
<a name="l01531"></a>01531   <span class="keywordflow">if</span> (wide_c_str == NULL) <span class="keywordflow">return</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8db865e64c3c3f65ec6a0b6fd8c09a94">String</a>(<span class="stringliteral">&quot;(null)&quot;</span>);
<a name="l01532"></a>01532 
<a name="l01533"></a>01533   <span class="keywordflow">return</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8db865e64c3c3f65ec6a0b6fd8c09a94">String</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a1a297845a586bbc4f853032571736af2">internal::WideStringToUtf8</a>(wide_c_str, -1).<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>());
<a name="l01534"></a>01534 }
<a name="l01535"></a>01535 
<a name="l01536"></a>01536 <span class="comment">// Similar to ShowWideCString(), except that this function encloses</span>
<a name="l01537"></a>01537 <span class="comment">// the converted string in double quotes.</span>
<a name="l01538"></a>01538 String <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a0e4af8864d2b052cd89e61c1dc21bfaa">String::ShowWideCStringQuoted</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* wide_c_str) {
<a name="l01539"></a>01539   <span class="keywordflow">if</span> (wide_c_str == NULL) <span class="keywordflow">return</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8db865e64c3c3f65ec6a0b6fd8c09a94">String</a>(<span class="stringliteral">&quot;(null)&quot;</span>);
<a name="l01540"></a>01540 
<a name="l01541"></a>01541   <span class="keywordflow">return</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;L\&quot;%s\&quot;&quot;</span>,
<a name="l01542"></a>01542                         <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a350a83c2a7b5b7510072a0fd9f322471">String::ShowWideCString</a>(wide_c_str).<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>());
<a name="l01543"></a>01543 }
<a name="l01544"></a>01544 
<a name="l01545"></a>01545 <span class="comment">// Compares two wide C strings.  Returns true iff they have the same</span>
<a name="l01546"></a>01546 <span class="comment">// content.</span>
<a name="l01547"></a>01547 <span class="comment">//</span>
<a name="l01548"></a>01548 <span class="comment">// Unlike wcscmp(), this function can handle NULL argument(s).  A NULL</span>
<a name="l01549"></a>01549 <span class="comment">// C string is considered different to any non-NULL C string,</span>
<a name="l01550"></a>01550 <span class="comment">// including the empty string.</span>
<a name="l01551"></a>01551 <span class="keywordtype">bool</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a911db0cff27e6663b2ff74014c05de35">String::WideCStringEquals</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span> * lhs, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> * rhs) {
<a name="l01552"></a>01552   <span class="keywordflow">if</span> (lhs == NULL) <span class="keywordflow">return</span> rhs == NULL;
<a name="l01553"></a>01553 
<a name="l01554"></a>01554   <span class="keywordflow">if</span> (rhs == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01555"></a>01555 
<a name="l01556"></a>01556   <span class="keywordflow">return</span> wcscmp(lhs, rhs) == 0;
<a name="l01557"></a>01557 }
<a name="l01558"></a>01558 
<a name="l01559"></a>01559 <span class="comment">// Helper function for *_STREQ on wide strings.</span>
<a name="l01560"></a>01560 AssertionResult <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#aac3ea8412a9d5f786b992a2b06aeb353">CmpHelperSTREQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01561"></a>01561                                <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01562"></a>01562                                <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* expected,
<a name="l01563"></a>01563                                <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* actual) {
<a name="l01564"></a>01564   <span class="keywordflow">if</span> (<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a911db0cff27e6663b2ff74014c05de35">String::WideCStringEquals</a>(expected, actual)) {
<a name="l01565"></a>01565     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01566"></a>01566   }
<a name="l01567"></a>01567 
<a name="l01568"></a>01568   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a1b32471fa3a4994b5e41120a349162ca">EqFailure</a>(expected_expression,
<a name="l01569"></a>01569                    actual_expression,
<a name="l01570"></a>01570                    <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a0e4af8864d2b052cd89e61c1dc21bfaa">String::ShowWideCStringQuoted</a>(expected),
<a name="l01571"></a>01571                    <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a0e4af8864d2b052cd89e61c1dc21bfaa">String::ShowWideCStringQuoted</a>(actual),
<a name="l01572"></a>01572                    <span class="keyword">false</span>);
<a name="l01573"></a>01573 }
<a name="l01574"></a>01574 
<a name="l01575"></a>01575 <span class="comment">// Helper function for *_STRNE on wide strings.</span>
<a name="l01576"></a>01576 AssertionResult <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a24dfe04b51cda2637868440f0e6a7110">CmpHelperSTRNE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s1_expression,
<a name="l01577"></a>01577                                <span class="keyword">const</span> <span class="keywordtype">char</span>* s2_expression,
<a name="l01578"></a>01578                                <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* s1,
<a name="l01579"></a>01579                                <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* s2) {
<a name="l01580"></a>01580   <span class="keywordflow">if</span> (!<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a911db0cff27e6663b2ff74014c05de35">String::WideCStringEquals</a>(s1, s2)) {
<a name="l01581"></a>01581     <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#a6941f23b3ce400dec4d2388cb466271c">AssertionSuccess</a>();
<a name="l01582"></a>01582   }
<a name="l01583"></a>01583 
<a name="l01584"></a>01584   <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#ac0c2a038d9ae21e130904675757fd5f3">AssertionFailure</a>() &lt;&lt; <span class="stringliteral">&quot;Expected: (&quot;</span> &lt;&lt; s1_expression &lt;&lt; <span class="stringliteral">&quot;) != (&quot;</span>
<a name="l01585"></a>01585                             &lt;&lt; s2_expression &lt;&lt; <span class="stringliteral">&quot;), actual: &quot;</span>
<a name="l01586"></a>01586                             &lt;&lt; <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a0e4af8864d2b052cd89e61c1dc21bfaa">String::ShowWideCStringQuoted</a>(s1)
<a name="l01587"></a>01587                             &lt;&lt; <span class="stringliteral">&quot; vs &quot;</span> &lt;&lt; <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a0e4af8864d2b052cd89e61c1dc21bfaa">String::ShowWideCStringQuoted</a>(s2);
<a name="l01588"></a>01588 }
<a name="l01589"></a>01589 
<a name="l01590"></a>01590 <span class="comment">// Compares two C strings, ignoring case.  Returns true iff they have</span>
<a name="l01591"></a>01591 <span class="comment">// the same content.</span>
<a name="l01592"></a>01592 <span class="comment">//</span>
<a name="l01593"></a>01593 <span class="comment">// Unlike strcasecmp(), this function can handle NULL argument(s).  A</span>
<a name="l01594"></a>01594 <span class="comment">// NULL C string is considered different to any non-NULL C string,</span>
<a name="l01595"></a>01595 <span class="comment">// including the empty string.</span>
<a name="l01596"></a>01596 <span class="keywordtype">bool</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a74c3f7f7cf90cc53c995dde20883d922">String::CaseInsensitiveCStringEquals</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * lhs, <span class="keyword">const</span> <span class="keywordtype">char</span> * rhs) {
<a name="l01597"></a>01597   <span class="keywordflow">if</span> (lhs == NULL)
<a name="l01598"></a>01598     <span class="keywordflow">return</span> rhs == NULL;
<a name="l01599"></a>01599   <span class="keywordflow">if</span> (rhs == NULL)
<a name="l01600"></a>01600     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01601"></a>01601   <span class="keywordflow">return</span> <a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#a4f3409b17d947f9e3a8f45d82ef6c862">posix::StrCaseCmp</a>(lhs, rhs) == 0;
<a name="l01602"></a>01602 }
<a name="l01603"></a>01603 
<a name="l01604"></a>01604   <span class="comment">// Compares two wide C strings, ignoring case.  Returns true iff they</span>
<a name="l01605"></a>01605   <span class="comment">// have the same content.</span>
<a name="l01606"></a>01606   <span class="comment">//</span>
<a name="l01607"></a>01607   <span class="comment">// Unlike wcscasecmp(), this function can handle NULL argument(s).</span>
<a name="l01608"></a>01608   <span class="comment">// A NULL C string is considered different to any non-NULL wide C string,</span>
<a name="l01609"></a>01609   <span class="comment">// including the empty string.</span>
<a name="l01610"></a>01610   <span class="comment">// NB: The implementations on different platforms slightly differ.</span>
<a name="l01611"></a>01611   <span class="comment">// On windows, this method uses _wcsicmp which compares according to LC_CTYPE</span>
<a name="l01612"></a>01612   <span class="comment">// environment variable. On GNU platform this method uses wcscasecmp</span>
<a name="l01613"></a>01613   <span class="comment">// which compares according to LC_CTYPE category of the current locale.</span>
<a name="l01614"></a>01614   <span class="comment">// On MacOS X, it uses towlower, which also uses LC_CTYPE category of the</span>
<a name="l01615"></a>01615   <span class="comment">// current locale.</span>
<a name="l01616"></a>01616 <span class="keywordtype">bool</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a7d0738cc0251b4109b35d0c388f99603">String::CaseInsensitiveWideCStringEquals</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* lhs,
<a name="l01617"></a>01617                                               <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* rhs) {
<a name="l01618"></a>01618   <span class="keywordflow">if</span> (lhs == NULL) <span class="keywordflow">return</span> rhs == NULL;
<a name="l01619"></a>01619 
<a name="l01620"></a>01620   <span class="keywordflow">if</span> (rhs == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01621"></a>01621 
<a name="l01622"></a>01622 <span class="preprocessor">#if GTEST_OS_WINDOWS</span>
<a name="l01623"></a>01623 <span class="preprocessor"></span>  <span class="keywordflow">return</span> _wcsicmp(lhs, rhs) == 0;
<a name="l01624"></a>01624 <span class="preprocessor">#elif GTEST_OS_LINUX &amp;&amp; !GTEST_OS_LINUX_ANDROID</span>
<a name="l01625"></a>01625 <span class="preprocessor"></span>  <span class="keywordflow">return</span> wcscasecmp(lhs, rhs) == 0;
<a name="l01626"></a>01626 <span class="preprocessor">#else</span>
<a name="l01627"></a>01627 <span class="preprocessor"></span>  <span class="comment">// Android, Mac OS X and Cygwin don&#39;t define wcscasecmp.</span>
<a name="l01628"></a>01628   <span class="comment">// Other unknown OSes may not define it either.</span>
<a name="l01629"></a>01629   wint_t left, right;
<a name="l01630"></a>01630   <span class="keywordflow">do</span> {
<a name="l01631"></a>01631     left = towlower(*lhs++);
<a name="l01632"></a>01632     right = towlower(*rhs++);
<a name="l01633"></a>01633   } <span class="keywordflow">while</span> (left &amp;&amp; left == right);
<a name="l01634"></a>01634   <span class="keywordflow">return</span> left == right;
<a name="l01635"></a>01635 <span class="preprocessor">#endif  // OS selector</span>
<a name="l01636"></a>01636 <span class="preprocessor"></span>}
<a name="l01637"></a>01637 
<a name="l01638"></a>01638 <span class="comment">// Compares this with another String.</span>
<a name="l01639"></a>01639 <span class="comment">// Returns &lt; 0 if this is less than rhs, 0 if this is equal to rhs, or &gt; 0</span>
<a name="l01640"></a>01640 <span class="comment">// if this is greater than rhs.</span>
<a name="l01641"></a>01641 <span class="keywordtype">int</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a454019802adc8561c0f1cf3c9564d682">String::Compare</a>(<span class="keyword">const</span> String &amp; rhs)<span class="keyword"> const </span>{
<a name="l01642"></a>01642   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> lhs_c_str = <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>();
<a name="l01643"></a>01643   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> rhs_c_str = rhs.c_str();
<a name="l01644"></a>01644 
<a name="l01645"></a>01645   <span class="keywordflow">if</span> (lhs_c_str == NULL) {
<a name="l01646"></a>01646     <span class="keywordflow">return</span> rhs_c_str == NULL ? 0 : -1;  <span class="comment">// NULL &lt; anything except NULL</span>
<a name="l01647"></a>01647   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rhs_c_str == NULL) {
<a name="l01648"></a>01648     <span class="keywordflow">return</span> 1;
<a name="l01649"></a>01649   }
<a name="l01650"></a>01650 
<a name="l01651"></a>01651   <span class="keyword">const</span> <span class="keywordtype">size_t</span> shorter_str_len =
<a name="l01652"></a>01652       <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a2edf269e5cd490f7863c9150bb910c85">length</a>() &lt;= rhs.length() ? <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a2edf269e5cd490f7863c9150bb910c85">length</a>() : rhs.<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a2edf269e5cd490f7863c9150bb910c85">length</a>();
<a name="l01653"></a>01653   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i != shorter_str_len; i++) {
<a name="l01654"></a>01654     <span class="keywordflow">if</span> (lhs_c_str[i] &lt; rhs_c_str[i]) {
<a name="l01655"></a>01655       <span class="keywordflow">return</span> -1;
<a name="l01656"></a>01656     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_c_str[i] &gt; rhs_c_str[i]) {
<a name="l01657"></a>01657       <span class="keywordflow">return</span> 1;
<a name="l01658"></a>01658     }
<a name="l01659"></a>01659   }
<a name="l01660"></a>01660   <span class="keywordflow">return</span> (<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a2edf269e5cd490f7863c9150bb910c85">length</a>() &lt; rhs.length()) ? -1 :
<a name="l01661"></a>01661       (<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a2edf269e5cd490f7863c9150bb910c85">length</a>() &gt; rhs.length()) ? 1 : 0;
<a name="l01662"></a>01662 }
<a name="l01663"></a>01663 
<a name="l01664"></a>01664 <span class="comment">// Returns true iff this String ends with the given suffix.  *Any*</span>
<a name="l01665"></a>01665 <span class="comment">// String is considered to end with a NULL or empty suffix.</span>
<a name="l01666"></a>01666 <span class="keywordtype">bool</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#ad95186cd1bc0b0d6b482487057d8198e">String::EndsWith</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* suffix)<span class="keyword"> const </span>{
<a name="l01667"></a>01667   <span class="keywordflow">if</span> (suffix == NULL || <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#ac1abc71678dbb1323757df95de3c5a46">CStringEquals</a>(suffix, <span class="stringliteral">&quot;&quot;</span>)) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01668"></a>01668 
<a name="l01669"></a>01669   <span class="keywordflow">if</span> (<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>() == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01670"></a>01670 
<a name="l01671"></a>01671   <span class="keyword">const</span> <span class="keywordtype">size_t</span> this_len = strlen(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>());
<a name="l01672"></a>01672   <span class="keyword">const</span> <span class="keywordtype">size_t</span> suffix_len = strlen(suffix);
<a name="l01673"></a>01673   <span class="keywordflow">return</span> (this_len &gt;= suffix_len) &amp;&amp;
<a name="l01674"></a>01674          <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#ac1abc71678dbb1323757df95de3c5a46">CStringEquals</a>(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>() + this_len - suffix_len, suffix);
<a name="l01675"></a>01675 }
<a name="l01676"></a>01676 
<a name="l01677"></a>01677 <span class="comment">// Returns true iff this String ends with the given suffix, ignoring case.</span>
<a name="l01678"></a>01678 <span class="comment">// Any String is considered to end with a NULL or empty suffix.</span>
<a name="l01679"></a>01679 <span class="keywordtype">bool</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a5d6a5d48da3213d93cb038ae045d06e3">String::EndsWithCaseInsensitive</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* suffix)<span class="keyword"> const </span>{
<a name="l01680"></a>01680   <span class="keywordflow">if</span> (suffix == NULL || <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#ac1abc71678dbb1323757df95de3c5a46">CStringEquals</a>(suffix, <span class="stringliteral">&quot;&quot;</span>)) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01681"></a>01681 
<a name="l01682"></a>01682   <span class="keywordflow">if</span> (<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>() == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01683"></a>01683 
<a name="l01684"></a>01684   <span class="keyword">const</span> <span class="keywordtype">size_t</span> this_len = strlen(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>());
<a name="l01685"></a>01685   <span class="keyword">const</span> <span class="keywordtype">size_t</span> suffix_len = strlen(suffix);
<a name="l01686"></a>01686   <span class="keywordflow">return</span> (this_len &gt;= suffix_len) &amp;&amp;
<a name="l01687"></a>01687          <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a74c3f7f7cf90cc53c995dde20883d922">CaseInsensitiveCStringEquals</a>(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>() + this_len - suffix_len, suffix);
<a name="l01688"></a>01688 }
<a name="l01689"></a>01689 
<a name="l01690"></a>01690 <span class="comment">// Formats a list of arguments to a String, using the same format</span>
<a name="l01691"></a>01691 <span class="comment">// spec string as for printf.</span>
<a name="l01692"></a>01692 <span class="comment">//</span>
<a name="l01693"></a>01693 <span class="comment">// We do not use the StringPrintf class as it is not universally</span>
<a name="l01694"></a>01694 <span class="comment">// available.</span>
<a name="l01695"></a>01695 <span class="comment">//</span>
<a name="l01696"></a>01696 <span class="comment">// The result is limited to 4096 characters (including the tailing 0).</span>
<a name="l01697"></a>01697 <span class="comment">// If 4096 characters are not enough to format the input, or if</span>
<a name="l01698"></a>01698 <span class="comment">// there&#39;s an error, &quot;&lt;formatting error or buffer exceeded&gt;&quot; is</span>
<a name="l01699"></a>01699 <span class="comment">// returned.</span>
<a name="l01700"></a>01700 String <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * format, ...) {
<a name="l01701"></a>01701   va_list args;
<a name="l01702"></a>01702   va_start(args, format);
<a name="l01703"></a>01703 
<a name="l01704"></a>01704   <span class="keywordtype">char</span> buffer[4096];
<a name="l01705"></a>01705   <span class="keyword">const</span> <span class="keywordtype">int</span> kBufferSize = <span class="keyword">sizeof</span>(buffer)/<span class="keyword">sizeof</span>(buffer[0]);
<a name="l01706"></a>01706 
<a name="l01707"></a>01707   <span class="comment">// MSVC 8 deprecates vsnprintf(), so we want to suppress warning</span>
<a name="l01708"></a>01708   <span class="comment">// 4996 (deprecated function) there.</span>
<a name="l01709"></a>01709 <span class="preprocessor">#ifdef _MSC_VER  // We are using MSVC.</span>
<a name="l01710"></a>01710 <span class="preprocessor"></span><span class="preprocessor"># pragma warning(push)          // Saves the current warning state.</span>
<a name="l01711"></a>01711 <span class="preprocessor"></span><span class="preprocessor"># pragma warning(disable:4996)  // Temporarily disables warning 4996.</span>
<a name="l01712"></a>01712 <span class="preprocessor"></span>
<a name="l01713"></a>01713   <span class="keyword">const</span> <span class="keywordtype">int</span> size = vsnprintf(buffer, kBufferSize, format, args);
<a name="l01714"></a>01714 
<a name="l01715"></a>01715 <span class="preprocessor"># pragma warning(pop)           // Restores the warning state.</span>
<a name="l01716"></a>01716 <span class="preprocessor"></span><span class="preprocessor">#else  // We are not using MSVC.</span>
<a name="l01717"></a>01717 <span class="preprocessor"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> size = vsnprintf(buffer, kBufferSize, format, args);
<a name="l01718"></a>01718 <span class="preprocessor">#endif  // _MSC_VER</span>
<a name="l01719"></a>01719 <span class="preprocessor"></span>  va_end(args);
<a name="l01720"></a>01720 
<a name="l01721"></a>01721   <span class="comment">// vsnprintf()&#39;s behavior is not portable.  When the buffer is not</span>
<a name="l01722"></a>01722   <span class="comment">// big enough, it returns a negative value in MSVC, and returns the</span>
<a name="l01723"></a>01723   <span class="comment">// needed buffer size on Linux.  When there is an output error, it</span>
<a name="l01724"></a>01724   <span class="comment">// always returns a negative value.  For simplicity, we lump the two</span>
<a name="l01725"></a>01725   <span class="comment">// error cases together.</span>
<a name="l01726"></a>01726   <span class="keywordflow">if</span> (size &lt; 0 || size &gt;= kBufferSize) {
<a name="l01727"></a>01727     <span class="keywordflow">return</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8db865e64c3c3f65ec6a0b6fd8c09a94">String</a>(<span class="stringliteral">&quot;&lt;formatting error or buffer exceeded&gt;&quot;</span>);
<a name="l01728"></a>01728   } <span class="keywordflow">else</span> {
<a name="l01729"></a>01729     <span class="keywordflow">return</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8db865e64c3c3f65ec6a0b6fd8c09a94">String</a>(buffer, size);
<a name="l01730"></a>01730   }
<a name="l01731"></a>01731 }
<a name="l01732"></a>01732 
<a name="l01733"></a>01733 <span class="comment">// Converts the buffer in a stringstream to a String, converting NUL</span>
<a name="l01734"></a>01734 <span class="comment">// bytes to &quot;\\0&quot; along the way.</span>
<a name="l01735"></a>01735 String <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#abf99dee8db2ca5a9bc512dd6cc34f048">StringStreamToString</a>(::std::stringstream* ss) {
<a name="l01736"></a>01736   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9882e571372fc19a02d2b2949e1f1557">const ::std::string</a>&amp; str = ss-&gt;str();
<a name="l01737"></a>01737   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> start = str.c_str();
<a name="l01738"></a>01738   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> end = start + str.length();
<a name="l01739"></a>01739 
<a name="l01740"></a>01740   <span class="comment">// We need to use a helper stringstream to do this transformation</span>
<a name="l01741"></a>01741   <span class="comment">// because String doesn&#39;t support push_back().</span>
<a name="l01742"></a>01742   ::std::stringstream helper;
<a name="l01743"></a>01743   <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>* ch = start; ch != end; ++ch) {
<a name="l01744"></a>01744     <span class="keywordflow">if</span> (*ch == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01745"></a>01745       helper &lt;&lt; <span class="stringliteral">&quot;\\0&quot;</span>;  <span class="comment">// Replaces NUL with &quot;\\0&quot;;</span>
<a name="l01746"></a>01746     } <span class="keywordflow">else</span> {
<a name="l01747"></a>01747       helper.put(*ch);
<a name="l01748"></a>01748     }
<a name="l01749"></a>01749   }
<a name="l01750"></a>01750 
<a name="l01751"></a>01751   <span class="keywordflow">return</span> String(helper.str().c_str());
<a name="l01752"></a>01752 }
<a name="l01753"></a>01753 
<a name="l01754"></a>01754 <span class="comment">// Appends the user-supplied message to the Google-Test-generated message.</span>
<a name="l01755"></a>01755 String <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a92cc3c0f16012ce7143a5c3256c00a29">AppendUserMessage</a>(<span class="keyword">const</span> String&amp; gtest_msg,
<a name="l01756"></a>01756                          <span class="keyword">const</span> Message&amp; user_msg) {
<a name="l01757"></a>01757   <span class="comment">// Appends the user message if it&#39;s non-empty.</span>
<a name="l01758"></a>01758   <span class="keyword">const</span> String user_msg_string = user_msg.GetString();
<a name="l01759"></a>01759   <span class="keywordflow">if</span> (user_msg_string.empty()) {
<a name="l01760"></a>01760     <span class="keywordflow">return</span> gtest_msg;
<a name="l01761"></a>01761   }
<a name="l01762"></a>01762 
<a name="l01763"></a>01763   Message msg;
<a name="l01764"></a>01764   msg &lt;&lt; gtest_msg &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; user_msg_string;
<a name="l01765"></a>01765 
<a name="l01766"></a>01766   <span class="keywordflow">return</span> msg.GetString();
<a name="l01767"></a>01767 }
<a name="l01768"></a>01768 
<a name="l01769"></a>01769 }  <span class="comment">// namespace internal</span>
<a name="l01770"></a>01770 
<a name="l01771"></a>01771 <span class="comment">// class TestResult</span>
<a name="l01772"></a>01772 
<a name="l01773"></a>01773 <span class="comment">// Creates an empty TestResult.</span>
<a name="l01774"></a>01774 <a class="code" href="../../d6/d6e/classtesting_1_1TestResult.html#a434977b0f85d921ae7a2f7ae506576cf">TestResult::TestResult</a>()
<a name="l01775"></a>01775     : death_test_count_(0),
<a name="l01776"></a>01776       elapsed_time_(0) {
<a name="l01777"></a>01777 }
<a name="l01778"></a>01778 
<a name="l01779"></a>01779 <span class="comment">// D&#39;tor.</span>
<a name="l01780"></a>01780 TestResult::~TestResult() {
<a name="l01781"></a>01781 }
<a name="l01782"></a>01782 
<a name="l01783"></a>01783 <span class="comment">// Returns the i-th test part result among all the results. i can</span>
<a name="l01784"></a>01784 <span class="comment">// range from 0 to total_part_count() - 1. If i is not in that range,</span>
<a name="l01785"></a>01785 <span class="comment">// aborts the program.</span>
<a name="l01786"></a>01786 <span class="keyword">const</span> TestPartResult&amp; TestResult::GetTestPartResult(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{
<a name="l01787"></a>01787   <span class="keywordflow">if</span> (i &lt; 0 || i &gt;= total_part_count())
<a name="l01788"></a>01788     <a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#a12b9283f52eaf7610afe4b04fbca2ff0">internal::posix::Abort</a>();
<a name="l01789"></a>01789   <span class="keywordflow">return</span> test_part_results_.at(i);
<a name="l01790"></a>01790 }
<a name="l01791"></a>01791 
<a name="l01792"></a>01792 <span class="comment">// Returns the i-th test property. i can range from 0 to</span>
<a name="l01793"></a>01793 <span class="comment">// test_property_count() - 1. If i is not in that range, aborts the</span>
<a name="l01794"></a>01794 <span class="comment">// program.</span>
<a name="l01795"></a>01795 <span class="keyword">const</span> TestProperty&amp; TestResult::GetTestProperty(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{
<a name="l01796"></a>01796   <span class="keywordflow">if</span> (i &lt; 0 || i &gt;= test_property_count())
<a name="l01797"></a>01797     <a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#a12b9283f52eaf7610afe4b04fbca2ff0">internal::posix::Abort</a>();
<a name="l01798"></a>01798   <span class="keywordflow">return</span> test_properties_.at(i);
<a name="l01799"></a>01799 }
<a name="l01800"></a>01800 
<a name="l01801"></a>01801 <span class="comment">// Clears the test part results.</span>
<a name="l01802"></a>01802 <span class="keywordtype">void</span> TestResult::ClearTestPartResults() {
<a name="l01803"></a>01803   test_part_results_.clear();
<a name="l01804"></a>01804 }
<a name="l01805"></a>01805 
<a name="l01806"></a>01806 <span class="comment">// Adds a test part result to the list.</span>
<a name="l01807"></a>01807 <span class="keywordtype">void</span> TestResult::AddTestPartResult(<span class="keyword">const</span> TestPartResult&amp; test_part_result) {
<a name="l01808"></a>01808   test_part_results_.push_back(test_part_result);
<a name="l01809"></a>01809 }
<a name="l01810"></a>01810 
<a name="l01811"></a>01811 <span class="comment">// Adds a test property to the list. If a property with the same key as the</span>
<a name="l01812"></a>01812 <span class="comment">// supplied property is already represented, the value of this test_property</span>
<a name="l01813"></a>01813 <span class="comment">// replaces the old value for that key.</span>
<a name="l01814"></a>01814 <span class="keywordtype">void</span> TestResult::RecordProperty(<span class="keyword">const</span> TestProperty&amp; test_property) {
<a name="l01815"></a>01815   <span class="keywordflow">if</span> (!ValidateTestProperty(test_property)) {
<a name="l01816"></a>01816     <span class="keywordflow">return</span>;
<a name="l01817"></a>01817   }
<a name="l01818"></a>01818   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0ceb93bd27638edfa3ced2469951fd99">internal::MutexLock</a> lock(&amp;test_properites_mutex_);
<a name="l01819"></a>01819   <span class="keyword">const</span> std::vector&lt;TestProperty&gt;::iterator property_with_matching_key =
<a name="l01820"></a>01820       std::find_if(test_properties_.begin(), test_properties_.end(),
<a name="l01821"></a>01821                    internal::TestPropertyKeyIs(test_property.key()));
<a name="l01822"></a>01822   <span class="keywordflow">if</span> (property_with_matching_key == test_properties_.end()) {
<a name="l01823"></a>01823     test_properties_.push_back(test_property);
<a name="l01824"></a>01824     <span class="keywordflow">return</span>;
<a name="l01825"></a>01825   }
<a name="l01826"></a>01826   property_with_matching_key-&gt;SetValue(test_property.value());
<a name="l01827"></a>01827 }
<a name="l01828"></a>01828 
<a name="l01829"></a>01829 <span class="comment">// Adds a failure if the key is a reserved attribute of Google Test</span>
<a name="l01830"></a>01830 <span class="comment">// testcase tags.  Returns true if the property is valid.</span>
<a name="l01831"></a>01831 <span class="keywordtype">bool</span> TestResult::ValidateTestProperty(<span class="keyword">const</span> TestProperty&amp; test_property) {
<a name="l01832"></a>01832   internal::String key(test_property.key());
<a name="l01833"></a>01833   <span class="keywordflow">if</span> (key == <span class="stringliteral">&quot;name&quot;</span> || key == <span class="stringliteral">&quot;status&quot;</span> || key == <span class="stringliteral">&quot;time&quot;</span> || key == <span class="stringliteral">&quot;classname&quot;</span>) {
<a name="l01834"></a>01834     <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#adc16b5b0a740c39084ea5c9e960e3063">ADD_FAILURE</a>()
<a name="l01835"></a>01835         &lt;&lt; <span class="stringliteral">&quot;Reserved key used in RecordProperty(): &quot;</span>
<a name="l01836"></a>01836         &lt;&lt; key
<a name="l01837"></a>01837         &lt;&lt; <span class="stringliteral">&quot; (&#39;name&#39;, &#39;status&#39;, &#39;time&#39;, and &#39;classname&#39; are reserved by &quot;</span>
<a name="l01838"></a>01838         &lt;&lt; <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a13d98c217176bd8722c395b9225fc19d">GTEST_NAME_</a> &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
<a name="l01839"></a>01839     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01840"></a>01840   }
<a name="l01841"></a>01841   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01842"></a>01842 }
<a name="l01843"></a>01843 
<a name="l01844"></a>01844 <span class="comment">// Clears the object.</span>
<a name="l01845"></a>01845 <span class="keywordtype">void</span> TestResult::Clear() {
<a name="l01846"></a>01846   test_part_results_.clear();
<a name="l01847"></a>01847   test_properties_.clear();
<a name="l01848"></a>01848   death_test_count_ = 0;
<a name="l01849"></a>01849   elapsed_time_ = 0;
<a name="l01850"></a>01850 }
<a name="l01851"></a>01851 
<a name="l01852"></a>01852 <span class="comment">// Returns true iff the test failed.</span>
<a name="l01853"></a>01853 <span class="keywordtype">bool</span> TestResult::Failed()<span class="keyword"> const </span>{
<a name="l01854"></a>01854   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; total_part_count(); ++i) {
<a name="l01855"></a>01855     <span class="keywordflow">if</span> (GetTestPartResult(i).failed())
<a name="l01856"></a>01856       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01857"></a>01857   }
<a name="l01858"></a>01858   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01859"></a>01859 }
<a name="l01860"></a>01860 
<a name="l01861"></a>01861 <span class="comment">// Returns true iff the test part fatally failed.</span>
<a name="l01862"></a>01862 <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d0/d75/namespacetesting.html#a88dd754d53baae013bf937f960e67306">TestPartFatallyFailed</a>(<span class="keyword">const</span> TestPartResult&amp; result) {
<a name="l01863"></a>01863   <span class="keywordflow">return</span> result.fatally_failed();
<a name="l01864"></a>01864 }
<a name="l01865"></a>01865 
<a name="l01866"></a>01866 <span class="comment">// Returns true iff the test fatally failed.</span>
<a name="l01867"></a>01867 <span class="keywordtype">bool</span> TestResult::HasFatalFailure()<span class="keyword"> const </span>{
<a name="l01868"></a>01868   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab37ae76c997078f65ba28f35b3657151">CountIf</a>(test_part_results_, <a class="code" href="../../d0/d75/namespacetesting.html#a88dd754d53baae013bf937f960e67306">TestPartFatallyFailed</a>) &gt; 0;
<a name="l01869"></a>01869 }
<a name="l01870"></a>01870 
<a name="l01871"></a>01871 <span class="comment">// Returns true iff the test part non-fatally failed.</span>
<a name="l01872"></a>01872 <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d0/d75/namespacetesting.html#a650fdc14846c63608fb1c0810bf2b5ca">TestPartNonfatallyFailed</a>(<span class="keyword">const</span> TestPartResult&amp; result) {
<a name="l01873"></a>01873   <span class="keywordflow">return</span> result.nonfatally_failed();
<a name="l01874"></a>01874 }
<a name="l01875"></a>01875 
<a name="l01876"></a>01876 <span class="comment">// Returns true iff the test has a non-fatal failure.</span>
<a name="l01877"></a>01877 <span class="keywordtype">bool</span> TestResult::HasNonfatalFailure()<span class="keyword"> const </span>{
<a name="l01878"></a>01878   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab37ae76c997078f65ba28f35b3657151">CountIf</a>(test_part_results_, <a class="code" href="../../d0/d75/namespacetesting.html#a650fdc14846c63608fb1c0810bf2b5ca">TestPartNonfatallyFailed</a>) &gt; 0;
<a name="l01879"></a>01879 }
<a name="l01880"></a>01880 
<a name="l01881"></a>01881 <span class="comment">// Gets the number of all test parts.  This is the sum of the number</span>
<a name="l01882"></a>01882 <span class="comment">// of successful test parts and the number of failed test parts.</span>
<a name="l01883"></a>01883 <span class="keywordtype">int</span> TestResult::total_part_count()<span class="keyword"> const </span>{
<a name="l01884"></a>01884   <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(test_part_results_.size());
<a name="l01885"></a>01885 }
<a name="l01886"></a>01886 
<a name="l01887"></a>01887 <span class="comment">// Returns the number of the test properties.</span>
<a name="l01888"></a>01888 <span class="keywordtype">int</span> TestResult::test_property_count()<span class="keyword"> const </span>{
<a name="l01889"></a>01889   <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(test_properties_.size());
<a name="l01890"></a>01890 }
<a name="l01891"></a>01891 
<a name="l01892"></a>01892 <span class="comment">// class Test</span>
<a name="l01893"></a>01893 
<a name="l01894"></a>01894 <span class="comment">// Creates a Test object.</span>
<a name="l01895"></a>01895 
<a name="l01896"></a>01896 <span class="comment">// The c&#39;tor saves the values of all Google Test flags.</span>
<a name="l01897"></a>01897 Test::Test()
<a name="l01898"></a>01898     : gtest_flag_saver_(new internal::GTestFlagSaver) {
<a name="l01899"></a>01899 }
<a name="l01900"></a>01900 
<a name="l01901"></a>01901 <span class="comment">// The d&#39;tor restores the values of all Google Test flags.</span>
<a name="l01902"></a>01902 Test::~Test() {
<a name="l01903"></a>01903   <span class="keyword">delete</span> gtest_flag_saver_;
<a name="l01904"></a>01904 }
<a name="l01905"></a>01905 
<a name="l01906"></a>01906 <span class="comment">// Sets up the test fixture.</span>
<a name="l01907"></a>01907 <span class="comment">//</span>
<a name="l01908"></a>01908 <span class="comment">// A sub-class may override this.</span>
<a name="l01909"></a>01909 <span class="keywordtype">void</span> Test::SetUp() {
<a name="l01910"></a>01910 }
<a name="l01911"></a>01911 
<a name="l01912"></a>01912 <span class="comment">// Tears down the test fixture.</span>
<a name="l01913"></a>01913 <span class="comment">//</span>
<a name="l01914"></a>01914 <span class="comment">// A sub-class may override this.</span>
<a name="l01915"></a>01915 <span class="keywordtype">void</span> Test::TearDown() {
<a name="l01916"></a>01916 }
<a name="l01917"></a>01917 
<a name="l01918"></a>01918 <span class="comment">// Allows user supplied key value pairs to be recorded for later output.</span>
<a name="l01919"></a>01919 <span class="keywordtype">void</span> Test::RecordProperty(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keyword">const</span> <span class="keywordtype">char</span>* value) {
<a name="l01920"></a>01920   UnitTest::GetInstance()-&gt;RecordPropertyForCurrentTest(key, value);
<a name="l01921"></a>01921 }
<a name="l01922"></a>01922 
<a name="l01923"></a>01923 <span class="comment">// Allows user supplied key value pairs to be recorded for later output.</span>
<a name="l01924"></a>01924 <span class="keywordtype">void</span> Test::RecordProperty(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keywordtype">int</span> value) {
<a name="l01925"></a>01925   Message value_message;
<a name="l01926"></a>01926   value_message &lt;&lt; value;
<a name="l01927"></a>01927   RecordProperty(key, value_message.GetString().c_str());
<a name="l01928"></a>01928 }
<a name="l01929"></a>01929 
<a name="l01930"></a>01930 <span class="keyword">namespace </span>internal {
<a name="l01931"></a>01931 
<a name="l01932"></a>01932 <span class="keywordtype">void</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a544a5c0a7bc19f664d434be72ecbdbfa">ReportFailureInUnknownLocation</a>(TestPartResult::Type result_type,
<a name="l01933"></a>01933                                     <span class="keyword">const</span> String&amp; message) {
<a name="l01934"></a>01934   <span class="comment">// This function is a friend of UnitTest and as such has access to</span>
<a name="l01935"></a>01935   <span class="comment">// AddTestPartResult.</span>
<a name="l01936"></a>01936   UnitTest::GetInstance()-&gt;AddTestPartResult(
<a name="l01937"></a>01937       result_type,
<a name="l01938"></a>01938       NULL,  <span class="comment">// No info about the source file where the exception occurred.</span>
<a name="l01939"></a>01939       -1,    <span class="comment">// We have no info on which line caused the exception.</span>
<a name="l01940"></a>01940       message,
<a name="l01941"></a>01941       String());  <span class="comment">// No stack trace, either.</span>
<a name="l01942"></a>01942 }
<a name="l01943"></a>01943 
<a name="l01944"></a>01944 }  <span class="comment">// namespace internal</span>
<a name="l01945"></a>01945 
<a name="l01946"></a>01946 <span class="comment">// Google Test requires all tests in the same test case to use the same test</span>
<a name="l01947"></a>01947 <span class="comment">// fixture class.  This function checks if the current test has the</span>
<a name="l01948"></a>01948 <span class="comment">// same fixture class as the first test in the current test case.  If</span>
<a name="l01949"></a>01949 <span class="comment">// yes, it returns true; otherwise it generates a Google Test failure and</span>
<a name="l01950"></a>01950 <span class="comment">// returns false.</span>
<a name="l01951"></a>01951 <span class="keywordtype">bool</span> Test::HasSameFixtureClass() {
<a name="l01952"></a>01952   internal::UnitTestImpl* <span class="keyword">const</span> impl = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3ae874a4030c4aa27d77d67bf08d9e1d">internal::GetUnitTestImpl</a>();
<a name="l01953"></a>01953   <span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>* <span class="keyword">const</span> test_case = impl-&gt;current_test_case();
<a name="l01954"></a>01954 
<a name="l01955"></a>01955   <span class="comment">// Info about the first test in the current test case.</span>
<a name="l01956"></a>01956   <span class="keyword">const</span> TestInfo* <span class="keyword">const</span> first_test_info = test_case-&gt;test_info_list()[0];
<a name="l01957"></a>01957   <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac8e91f0c6a06c0361dc3152ddfeb2342">internal::TypeId</a> first_fixture_id = first_test_info-&gt;fixture_class_id_;
<a name="l01958"></a>01958   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> first_test_name = first_test_info-&gt;name();
<a name="l01959"></a>01959 
<a name="l01960"></a>01960   <span class="comment">// Info about the current test.</span>
<a name="l01961"></a>01961   <span class="keyword">const</span> TestInfo* <span class="keyword">const</span> this_test_info = impl-&gt;current_test_info();
<a name="l01962"></a>01962   <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac8e91f0c6a06c0361dc3152ddfeb2342">internal::TypeId</a> this_fixture_id = this_test_info-&gt;fixture_class_id_;
<a name="l01963"></a>01963   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> this_test_name = this_test_info-&gt;name();
<a name="l01964"></a>01964 
<a name="l01965"></a>01965   <span class="keywordflow">if</span> (this_fixture_id != first_fixture_id) {
<a name="l01966"></a>01966     <span class="comment">// Is the first test defined using TEST?</span>
<a name="l01967"></a>01967     <span class="keyword">const</span> <span class="keywordtype">bool</span> first_is_TEST = first_fixture_id == <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3e7f71e983859c908bae4ec8d593ff58">internal::GetTestTypeId</a>();
<a name="l01968"></a>01968     <span class="comment">// Is this test defined using TEST?</span>
<a name="l01969"></a>01969     <span class="keyword">const</span> <span class="keywordtype">bool</span> this_is_TEST = this_fixture_id == <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3e7f71e983859c908bae4ec8d593ff58">internal::GetTestTypeId</a>();
<a name="l01970"></a>01970 
<a name="l01971"></a>01971     <span class="keywordflow">if</span> (first_is_TEST || this_is_TEST) {
<a name="l01972"></a>01972       <span class="comment">// The user mixed TEST and TEST_F in this test case - we&#39;ll tell</span>
<a name="l01973"></a>01973       <span class="comment">// him/her how to fix it.</span>
<a name="l01974"></a>01974 
<a name="l01975"></a>01975       <span class="comment">// Gets the name of the TEST and the name of the TEST_F.  Note</span>
<a name="l01976"></a>01976       <span class="comment">// that first_is_TEST and this_is_TEST cannot both be true, as</span>
<a name="l01977"></a>01977       <span class="comment">// the fixture IDs are different for the two tests.</span>
<a name="l01978"></a>01978       <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> TEST_name =
<a name="l01979"></a>01979           first_is_TEST ? first_test_name : this_test_name;
<a name="l01980"></a>01980       <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> TEST_F_name =
<a name="l01981"></a>01981           first_is_TEST ? this_test_name : first_test_name;
<a name="l01982"></a>01982 
<a name="l01983"></a>01983       <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#adc16b5b0a740c39084ea5c9e960e3063">ADD_FAILURE</a>()
<a name="l01984"></a>01984           &lt;&lt; <span class="stringliteral">&quot;All tests in the same test case must use the same test fixture\n&quot;</span>
<a name="l01985"></a>01985           &lt;&lt; <span class="stringliteral">&quot;class, so mixing TEST_F and TEST in the same test case is\n&quot;</span>
<a name="l01986"></a>01986           &lt;&lt; <span class="stringliteral">&quot;illegal.  In test case &quot;</span> &lt;&lt; this_test_info-&gt;test_case_name()
<a name="l01987"></a>01987           &lt;&lt; <span class="stringliteral">&quot;,\n&quot;</span>
<a name="l01988"></a>01988           &lt;&lt; <span class="stringliteral">&quot;test &quot;</span> &lt;&lt; TEST_F_name &lt;&lt; <span class="stringliteral">&quot; is defined using TEST_F but\n&quot;</span>
<a name="l01989"></a>01989           &lt;&lt; <span class="stringliteral">&quot;test &quot;</span> &lt;&lt; TEST_name &lt;&lt; <span class="stringliteral">&quot; is defined using TEST.  You probably\n&quot;</span>
<a name="l01990"></a>01990           &lt;&lt; <span class="stringliteral">&quot;want to change the TEST to TEST_F or move it to another test\n&quot;</span>
<a name="l01991"></a>01991           &lt;&lt; <span class="stringliteral">&quot;case.&quot;</span>;
<a name="l01992"></a>01992     } <span class="keywordflow">else</span> {
<a name="l01993"></a>01993       <span class="comment">// The user defined two fixture classes with the same name in</span>
<a name="l01994"></a>01994       <span class="comment">// two namespaces - we&#39;ll tell him/her how to fix it.</span>
<a name="l01995"></a>01995       <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#adc16b5b0a740c39084ea5c9e960e3063">ADD_FAILURE</a>()
<a name="l01996"></a>01996           &lt;&lt; <span class="stringliteral">&quot;All tests in the same test case must use the same test fixture\n&quot;</span>
<a name="l01997"></a>01997           &lt;&lt; <span class="stringliteral">&quot;class.  However, in test case &quot;</span>
<a name="l01998"></a>01998           &lt;&lt; this_test_info-&gt;test_case_name() &lt;&lt; <span class="stringliteral">&quot;,\n&quot;</span>
<a name="l01999"></a>01999           &lt;&lt; <span class="stringliteral">&quot;you defined test &quot;</span> &lt;&lt; first_test_name
<a name="l02000"></a>02000           &lt;&lt; <span class="stringliteral">&quot; and test &quot;</span> &lt;&lt; this_test_name &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>
<a name="l02001"></a>02001           &lt;&lt; <span class="stringliteral">&quot;using two different test fixture classes.  This can happen if\n&quot;</span>
<a name="l02002"></a>02002           &lt;&lt; <span class="stringliteral">&quot;the two classes are from different namespaces or translation\n&quot;</span>
<a name="l02003"></a>02003           &lt;&lt; <span class="stringliteral">&quot;units and have the same name.  You should probably rename one\n&quot;</span>
<a name="l02004"></a>02004           &lt;&lt; <span class="stringliteral">&quot;of the classes to put the tests into different test cases.&quot;</span>;
<a name="l02005"></a>02005     }
<a name="l02006"></a>02006     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02007"></a>02007   }
<a name="l02008"></a>02008 
<a name="l02009"></a>02009   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02010"></a>02010 }
<a name="l02011"></a>02011 
<a name="l02012"></a>02012 <span class="preprocessor">#if GTEST_HAS_SEH</span>
<a name="l02013"></a>02013 <span class="preprocessor"></span>
<a name="l02014"></a>02014 <span class="comment">// Adds an &quot;exception thrown&quot; fatal failure to the current test.  This</span>
<a name="l02015"></a>02015 <span class="comment">// function returns its result via an output parameter pointer because VC++</span>
<a name="l02016"></a>02016 <span class="comment">// prohibits creation of objects with destructors on stack in functions</span>
<a name="l02017"></a>02017 <span class="comment">// using __try (see error C2712).</span>
<a name="l02018"></a>02018 <span class="keyword">static</span> internal::String* FormatSehExceptionMessage(DWORD exception_code,
<a name="l02019"></a>02019                                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* location) {
<a name="l02020"></a>02020   Message <a class="code" href="../../d6/dc2/namespacegtest__output__test.html#a536593b2a92b75b5c370d337feb4f615">message</a>;
<a name="l02021"></a>02021   message &lt;&lt; <span class="stringliteral">&quot;SEH exception with code 0x&quot;</span> &lt;&lt; std::setbase(16) &lt;&lt;
<a name="l02022"></a>02022     exception_code &lt;&lt; std::setbase(10) &lt;&lt; <span class="stringliteral">&quot; thrown in &quot;</span> &lt;&lt; location &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;
<a name="l02023"></a>02023 
<a name="l02024"></a>02024   <span class="keywordflow">return</span> <span class="keyword">new</span> internal::String(message.GetString());
<a name="l02025"></a>02025 }
<a name="l02026"></a>02026 
<a name="l02027"></a>02027 <span class="preprocessor">#endif  // GTEST_HAS_SEH</span>
<a name="l02028"></a>02028 <span class="preprocessor"></span>
<a name="l02029"></a>02029 <span class="preprocessor">#if GTEST_HAS_EXCEPTIONS</span>
<a name="l02030"></a>02030 <span class="preprocessor"></span>
<a name="l02031"></a>02031 <span class="comment">// Adds an &quot;exception thrown&quot; fatal failure to the current test.</span>
<a name="l02032"></a>02032 <span class="keyword">static</span> internal::String FormatCxxExceptionMessage(<span class="keyword">const</span> <span class="keywordtype">char</span>* description,
<a name="l02033"></a>02033                                                   <span class="keyword">const</span> <span class="keywordtype">char</span>* location) {
<a name="l02034"></a>02034   Message <a class="code" href="../../d6/dc2/namespacegtest__output__test.html#a536593b2a92b75b5c370d337feb4f615">message</a>;
<a name="l02035"></a>02035   <span class="keywordflow">if</span> (description != NULL) {
<a name="l02036"></a>02036     message &lt;&lt; <span class="stringliteral">&quot;C++ exception with description \&quot;&quot;</span> &lt;&lt; description &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l02037"></a>02037   } <span class="keywordflow">else</span> {
<a name="l02038"></a>02038     message &lt;&lt; <span class="stringliteral">&quot;Unknown C++ exception&quot;</span>;
<a name="l02039"></a>02039   }
<a name="l02040"></a>02040   message &lt;&lt; <span class="stringliteral">&quot; thrown in &quot;</span> &lt;&lt; location &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;
<a name="l02041"></a>02041 
<a name="l02042"></a>02042   <span class="keywordflow">return</span> message.GetString();
<a name="l02043"></a>02043 }
<a name="l02044"></a>02044 
<a name="l02045"></a>02045 <span class="keyword">static</span> internal::String <a class="code" href="../../d0/d75/namespacetesting.html#aa72a7aad5f2a9ccde41699f09348160a">PrintTestPartResultToString</a>(
<a name="l02046"></a>02046     <span class="keyword">const</span> TestPartResult&amp; test_part_result);
<a name="l02047"></a>02047 
<a name="l02048"></a>02048 <span class="comment">// A failed Google Test assertion will throw an exception of this type when</span>
<a name="l02049"></a>02049 <span class="comment">// GTEST_FLAG(throw_on_failure) is true (if exceptions are enabled).  We</span>
<a name="l02050"></a>02050 <span class="comment">// derive it from std::runtime_error, which is for errors presumably</span>
<a name="l02051"></a>02051 <span class="comment">// detectable only at run time.  Since std::runtime_error inherits from</span>
<a name="l02052"></a>02052 <span class="comment">// std::exception, many testing frameworks know how to extract and print the</span>
<a name="l02053"></a>02053 <span class="comment">// message inside it.</span>
<a name="l02054"></a>02054 <span class="keyword">class </span>GoogleTestFailureException : <span class="keyword">public</span> ::std::runtime_error {
<a name="l02055"></a>02055  <span class="keyword">public</span>:
<a name="l02056"></a>02056   <span class="keyword">explicit</span> GoogleTestFailureException(<span class="keyword">const</span> TestPartResult&amp; failure)
<a name="l02057"></a>02057       : ::std::runtime_error(<a class="code" href="../../d0/d75/namespacetesting.html#aa72a7aad5f2a9ccde41699f09348160a">PrintTestPartResultToString</a>(failure).c_str()) {}
<a name="l02058"></a>02058 };
<a name="l02059"></a>02059 <span class="preprocessor">#endif  // GTEST_HAS_EXCEPTIONS</span>
<a name="l02060"></a>02060 <span class="preprocessor"></span>
<a name="l02061"></a>02061 <span class="keyword">namespace </span>internal {
<a name="l02062"></a>02062 <span class="comment">// We put these helper functions in the internal namespace as IBM&#39;s xlC</span>
<a name="l02063"></a>02063 <span class="comment">// compiler rejects the code if they were declared static.</span>
<a name="l02064"></a>02064 
<a name="l02065"></a>02065 <span class="comment">// Runs the given method and handles SEH exceptions it throws, when</span>
<a name="l02066"></a>02066 <span class="comment">// SEH is supported; returns the 0-value for type Result in case of an</span>
<a name="l02067"></a>02067 <span class="comment">// SEH exception.  (Microsoft compilers cannot handle SEH and C++</span>
<a name="l02068"></a>02068 <span class="comment">// exceptions in the same function.  Therefore, we provide a separate</span>
<a name="l02069"></a>02069 <span class="comment">// wrapper function for handling SEH exceptions.)</span>
<a name="l02070"></a>02070 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">typename</span> Result&gt;
<a name="l02071"></a>02071 Result <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac7b1ac01c4703111210df6badab74591">HandleSehExceptionsInMethodIfSupported</a>(
<a name="l02072"></a>02072     T* <span class="keywordtype">object</span>, Result (T::*method)(), <span class="keyword">const</span> <span class="keywordtype">char</span>* location) {
<a name="l02073"></a>02073 <span class="preprocessor">#if GTEST_HAS_SEH</span>
<a name="l02074"></a>02074 <span class="preprocessor"></span>  __try {
<a name="l02075"></a>02075     <span class="keywordflow">return</span> (object-&gt;*method)();
<a name="l02076"></a>02076   } __except (internal::UnitTestOptions::GTestShouldProcessSEH(  <span class="comment">// NOLINT</span>
<a name="l02077"></a>02077       GetExceptionCode())) {
<a name="l02078"></a>02078     <span class="comment">// We create the exception message on the heap because VC++ prohibits</span>
<a name="l02079"></a>02079     <span class="comment">// creation of objects with destructors on stack in functions using __try</span>
<a name="l02080"></a>02080     <span class="comment">// (see error C2712).</span>
<a name="l02081"></a>02081     internal::String* exception_message = FormatSehExceptionMessage(
<a name="l02082"></a>02082         GetExceptionCode(), location);
<a name="l02083"></a>02083     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a544a5c0a7bc19f664d434be72ecbdbfa">internal::ReportFailureInUnknownLocation</a>(TestPartResult::kFatalFailure,
<a name="l02084"></a>02084                                              *exception_message);
<a name="l02085"></a>02085     <span class="keyword">delete</span> exception_message;
<a name="l02086"></a>02086     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Result<span class="keyword">&gt;</span>(0);
<a name="l02087"></a>02087   }
<a name="l02088"></a>02088 <span class="preprocessor">#else</span>
<a name="l02089"></a>02089 <span class="preprocessor"></span>  (void)location;
<a name="l02090"></a>02090   <span class="keywordflow">return</span> (object-&gt;*method)();
<a name="l02091"></a>02091 <span class="preprocessor">#endif  // GTEST_HAS_SEH</span>
<a name="l02092"></a>02092 <span class="preprocessor"></span>}
<a name="l02093"></a>02093 
<a name="l02094"></a>02094 <span class="comment">// Runs the given method and catches and reports C++ and/or SEH-style</span>
<a name="l02095"></a>02095 <span class="comment">// exceptions, if they are supported; returns the 0-value for type</span>
<a name="l02096"></a>02096 <span class="comment">// Result in case of an SEH exception.</span>
<a name="l02097"></a>02097 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">typename</span> Result&gt;
<a name="l02098"></a>02098 Result <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0034a1799f52bef77bb3b810af8b8969">HandleExceptionsInMethodIfSupported</a>(
<a name="l02099"></a>02099     T* <span class="keywordtype">object</span>, Result (T::*method)(), <span class="keyword">const</span> <span class="keywordtype">char</span>* location) {
<a name="l02100"></a>02100   <span class="comment">// NOTE: The user code can affect the way in which Google Test handles</span>
<a name="l02101"></a>02101   <span class="comment">// exceptions by setting GTEST_FLAG(catch_exceptions), but only before</span>
<a name="l02102"></a>02102   <span class="comment">// RUN_ALL_TESTS() starts. It is technically possible to check the flag</span>
<a name="l02103"></a>02103   <span class="comment">// after the exception is caught and either report or re-throw the</span>
<a name="l02104"></a>02104   <span class="comment">// exception based on the flag&#39;s value:</span>
<a name="l02105"></a>02105   <span class="comment">//</span>
<a name="l02106"></a>02106   <span class="comment">// try {</span>
<a name="l02107"></a>02107   <span class="comment">//   // Perform the test method.</span>
<a name="l02108"></a>02108   <span class="comment">// } catch (...) {</span>
<a name="l02109"></a>02109   <span class="comment">//   if (GTEST_FLAG(catch_exceptions))</span>
<a name="l02110"></a>02110   <span class="comment">//     // Report the exception as failure.</span>
<a name="l02111"></a>02111   <span class="comment">//   else</span>
<a name="l02112"></a>02112   <span class="comment">//     throw;  // Re-throws the original exception.</span>
<a name="l02113"></a>02113   <span class="comment">// }</span>
<a name="l02114"></a>02114   <span class="comment">//</span>
<a name="l02115"></a>02115   <span class="comment">// However, the purpose of this flag is to allow the program to drop into</span>
<a name="l02116"></a>02116   <span class="comment">// the debugger when the exception is thrown. On most platforms, once the</span>
<a name="l02117"></a>02117   <span class="comment">// control enters the catch block, the exception origin information is</span>
<a name="l02118"></a>02118   <span class="comment">// lost and the debugger will stop the program at the point of the</span>
<a name="l02119"></a>02119   <span class="comment">// re-throw in this function -- instead of at the point of the original</span>
<a name="l02120"></a>02120   <span class="comment">// throw statement in the code under test.  For this reason, we perform</span>
<a name="l02121"></a>02121   <span class="comment">// the check early, sacrificing the ability to affect Google Test&#39;s</span>
<a name="l02122"></a>02122   <span class="comment">// exception handling in the method where the exception is thrown.</span>
<a name="l02123"></a>02123   <span class="keywordflow">if</span> (<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3ae874a4030c4aa27d77d67bf08d9e1d">internal::GetUnitTestImpl</a>()-&gt;catch_exceptions()) {
<a name="l02124"></a>02124 <span class="preprocessor">#if GTEST_HAS_EXCEPTIONS</span>
<a name="l02125"></a>02125 <span class="preprocessor"></span>    <span class="keywordflow">try</span> {
<a name="l02126"></a>02126       <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac7b1ac01c4703111210df6badab74591">HandleSehExceptionsInMethodIfSupported</a>(<span class="keywordtype">object</span>, method, location);
<a name="l02127"></a>02127     } <span class="keywordflow">catch</span> (<span class="keyword">const</span> GoogleTestFailureException&amp;) {  <span class="comment">// NOLINT</span>
<a name="l02128"></a>02128       <span class="comment">// This exception doesn&#39;t originate in code under test. It makes no</span>
<a name="l02129"></a>02129       <span class="comment">// sense to report it as a test failure.</span>
<a name="l02130"></a>02130       <span class="keywordflow">throw</span>;
<a name="l02131"></a>02131     } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {  <span class="comment">// NOLINT</span>
<a name="l02132"></a>02132       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a544a5c0a7bc19f664d434be72ecbdbfa">internal::ReportFailureInUnknownLocation</a>(
<a name="l02133"></a>02133           TestPartResult::kFatalFailure,
<a name="l02134"></a>02134           FormatCxxExceptionMessage(e.what(), location));
<a name="l02135"></a>02135     } <span class="keywordflow">catch</span> (...) {  <span class="comment">// NOLINT</span>
<a name="l02136"></a>02136       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a544a5c0a7bc19f664d434be72ecbdbfa">internal::ReportFailureInUnknownLocation</a>(
<a name="l02137"></a>02137           TestPartResult::kFatalFailure,
<a name="l02138"></a>02138           FormatCxxExceptionMessage(NULL, location));
<a name="l02139"></a>02139     }
<a name="l02140"></a>02140     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Result<span class="keyword">&gt;</span>(0);
<a name="l02141"></a>02141 <span class="preprocessor">#else</span>
<a name="l02142"></a>02142 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac7b1ac01c4703111210df6badab74591">HandleSehExceptionsInMethodIfSupported</a>(<span class="keywordtype">object</span>, method, location);
<a name="l02143"></a>02143 <span class="preprocessor">#endif  // GTEST_HAS_EXCEPTIONS</span>
<a name="l02144"></a>02144 <span class="preprocessor"></span>  } <span class="keywordflow">else</span> {
<a name="l02145"></a>02145     <span class="keywordflow">return</span> (object-&gt;*method)();
<a name="l02146"></a>02146   }
<a name="l02147"></a>02147 }
<a name="l02148"></a>02148 
<a name="l02149"></a>02149 }  <span class="comment">// namespace internal</span>
<a name="l02150"></a>02150 
<a name="l02151"></a>02151 <span class="comment">// Runs the test and updates the test result.</span>
<a name="l02152"></a>02152 <span class="keywordtype">void</span> <a class="code" href="../../d2/dcc/namespacegtest__break__on__failure__unittest.html#ae784214748d2010e70d5519ce618af5f">Test::Run</a>() {
<a name="l02153"></a>02153   <span class="keywordflow">if</span> (!HasSameFixtureClass()) <span class="keywordflow">return</span>;
<a name="l02154"></a>02154 
<a name="l02155"></a>02155   internal::UnitTestImpl* <span class="keyword">const</span> impl = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3ae874a4030c4aa27d77d67bf08d9e1d">internal::GetUnitTestImpl</a>();
<a name="l02156"></a>02156   impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
<a name="l02157"></a>02157   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0034a1799f52bef77bb3b810af8b8969">internal::HandleExceptionsInMethodIfSupported</a>(<span class="keyword">this</span>, &amp;Test::SetUp, <span class="stringliteral">&quot;SetUp()&quot;</span>);
<a name="l02158"></a>02158   <span class="comment">// We will run the test only if SetUp() was successful.</span>
<a name="l02159"></a>02159   <span class="keywordflow">if</span> (!HasFatalFailure()) {
<a name="l02160"></a>02160     impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
<a name="l02161"></a>02161     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0034a1799f52bef77bb3b810af8b8969">internal::HandleExceptionsInMethodIfSupported</a>(
<a name="l02162"></a>02162         <span class="keyword">this</span>, &amp;Test::TestBody, <span class="stringliteral">&quot;the test body&quot;</span>);
<a name="l02163"></a>02163   }
<a name="l02164"></a>02164 
<a name="l02165"></a>02165   <span class="comment">// However, we want to clean up as much as possible.  Hence we will</span>
<a name="l02166"></a>02166   <span class="comment">// always call TearDown(), even if SetUp() or the test body has</span>
<a name="l02167"></a>02167   <span class="comment">// failed.</span>
<a name="l02168"></a>02168   impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
<a name="l02169"></a>02169   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0034a1799f52bef77bb3b810af8b8969">internal::HandleExceptionsInMethodIfSupported</a>(
<a name="l02170"></a>02170       <span class="keyword">this</span>, &amp;Test::TearDown, <span class="stringliteral">&quot;TearDown()&quot;</span>);
<a name="l02171"></a>02171 }
<a name="l02172"></a>02172 
<a name="l02173"></a>02173 <span class="comment">// Returns true iff the current test has a fatal failure.</span>
<a name="l02174"></a>02174 <span class="keywordtype">bool</span> Test::HasFatalFailure() {
<a name="l02175"></a>02175   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3ae874a4030c4aa27d77d67bf08d9e1d">internal::GetUnitTestImpl</a>()-&gt;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a385bee93ae6043262a860574aa59ba1a">current_test_result</a>()-&gt;<a class="code" href="../../d6/d6e/classtesting_1_1TestResult.html#a6635ff3817f8f3dccf41e3e3524b8b15">HasFatalFailure</a>();
<a name="l02176"></a>02176 }
<a name="l02177"></a>02177 
<a name="l02178"></a>02178 <span class="comment">// Returns true iff the current test has a non-fatal failure.</span>
<a name="l02179"></a>02179 <span class="keywordtype">bool</span> Test::HasNonfatalFailure() {
<a name="l02180"></a>02180   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3ae874a4030c4aa27d77d67bf08d9e1d">internal::GetUnitTestImpl</a>()-&gt;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a385bee93ae6043262a860574aa59ba1a">current_test_result</a>()-&gt;
<a name="l02181"></a>02181       HasNonfatalFailure();
<a name="l02182"></a>02182 }
<a name="l02183"></a>02183 
<a name="l02184"></a>02184 <span class="comment">// class TestInfo</span>
<a name="l02185"></a>02185 
<a name="l02186"></a>02186 <span class="comment">// Constructs a TestInfo object. It assumes ownership of the test factory</span>
<a name="l02187"></a>02187 <span class="comment">// object.</span>
<a name="l02188"></a>02188 <span class="comment">// TODO(vladl@google.com): Make a_test_case_name and a_name const string&amp;&#39;s</span>
<a name="l02189"></a>02189 <span class="comment">// to signify they cannot be NULLs.</span>
<a name="l02190"></a>02190 TestInfo::TestInfo(<span class="keyword">const</span> <span class="keywordtype">char</span>* a_test_case_name,
<a name="l02191"></a>02191                    <span class="keyword">const</span> <span class="keywordtype">char</span>* a_name,
<a name="l02192"></a>02192                    <span class="keyword">const</span> <span class="keywordtype">char</span>* a_type_param,
<a name="l02193"></a>02193                    <span class="keyword">const</span> <span class="keywordtype">char</span>* a_value_param,
<a name="l02194"></a>02194                    <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac8e91f0c6a06c0361dc3152ddfeb2342">internal::TypeId</a> fixture_class_id,
<a name="l02195"></a>02195                    internal::TestFactoryBase* factory)
<a name="l02196"></a>02196     : test_case_name_(a_test_case_name),
<a name="l02197"></a>02197       <a class="code" href="../../dc/dba/fused-src_2gtest_2gtest-all_8cc.html#a405ae26bae83121bb8a0991436141b78">name_</a>(a_name),
<a name="l02198"></a>02198       type_param_(a_type_param ? new std::<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9882e571372fc19a02d2b2949e1f1557">string</a>(a_type_param) : NULL),
<a name="l02199"></a>02199       value_param_(a_value_param ? new std::<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9882e571372fc19a02d2b2949e1f1557">string</a>(a_value_param) : NULL),
<a name="l02200"></a>02200       fixture_class_id_(fixture_class_id),
<a name="l02201"></a>02201       should_run_(false),
<a name="l02202"></a>02202       is_disabled_(false),
<a name="l02203"></a>02203       matches_filter_(false),
<a name="l02204"></a>02204       factory_(factory),
<a name="l02205"></a>02205       result_() {}
<a name="l02206"></a>02206 
<a name="l02207"></a>02207 <span class="comment">// Destructs a TestInfo object.</span>
<a name="l02208"></a>02208 TestInfo::~TestInfo() { <span class="keyword">delete</span> factory_; }
<a name="l02209"></a>02209 
<a name="l02210"></a>02210 <span class="keyword">namespace </span>internal {
<a name="l02211"></a>02211 
<a name="l02212"></a>02212 <span class="comment">// Creates a new TestInfo object and registers it with Google Test;</span>
<a name="l02213"></a>02213 <span class="comment">// returns the created object.</span>
<a name="l02214"></a>02214 <span class="comment">//</span>
<a name="l02215"></a>02215 <span class="comment">// Arguments:</span>
<a name="l02216"></a>02216 <span class="comment">//</span>
<a name="l02217"></a>02217 <span class="comment">//   test_case_name:   name of the test case</span>
<a name="l02218"></a>02218 <span class="comment">//   name:             name of the test</span>
<a name="l02219"></a>02219 <span class="comment">//   type_param:       the name of the test&#39;s type parameter, or NULL if</span>
<a name="l02220"></a>02220 <span class="comment">//                     this is not a typed or a type-parameterized test.</span>
<a name="l02221"></a>02221 <span class="comment">//   value_param:      text representation of the test&#39;s value parameter,</span>
<a name="l02222"></a>02222 <span class="comment">//                     or NULL if this is not a value-parameterized test.</span>
<a name="l02223"></a>02223 <span class="comment">//   fixture_class_id: ID of the test fixture class</span>
<a name="l02224"></a>02224 <span class="comment">//   set_up_tc:        pointer to the function that sets up the test case</span>
<a name="l02225"></a>02225 <span class="comment">//   tear_down_tc:     pointer to the function that tears down the test case</span>
<a name="l02226"></a>02226 <span class="comment">//   factory:          pointer to the factory that creates a test object.</span>
<a name="l02227"></a>02227 <span class="comment">//                     The newly created TestInfo instance will assume</span>
<a name="l02228"></a>02228 <span class="comment">//                     ownership of the factory object.</span>
<a name="l02229"></a>02229 TestInfo* <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a8f58f081cff056a35d18746667a16c4f">MakeAndRegisterTestInfo</a>(
<a name="l02230"></a>02230     <span class="keyword">const</span> <span class="keywordtype">char</span>* test_case_name, <span class="keyword">const</span> <span class="keywordtype">char</span>* name,
<a name="l02231"></a>02231     <span class="keyword">const</span> <span class="keywordtype">char</span>* type_param,
<a name="l02232"></a>02232     <span class="keyword">const</span> <span class="keywordtype">char</span>* value_param,
<a name="l02233"></a>02233     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac8e91f0c6a06c0361dc3152ddfeb2342">TypeId</a> fixture_class_id,
<a name="l02234"></a>02234     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#abdd2548fdbf05907e439e416dab030ec">SetUpTestCaseFunc</a> set_up_tc,
<a name="l02235"></a>02235     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0d7d11b7ce3a8f9d969e0dfb543dde3d">TearDownTestCaseFunc</a> tear_down_tc,
<a name="l02236"></a>02236     TestFactoryBase* factory) {
<a name="l02237"></a>02237   TestInfo* <span class="keyword">const</span> test_info =
<a name="l02238"></a>02238       <span class="keyword">new</span> TestInfo(test_case_name, name, type_param, value_param,
<a name="l02239"></a>02239                    fixture_class_id, factory);
<a name="l02240"></a>02240   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3ae874a4030c4aa27d77d67bf08d9e1d">GetUnitTestImpl</a>()-&gt;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a0f73735489a968e6f6d57f791a246615">AddTestInfo</a>(set_up_tc, tear_down_tc, test_info);
<a name="l02241"></a>02241   <span class="keywordflow">return</span> test_info;
<a name="l02242"></a>02242 }
<a name="l02243"></a>02243 
<a name="l02244"></a>02244 <span class="preprocessor">#if GTEST_HAS_PARAM_TEST</span>
<a name="l02245"></a>02245 <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a864171ad4983f5b8e4258d0d5db0c03b">ReportInvalidTestCaseType</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* test_case_name,
<a name="l02246"></a>02246                                <span class="keyword">const</span> <span class="keywordtype">char</span>* file, <span class="keywordtype">int</span> line) {
<a name="l02247"></a>02247   Message errors;
<a name="l02248"></a>02248   errors
<a name="l02249"></a>02249       &lt;&lt; <span class="stringliteral">&quot;Attempted redefinition of test case &quot;</span> &lt;&lt; test_case_name &lt;&lt; <span class="stringliteral">&quot;.\n&quot;</span>
<a name="l02250"></a>02250       &lt;&lt; <span class="stringliteral">&quot;All tests in the same test case must use the same test fixture\n&quot;</span>
<a name="l02251"></a>02251       &lt;&lt; <span class="stringliteral">&quot;class.  However, in test case &quot;</span> &lt;&lt; test_case_name &lt;&lt; <span class="stringliteral">&quot;, you tried\n&quot;</span>
<a name="l02252"></a>02252       &lt;&lt; <span class="stringliteral">&quot;to define a test using a fixture class different from the one\n&quot;</span>
<a name="l02253"></a>02253       &lt;&lt; <span class="stringliteral">&quot;used earlier. This can happen if the two fixture classes are\n&quot;</span>
<a name="l02254"></a>02254       &lt;&lt; <span class="stringliteral">&quot;from different namespaces and have the same name. You should\n&quot;</span>
<a name="l02255"></a>02255       &lt;&lt; <span class="stringliteral">&quot;probably rename one of the classes to put the tests into different\n&quot;</span>
<a name="l02256"></a>02256       &lt;&lt; <span class="stringliteral">&quot;test cases.&quot;</span>;
<a name="l02257"></a>02257 
<a name="l02258"></a>02258   fprintf(stderr, <span class="stringliteral">&quot;%s %s&quot;</span>, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a6264f0605b7d7d0609eae663c58662c0">FormatFileLocation</a>(file, line).c_str(),
<a name="l02259"></a>02259           errors.GetString().c_str());
<a name="l02260"></a>02260 }
<a name="l02261"></a>02261 <span class="preprocessor">#endif  // GTEST_HAS_PARAM_TEST</span>
<a name="l02262"></a>02262 <span class="preprocessor"></span>
<a name="l02263"></a>02263 }  <span class="comment">// namespace internal</span>
<a name="l02264"></a>02264 
<a name="l02265"></a>02265 <span class="keyword">namespace </span>{
<a name="l02266"></a>02266 
<a name="l02267"></a>02267 <span class="comment">// A predicate that checks the test name of a TestInfo against a known</span>
<a name="l02268"></a>02268 <span class="comment">// value.</span>
<a name="l02269"></a>02269 <span class="comment">//</span>
<a name="l02270"></a>02270 <span class="comment">// This is used for implementation of the TestCase class only.  We put</span>
<a name="l02271"></a>02271 <span class="comment">// it in the anonymous namespace to prevent polluting the outer</span>
<a name="l02272"></a>02272 <span class="comment">// namespace.</span>
<a name="l02273"></a>02273 <span class="comment">//</span>
<a name="l02274"></a>02274 <span class="comment">// TestNameIs is copyable.</span>
<a name="l02275"></a>02275 <span class="keyword">class </span>TestNameIs {
<a name="l02276"></a>02276  <span class="keyword">public</span>:
<a name="l02277"></a>02277   <span class="comment">// Constructor.</span>
<a name="l02278"></a>02278   <span class="comment">//</span>
<a name="l02279"></a>02279   <span class="comment">// TestNameIs has NO default constructor.</span>
<a name="l02280"></a>02280   <span class="keyword">explicit</span> TestNameIs(<span class="keyword">const</span> <span class="keywordtype">char</span>* name)
<a name="l02281"></a>02281       : <a class="code" href="../../dc/dba/fused-src_2gtest_2gtest-all_8cc.html#a405ae26bae83121bb8a0991436141b78">name_</a>(name) {}
<a name="l02282"></a>02282 
<a name="l02283"></a>02283   <span class="comment">// Returns true iff the test name of test_info matches name_.</span>
<a name="l02284"></a>02284   <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> TestInfo * test_info)<span class="keyword"> const </span>{
<a name="l02285"></a>02285     <span class="keywordflow">return</span> test_info &amp;&amp; internal::String(test_info-&gt;name()).Compare(<a class="code" href="../../dc/dba/fused-src_2gtest_2gtest-all_8cc.html#a405ae26bae83121bb8a0991436141b78">name_</a>) == 0;
<a name="l02286"></a>02286   }
<a name="l02287"></a>02287 
<a name="l02288"></a>02288  <span class="keyword">private</span>:
<a name="l02289"></a><a class="code" href="../../df/d5b/gtest_8cc.html#a405ae26bae83121bb8a0991436141b78">02289</a>   internal::String <a class="code" href="../../dc/dba/fused-src_2gtest_2gtest-all_8cc.html#a405ae26bae83121bb8a0991436141b78">name_</a>;
<a name="l02290"></a>02290 };
<a name="l02291"></a>02291 
<a name="l02292"></a>02292 }  <span class="comment">// namespace</span>
<a name="l02293"></a>02293 
<a name="l02294"></a>02294 <span class="keyword">namespace </span>internal {
<a name="l02295"></a>02295 
<a name="l02296"></a>02296 <span class="comment">// This method expands all parameterized tests registered with macros TEST_P</span>
<a name="l02297"></a>02297 <span class="comment">// and INSTANTIATE_TEST_CASE_P into regular tests and registers those.</span>
<a name="l02298"></a>02298 <span class="comment">// This will be done just once during the program runtime.</span>
<a name="l02299"></a>02299 <span class="keywordtype">void</span> UnitTestImpl::RegisterParameterizedTests() {
<a name="l02300"></a>02300 <span class="preprocessor">#if GTEST_HAS_PARAM_TEST</span>
<a name="l02301"></a>02301 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!parameterized_tests_registered_) {
<a name="l02302"></a>02302     parameterized_test_registry_.RegisterTests();
<a name="l02303"></a>02303     parameterized_tests_registered_ = <span class="keyword">true</span>;
<a name="l02304"></a>02304   }
<a name="l02305"></a>02305 <span class="preprocessor">#endif</span>
<a name="l02306"></a>02306 <span class="preprocessor"></span>}
<a name="l02307"></a>02307 
<a name="l02308"></a>02308 }  <span class="comment">// namespace internal</span>
<a name="l02309"></a>02309 
<a name="l02310"></a>02310 <span class="comment">// Creates the test object, runs it, records its result, and then</span>
<a name="l02311"></a>02311 <span class="comment">// deletes it.</span>
<a name="l02312"></a>02312 <span class="keywordtype">void</span> <a class="code" href="../../d2/dcc/namespacegtest__break__on__failure__unittest.html#ae784214748d2010e70d5519ce618af5f">TestInfo::Run</a>() {
<a name="l02313"></a>02313   <span class="keywordflow">if</span> (!should_run_) <span class="keywordflow">return</span>;
<a name="l02314"></a>02314 
<a name="l02315"></a>02315   <span class="comment">// Tells UnitTest where to store test result.</span>
<a name="l02316"></a>02316   internal::UnitTestImpl* <span class="keyword">const</span> impl = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3ae874a4030c4aa27d77d67bf08d9e1d">internal::GetUnitTestImpl</a>();
<a name="l02317"></a>02317   impl-&gt;set_current_test_info(<span class="keyword">this</span>);
<a name="l02318"></a>02318 
<a name="l02319"></a>02319   TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();
<a name="l02320"></a>02320 
<a name="l02321"></a>02321   <span class="comment">// Notifies the unit test event listeners that a test is about to start.</span>
<a name="l02322"></a>02322   repeater-&gt;OnTestStart(*<span class="keyword">this</span>);
<a name="l02323"></a>02323 
<a name="l02324"></a>02324   <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9e0fb32f592d143f031a3431366adae0">TimeInMillis</a> start = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae0c6fd4543c65945515c42d6f43cc138">internal::GetTimeInMillis</a>();
<a name="l02325"></a>02325 
<a name="l02326"></a>02326   impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
<a name="l02327"></a>02327 
<a name="l02328"></a>02328   <span class="comment">// Creates the test object.</span>
<a name="l02329"></a>02329   Test* <span class="keyword">const</span> test = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0034a1799f52bef77bb3b810af8b8969">internal::HandleExceptionsInMethodIfSupported</a>(
<a name="l02330"></a>02330       factory_, &amp;internal::TestFactoryBase::CreateTest,
<a name="l02331"></a>02331       <span class="stringliteral">&quot;the test fixture&#39;s constructor&quot;</span>);
<a name="l02332"></a>02332 
<a name="l02333"></a>02333   <span class="comment">// Runs the test only if the test object was created and its</span>
<a name="l02334"></a>02334   <span class="comment">// constructor didn&#39;t generate a fatal failure.</span>
<a name="l02335"></a>02335   <span class="keywordflow">if</span> ((test != NULL) &amp;&amp; !Test::HasFatalFailure()) {
<a name="l02336"></a>02336     <span class="comment">// This doesn&#39;t throw as all user code that can throw are wrapped into</span>
<a name="l02337"></a>02337     <span class="comment">// exception handling code.</span>
<a name="l02338"></a>02338     test-&gt;Run();
<a name="l02339"></a>02339   }
<a name="l02340"></a>02340 
<a name="l02341"></a>02341   <span class="comment">// Deletes the test object.</span>
<a name="l02342"></a>02342   impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
<a name="l02343"></a>02343   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0034a1799f52bef77bb3b810af8b8969">internal::HandleExceptionsInMethodIfSupported</a>(
<a name="l02344"></a>02344       test, &amp;Test::DeleteSelf_, <span class="stringliteral">&quot;the test fixture&#39;s destructor&quot;</span>);
<a name="l02345"></a>02345 
<a name="l02346"></a>02346   result_.set_elapsed_time(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae0c6fd4543c65945515c42d6f43cc138">internal::GetTimeInMillis</a>() - start);
<a name="l02347"></a>02347 
<a name="l02348"></a>02348   <span class="comment">// Notifies the unit test event listener that a test has just finished.</span>
<a name="l02349"></a>02349   repeater-&gt;OnTestEnd(*<span class="keyword">this</span>);
<a name="l02350"></a>02350 
<a name="l02351"></a>02351   <span class="comment">// Tells UnitTest to stop associating assertion results to this</span>
<a name="l02352"></a>02352   <span class="comment">// test.</span>
<a name="l02353"></a>02353   impl-&gt;set_current_test_info(NULL);
<a name="l02354"></a>02354 }
<a name="l02355"></a>02355 
<a name="l02356"></a>02356 <span class="comment">// class TestCase</span>
<a name="l02357"></a>02357 
<a name="l02358"></a>02358 <span class="comment">// Gets the number of successful tests in this test case.</span>
<a name="l02359"></a>02359 <span class="keywordtype">int</span> TestCase::successful_test_count()<span class="keyword"> const </span>{
<a name="l02360"></a>02360   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab37ae76c997078f65ba28f35b3657151">CountIf</a>(test_info_list_, TestPassed);
<a name="l02361"></a>02361 }
<a name="l02362"></a>02362 
<a name="l02363"></a>02363 <span class="comment">// Gets the number of failed tests in this test case.</span>
<a name="l02364"></a>02364 <span class="keywordtype">int</span> TestCase::failed_test_count()<span class="keyword"> const </span>{
<a name="l02365"></a>02365   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab37ae76c997078f65ba28f35b3657151">CountIf</a>(test_info_list_, TestFailed);
<a name="l02366"></a>02366 }
<a name="l02367"></a>02367 
<a name="l02368"></a>02368 <span class="keywordtype">int</span> TestCase::disabled_test_count()<span class="keyword"> const </span>{
<a name="l02369"></a>02369   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab37ae76c997078f65ba28f35b3657151">CountIf</a>(test_info_list_, TestDisabled);
<a name="l02370"></a>02370 }
<a name="l02371"></a>02371 
<a name="l02372"></a>02372 <span class="comment">// Get the number of tests in this test case that should run.</span>
<a name="l02373"></a>02373 <span class="keywordtype">int</span> TestCase::test_to_run_count()<span class="keyword"> const </span>{
<a name="l02374"></a>02374   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab37ae76c997078f65ba28f35b3657151">CountIf</a>(test_info_list_, ShouldRunTest);
<a name="l02375"></a>02375 }
<a name="l02376"></a>02376 
<a name="l02377"></a>02377 <span class="comment">// Gets the number of all tests.</span>
<a name="l02378"></a>02378 <span class="keywordtype">int</span> TestCase::total_test_count()<span class="keyword"> const </span>{
<a name="l02379"></a>02379   <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(test_info_list_.size());
<a name="l02380"></a>02380 }
<a name="l02381"></a>02381 
<a name="l02382"></a>02382 <span class="comment">// Creates a TestCase with the given name.</span>
<a name="l02383"></a>02383 <span class="comment">//</span>
<a name="l02384"></a>02384 <span class="comment">// Arguments:</span>
<a name="l02385"></a>02385 <span class="comment">//</span>
<a name="l02386"></a>02386 <span class="comment">//   name:         name of the test case</span>
<a name="l02387"></a>02387 <span class="comment">//   a_type_param: the name of the test case&#39;s type parameter, or NULL if</span>
<a name="l02388"></a>02388 <span class="comment">//                 this is not a typed or a type-parameterized test case.</span>
<a name="l02389"></a>02389 <span class="comment">//   set_up_tc:    pointer to the function that sets up the test case</span>
<a name="l02390"></a>02390 <span class="comment">//   tear_down_tc: pointer to the function that tears down the test case</span>
<a name="l02391"></a>02391 <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase::TestCase</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* a_name, <span class="keyword">const</span> <span class="keywordtype">char</span>* a_type_param,
<a name="l02392"></a>02392                    <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#abdd2548fdbf05907e439e416dab030ec">Test::SetUpTestCaseFunc</a> set_up_tc,
<a name="l02393"></a>02393                    <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0d7d11b7ce3a8f9d969e0dfb543dde3d">Test::TearDownTestCaseFunc</a> tear_down_tc)
<a name="l02394"></a>02394     : <a class="code" href="../../dc/dba/fused-src_2gtest_2gtest-all_8cc.html#a405ae26bae83121bb8a0991436141b78">name_</a>(a_name),
<a name="l02395"></a>02395       type_param_(a_type_param ? new std::<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9882e571372fc19a02d2b2949e1f1557">string</a>(a_type_param) : NULL),
<a name="l02396"></a>02396       set_up_tc_(set_up_tc),
<a name="l02397"></a>02397       tear_down_tc_(tear_down_tc),
<a name="l02398"></a>02398       should_run_(false),
<a name="l02399"></a>02399       elapsed_time_(0) {
<a name="l02400"></a>02400 }
<a name="l02401"></a>02401 
<a name="l02402"></a>02402 <span class="comment">// Destructor of TestCase.</span>
<a name="l02403"></a>02403 TestCase::~TestCase() {
<a name="l02404"></a>02404   <span class="comment">// Deletes every Test in the collection.</span>
<a name="l02405"></a>02405   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af699259a2b1e5e06250ed075b735b1f6">ForEach</a>(test_info_list_, internal::Delete&lt;TestInfo&gt;);
<a name="l02406"></a>02406 }
<a name="l02407"></a>02407 
<a name="l02408"></a>02408 <span class="comment">// Returns the i-th test among all the tests. i can range from 0 to</span>
<a name="l02409"></a>02409 <span class="comment">// total_test_count() - 1. If i is not in that range, returns NULL.</span>
<a name="l02410"></a>02410 <span class="keyword">const</span> TestInfo* TestCase::GetTestInfo(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{
<a name="l02411"></a>02411   <span class="keyword">const</span> <span class="keywordtype">int</span> index = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a06b7c21a279eef9fbf0b8810af41e6b5">GetElementOr</a>(test_indices_, i, -1);
<a name="l02412"></a>02412   <span class="keywordflow">return</span> index &lt; 0 ? NULL : test_info_list_[index];
<a name="l02413"></a>02413 }
<a name="l02414"></a>02414 
<a name="l02415"></a>02415 <span class="comment">// Returns the i-th test among all the tests. i can range from 0 to</span>
<a name="l02416"></a>02416 <span class="comment">// total_test_count() - 1. If i is not in that range, returns NULL.</span>
<a name="l02417"></a>02417 TestInfo* TestCase::GetMutableTestInfo(<span class="keywordtype">int</span> i) {
<a name="l02418"></a>02418   <span class="keyword">const</span> <span class="keywordtype">int</span> index = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a06b7c21a279eef9fbf0b8810af41e6b5">GetElementOr</a>(test_indices_, i, -1);
<a name="l02419"></a>02419   <span class="keywordflow">return</span> index &lt; 0 ? NULL : test_info_list_[index];
<a name="l02420"></a>02420 }
<a name="l02421"></a>02421 
<a name="l02422"></a>02422 <span class="comment">// Adds a test to this test case.  Will delete the test upon</span>
<a name="l02423"></a>02423 <span class="comment">// destruction of the TestCase object.</span>
<a name="l02424"></a>02424 <span class="keywordtype">void</span> TestCase::AddTestInfo(TestInfo * test_info) {
<a name="l02425"></a>02425   test_info_list_.push_back(test_info);
<a name="l02426"></a>02426   test_indices_.push_back(static_cast&lt;int&gt;(test_indices_.size()));
<a name="l02427"></a>02427 }
<a name="l02428"></a>02428 
<a name="l02429"></a>02429 <span class="comment">// Runs every test in this TestCase.</span>
<a name="l02430"></a>02430 <span class="keywordtype">void</span> <a class="code" href="../../d2/dcc/namespacegtest__break__on__failure__unittest.html#ae784214748d2010e70d5519ce618af5f">TestCase::Run</a>() {
<a name="l02431"></a>02431   <span class="keywordflow">if</span> (!should_run_) <span class="keywordflow">return</span>;
<a name="l02432"></a>02432 
<a name="l02433"></a>02433   internal::UnitTestImpl* <span class="keyword">const</span> impl = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3ae874a4030c4aa27d77d67bf08d9e1d">internal::GetUnitTestImpl</a>();
<a name="l02434"></a>02434   impl-&gt;set_current_test_case(<span class="keyword">this</span>);
<a name="l02435"></a>02435 
<a name="l02436"></a>02436   TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();
<a name="l02437"></a>02437 
<a name="l02438"></a>02438   repeater-&gt;OnTestCaseStart(*<span class="keyword">this</span>);
<a name="l02439"></a>02439   impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
<a name="l02440"></a>02440   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0034a1799f52bef77bb3b810af8b8969">internal::HandleExceptionsInMethodIfSupported</a>(
<a name="l02441"></a>02441       <span class="keyword">this</span>, &amp;TestCase::RunSetUpTestCase, <span class="stringliteral">&quot;SetUpTestCase()&quot;</span>);
<a name="l02442"></a>02442 
<a name="l02443"></a>02443   <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9e0fb32f592d143f031a3431366adae0">internal::TimeInMillis</a> start = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae0c6fd4543c65945515c42d6f43cc138">internal::GetTimeInMillis</a>();
<a name="l02444"></a>02444   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; total_test_count(); i++) {
<a name="l02445"></a>02445     GetMutableTestInfo(i)-&gt;Run();
<a name="l02446"></a>02446   }
<a name="l02447"></a>02447   elapsed_time_ = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae0c6fd4543c65945515c42d6f43cc138">internal::GetTimeInMillis</a>() - start;
<a name="l02448"></a>02448 
<a name="l02449"></a>02449   impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
<a name="l02450"></a>02450   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0034a1799f52bef77bb3b810af8b8969">internal::HandleExceptionsInMethodIfSupported</a>(
<a name="l02451"></a>02451       <span class="keyword">this</span>, &amp;TestCase::RunTearDownTestCase, <span class="stringliteral">&quot;TearDownTestCase()&quot;</span>);
<a name="l02452"></a>02452 
<a name="l02453"></a>02453   repeater-&gt;OnTestCaseEnd(*<span class="keyword">this</span>);
<a name="l02454"></a>02454   impl-&gt;set_current_test_case(NULL);
<a name="l02455"></a>02455 }
<a name="l02456"></a>02456 
<a name="l02457"></a>02457 <span class="comment">// Clears the results of all tests in this test case.</span>
<a name="l02458"></a>02458 <span class="keywordtype">void</span> TestCase::ClearResult() {
<a name="l02459"></a>02459   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af699259a2b1e5e06250ed075b735b1f6">ForEach</a>(test_info_list_, TestInfo::ClearTestResult);
<a name="l02460"></a>02460 }
<a name="l02461"></a>02461 
<a name="l02462"></a>02462 <span class="comment">// Shuffles the tests in this test case.</span>
<a name="l02463"></a>02463 <span class="keywordtype">void</span> TestCase::ShuffleTests(internal::Random* random) {
<a name="l02464"></a>02464   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a955e3f72f36c9db3a1165517010f52a3">Shuffle</a>(random, &amp;test_indices_);
<a name="l02465"></a>02465 }
<a name="l02466"></a>02466 
<a name="l02467"></a>02467 <span class="comment">// Restores the test order to before the first shuffle.</span>
<a name="l02468"></a>02468 <span class="keywordtype">void</span> TestCase::UnshuffleTests() {
<a name="l02469"></a>02469   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; test_indices_.size(); i++) {
<a name="l02470"></a>02470     test_indices_[i] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(i);
<a name="l02471"></a>02471   }
<a name="l02472"></a>02472 }
<a name="l02473"></a>02473 
<a name="l02474"></a>02474 <span class="comment">// Formats a countable noun.  Depending on its quantity, either the</span>
<a name="l02475"></a>02475 <span class="comment">// singular form or the plural form is used. e.g.</span>
<a name="l02476"></a>02476 <span class="comment">//</span>
<a name="l02477"></a>02477 <span class="comment">// FormatCountableNoun(1, &quot;formula&quot;, &quot;formuli&quot;) returns &quot;1 formula&quot;.</span>
<a name="l02478"></a>02478 <span class="comment">// FormatCountableNoun(5, &quot;book&quot;, &quot;books&quot;) returns &quot;5 books&quot;.</span>
<a name="l02479"></a>02479 <span class="keyword">static</span> internal::String <a class="code" href="../../d0/d75/namespacetesting.html#aefca65bdfcf981c1e55c7d90e14a263f">FormatCountableNoun</a>(<span class="keywordtype">int</span> count,
<a name="l02480"></a>02480                                             <span class="keyword">const</span> <span class="keywordtype">char</span> * singular_form,
<a name="l02481"></a>02481                                             <span class="keyword">const</span> <span class="keywordtype">char</span> * plural_form) {
<a name="l02482"></a>02482   <span class="keywordflow">return</span> internal::String::Format(<span class="stringliteral">&quot;%d %s&quot;</span>, count,
<a name="l02483"></a>02483                                   count == 1 ? singular_form : plural_form);
<a name="l02484"></a>02484 }
<a name="l02485"></a>02485 
<a name="l02486"></a>02486 <span class="comment">// Formats the count of tests.</span>
<a name="l02487"></a>02487 <span class="keyword">static</span> internal::String <a class="code" href="../../d0/d75/namespacetesting.html#a9e35e748b0be521a7c14047d3cab12b2">FormatTestCount</a>(<span class="keywordtype">int</span> test_count) {
<a name="l02488"></a>02488   <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#aefca65bdfcf981c1e55c7d90e14a263f">FormatCountableNoun</a>(test_count, <span class="stringliteral">&quot;test&quot;</span>, <span class="stringliteral">&quot;tests&quot;</span>);
<a name="l02489"></a>02489 }
<a name="l02490"></a>02490 
<a name="l02491"></a>02491 <span class="comment">// Formats the count of test cases.</span>
<a name="l02492"></a>02492 <span class="keyword">static</span> internal::String <a class="code" href="../../d0/d75/namespacetesting.html#a62a889fb8f600d386c9c75951b0a45b7">FormatTestCaseCount</a>(<span class="keywordtype">int</span> test_case_count) {
<a name="l02493"></a>02493   <span class="keywordflow">return</span> <a class="code" href="../../d0/d75/namespacetesting.html#aefca65bdfcf981c1e55c7d90e14a263f">FormatCountableNoun</a>(test_case_count, <span class="stringliteral">&quot;test case&quot;</span>, <span class="stringliteral">&quot;test cases&quot;</span>);
<a name="l02494"></a>02494 }
<a name="l02495"></a>02495 
<a name="l02496"></a>02496 <span class="comment">// Converts a TestPartResult::Type enum to human-friendly string</span>
<a name="l02497"></a>02497 <span class="comment">// representation.  Both kNonFatalFailure and kFatalFailure are translated</span>
<a name="l02498"></a>02498 <span class="comment">// to &quot;Failure&quot;, as the user usually doesn&#39;t care about the difference</span>
<a name="l02499"></a>02499 <span class="comment">// between the two when viewing the test result.</span>
<a name="l02500"></a>02500 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="../../d0/d75/namespacetesting.html#a3095c11c161dad676777579f3619d016">TestPartResultTypeToString</a>(TestPartResult::Type type) {
<a name="l02501"></a>02501   <span class="keywordflow">switch</span> (type) {
<a name="l02502"></a>02502     <span class="keywordflow">case</span> TestPartResult::kSuccess:
<a name="l02503"></a>02503       <span class="keywordflow">return</span> <span class="stringliteral">&quot;Success&quot;</span>;
<a name="l02504"></a>02504 
<a name="l02505"></a>02505     <span class="keywordflow">case</span> TestPartResult::kNonFatalFailure:
<a name="l02506"></a>02506     <span class="keywordflow">case</span> TestPartResult::kFatalFailure:
<a name="l02507"></a>02507 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l02508"></a>02508 <span class="preprocessor"></span>      <span class="keywordflow">return</span> <span class="stringliteral">&quot;error: &quot;</span>;
<a name="l02509"></a>02509 <span class="preprocessor">#else</span>
<a name="l02510"></a>02510 <span class="preprocessor"></span>      <span class="keywordflow">return</span> <span class="stringliteral">&quot;Failure\n&quot;</span>;
<a name="l02511"></a>02511 <span class="preprocessor">#endif</span>
<a name="l02512"></a>02512 <span class="preprocessor"></span>    <span class="keywordflow">default</span>:
<a name="l02513"></a>02513       <span class="keywordflow">return</span> <span class="stringliteral">&quot;Unknown result type&quot;</span>;
<a name="l02514"></a>02514   }
<a name="l02515"></a>02515 }
<a name="l02516"></a>02516 
<a name="l02517"></a>02517 <span class="comment">// Prints a TestPartResult to a String.</span>
<a name="l02518"></a>02518 <span class="keyword">static</span> internal::String <a class="code" href="../../d0/d75/namespacetesting.html#aa72a7aad5f2a9ccde41699f09348160a">PrintTestPartResultToString</a>(
<a name="l02519"></a>02519     <span class="keyword">const</span> TestPartResult&amp; test_part_result) {
<a name="l02520"></a>02520   <span class="keywordflow">return</span> (Message()
<a name="l02521"></a>02521           &lt;&lt; <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a6264f0605b7d7d0609eae663c58662c0">internal::FormatFileLocation</a>(test_part_result.file_name(),
<a name="l02522"></a>02522                                           test_part_result.line_number())
<a name="l02523"></a>02523           &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="../../d0/d75/namespacetesting.html#a3095c11c161dad676777579f3619d016">TestPartResultTypeToString</a>(test_part_result.type())
<a name="l02524"></a>02524           &lt;&lt; test_part_result.message()).GetString();
<a name="l02525"></a>02525 }
<a name="l02526"></a>02526 
<a name="l02527"></a>02527 <span class="comment">// Prints a TestPartResult.</span>
<a name="l02528"></a>02528 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="../../d0/d75/namespacetesting.html#af2baf2fe4307d85e2124466614b0108a">PrintTestPartResult</a>(<span class="keyword">const</span> TestPartResult&amp; test_part_result) {
<a name="l02529"></a>02529   <span class="keyword">const</span> internal::String&amp; result =
<a name="l02530"></a>02530       <a class="code" href="../../d0/d75/namespacetesting.html#aa72a7aad5f2a9ccde41699f09348160a">PrintTestPartResultToString</a>(test_part_result);
<a name="l02531"></a>02531   printf(<span class="stringliteral">&quot;%s\n&quot;</span>, result.c_str());
<a name="l02532"></a>02532   fflush(stdout);
<a name="l02533"></a>02533   <span class="comment">// If the test program runs in Visual Studio or a debugger, the</span>
<a name="l02534"></a>02534   <span class="comment">// following statements add the test part result message to the Output</span>
<a name="l02535"></a>02535   <span class="comment">// window such that the user can double-click on it to jump to the</span>
<a name="l02536"></a>02536   <span class="comment">// corresponding source code location; otherwise they do nothing.</span>
<a name="l02537"></a>02537 <span class="preprocessor">#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l02538"></a>02538 <span class="preprocessor"></span>  <span class="comment">// We don&#39;t call OutputDebugString*() on Windows Mobile, as printing</span>
<a name="l02539"></a>02539   <span class="comment">// to stdout is done by OutputDebugString() there already - we don&#39;t</span>
<a name="l02540"></a>02540   <span class="comment">// want the same message printed twice.</span>
<a name="l02541"></a>02541   ::OutputDebugStringA(result.c_str());
<a name="l02542"></a>02542   ::OutputDebugStringA(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02543"></a>02543 <span class="preprocessor">#endif</span>
<a name="l02544"></a>02544 <span class="preprocessor"></span>}
<a name="l02545"></a>02545 
<a name="l02546"></a>02546 <span class="comment">// class PrettyUnitTestResultPrinter</span>
<a name="l02547"></a>02547 
<a name="l02548"></a>02548 <span class="keyword">namespace </span>internal {
<a name="l02549"></a>02549 
<a name="l02550"></a><a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965">02550</a> <span class="keyword">enum</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965">GTestColor</a> {
<a name="l02551"></a>02551   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965aaeda96851415e6bb57229cf139545439">COLOR_DEFAULT</a>,
<a name="l02552"></a>02552   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a55978b2a4d309f4f009fd1baa7808358">COLOR_RED</a>,
<a name="l02553"></a>02553   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>,
<a name="l02554"></a>02554   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a220df2a47a11552fb8631253ef7c3f10">COLOR_YELLOW</a>
<a name="l02555"></a>02555 };
<a name="l02556"></a>02556 
<a name="l02557"></a>02557 <span class="preprocessor">#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l02558"></a>02558 <span class="preprocessor"></span>
<a name="l02559"></a>02559 <span class="comment">// Returns the character attribute for the given color.</span>
<a name="l02560"></a>02560 WORD GetColorAttribute(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965">GTestColor</a> color) {
<a name="l02561"></a>02561   <span class="keywordflow">switch</span> (color) {
<a name="l02562"></a>02562     <span class="keywordflow">case</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a55978b2a4d309f4f009fd1baa7808358">COLOR_RED</a>:    <span class="keywordflow">return</span> FOREGROUND_RED;
<a name="l02563"></a>02563     <span class="keywordflow">case</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>:  <span class="keywordflow">return</span> FOREGROUND_GREEN;
<a name="l02564"></a>02564     <span class="keywordflow">case</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a220df2a47a11552fb8631253ef7c3f10">COLOR_YELLOW</a>: <span class="keywordflow">return</span> FOREGROUND_RED | FOREGROUND_GREEN;
<a name="l02565"></a>02565     <span class="keywordflow">default</span>:           <span class="keywordflow">return</span> 0;
<a name="l02566"></a>02566   }
<a name="l02567"></a>02567 }
<a name="l02568"></a>02568 
<a name="l02569"></a>02569 <span class="preprocessor">#else</span>
<a name="l02570"></a>02570 <span class="preprocessor"></span>
<a name="l02571"></a>02571 <span class="comment">// Returns the ANSI color code for the given color.  COLOR_DEFAULT is</span>
<a name="l02572"></a>02572 <span class="comment">// an invalid input.</span>
<a name="l02573"></a>02573 <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a381864cc8cad6df85e53dcee3b0cea92">GetAnsiColorCode</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965">GTestColor</a> color) {
<a name="l02574"></a>02574   <span class="keywordflow">switch</span> (color) {
<a name="l02575"></a>02575     <span class="keywordflow">case</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a55978b2a4d309f4f009fd1baa7808358">COLOR_RED</a>:     <span class="keywordflow">return</span> <span class="stringliteral">&quot;1&quot;</span>;
<a name="l02576"></a>02576     <span class="keywordflow">case</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>:   <span class="keywordflow">return</span> <span class="stringliteral">&quot;2&quot;</span>;
<a name="l02577"></a>02577     <span class="keywordflow">case</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a220df2a47a11552fb8631253ef7c3f10">COLOR_YELLOW</a>:  <span class="keywordflow">return</span> <span class="stringliteral">&quot;3&quot;</span>;
<a name="l02578"></a>02578     <span class="keywordflow">default</span>:            <span class="keywordflow">return</span> NULL;
<a name="l02579"></a>02579   };
<a name="l02580"></a>02580 }
<a name="l02581"></a>02581 
<a name="l02582"></a>02582 <span class="preprocessor">#endif  // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l02583"></a>02583 <span class="preprocessor"></span>
<a name="l02584"></a>02584 <span class="comment">// Returns true iff Google Test should use colors in the output.</span>
<a name="l02585"></a>02585 <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab0f928e61ab8ec92e75ddfcae9324c1e">ShouldUseColor</a>(<span class="keywordtype">bool</span> stdout_is_tty) {
<a name="l02586"></a>02586   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> gtest_color = <a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(color).c_str();
<a name="l02587"></a>02587 
<a name="l02588"></a>02588   <span class="keywordflow">if</span> (String::CaseInsensitiveCStringEquals(gtest_color, <span class="stringliteral">&quot;auto&quot;</span>)) {
<a name="l02589"></a>02589 <span class="preprocessor">#if GTEST_OS_WINDOWS</span>
<a name="l02590"></a>02590 <span class="preprocessor"></span>    <span class="comment">// On Windows the TERM variable is usually not set, but the</span>
<a name="l02591"></a>02591     <span class="comment">// console there does support colors.</span>
<a name="l02592"></a>02592     <span class="keywordflow">return</span> stdout_is_tty;
<a name="l02593"></a>02593 <span class="preprocessor">#else</span>
<a name="l02594"></a>02594 <span class="preprocessor"></span>    <span class="comment">// On non-Windows platforms, we rely on the TERM variable.</span>
<a name="l02595"></a>02595     <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> term = <a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#a7ed11bcd211f76641b16e60b5f0594eb">posix::GetEnv</a>(<span class="stringliteral">&quot;TERM&quot;</span>);
<a name="l02596"></a>02596     <span class="keyword">const</span> <span class="keywordtype">bool</span> term_supports_color =
<a name="l02597"></a>02597         String::CStringEquals(term, <span class="stringliteral">&quot;xterm&quot;</span>) ||
<a name="l02598"></a>02598         String::CStringEquals(term, <span class="stringliteral">&quot;xterm-color&quot;</span>) ||
<a name="l02599"></a>02599         String::CStringEquals(term, <span class="stringliteral">&quot;xterm-256color&quot;</span>) ||
<a name="l02600"></a>02600         String::CStringEquals(term, <span class="stringliteral">&quot;screen&quot;</span>) ||
<a name="l02601"></a>02601         String::CStringEquals(term, <span class="stringliteral">&quot;linux&quot;</span>) ||
<a name="l02602"></a>02602         String::CStringEquals(term, <span class="stringliteral">&quot;cygwin&quot;</span>);
<a name="l02603"></a>02603     <span class="keywordflow">return</span> stdout_is_tty &amp;&amp; term_supports_color;
<a name="l02604"></a>02604 <span class="preprocessor">#endif  // GTEST_OS_WINDOWS</span>
<a name="l02605"></a>02605 <span class="preprocessor"></span>  }
<a name="l02606"></a>02606 
<a name="l02607"></a>02607   <span class="keywordflow">return</span> String::CaseInsensitiveCStringEquals(gtest_color, <span class="stringliteral">&quot;yes&quot;</span>) ||
<a name="l02608"></a>02608       String::CaseInsensitiveCStringEquals(gtest_color, <span class="stringliteral">&quot;true&quot;</span>) ||
<a name="l02609"></a>02609       String::CaseInsensitiveCStringEquals(gtest_color, <span class="stringliteral">&quot;t&quot;</span>) ||
<a name="l02610"></a>02610       String::CStringEquals(gtest_color, <span class="stringliteral">&quot;1&quot;</span>);
<a name="l02611"></a>02611   <span class="comment">// We take &quot;yes&quot;, &quot;true&quot;, &quot;t&quot;, and &quot;1&quot; as meaning &quot;yes&quot;.  If the</span>
<a name="l02612"></a>02612   <span class="comment">// value is neither one of these nor &quot;auto&quot;, we treat it as &quot;no&quot; to</span>
<a name="l02613"></a>02613   <span class="comment">// be conservative.</span>
<a name="l02614"></a>02614 }
<a name="l02615"></a>02615 
<a name="l02616"></a>02616 <span class="comment">// Helpers for printing colored strings to stdout. Note that on Windows, we</span>
<a name="l02617"></a>02617 <span class="comment">// cannot simply emit special characters and have the terminal change colors.</span>
<a name="l02618"></a>02618 <span class="comment">// This routine must actually emit the characters rather than return a string</span>
<a name="l02619"></a>02619 <span class="comment">// that would be colored when printed, as can be done on Linux.</span>
<a name="l02620"></a>02620 <span class="keywordtype">void</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965">GTestColor</a> color, <span class="keyword">const</span> <span class="keywordtype">char</span>* fmt, ...) {
<a name="l02621"></a>02621   va_list args;
<a name="l02622"></a>02622   va_start(args, fmt);
<a name="l02623"></a>02623 
<a name="l02624"></a>02624 <span class="preprocessor">#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS</span>
<a name="l02625"></a>02625 <span class="preprocessor"></span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_color = <span class="keyword">false</span>;
<a name="l02626"></a>02626 <span class="preprocessor">#else</span>
<a name="l02627"></a>02627 <span class="preprocessor"></span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> in_color_mode =
<a name="l02628"></a>02628       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ab0f928e61ab8ec92e75ddfcae9324c1e">ShouldUseColor</a>(<a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#a95de7f4c27e0ed8d1b8a2dae5b8cd4aa">posix::IsATTY</a>(<a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#ad74bd19d3fa41052bbd53ec4ead31880">posix::FileNo</a>(stdout)) != 0);
<a name="l02629"></a>02629   <span class="keyword">const</span> <span class="keywordtype">bool</span> use_color = in_color_mode &amp;&amp; (color != <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965aaeda96851415e6bb57229cf139545439">COLOR_DEFAULT</a>);
<a name="l02630"></a>02630 <span class="preprocessor">#endif  // GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS</span>
<a name="l02631"></a>02631 <span class="preprocessor"></span>  <span class="comment">// The &#39;!= 0&#39; comparison is necessary to satisfy MSVC 7.1.</span>
<a name="l02632"></a>02632 
<a name="l02633"></a>02633   <span class="keywordflow">if</span> (!use_color) {
<a name="l02634"></a>02634     vprintf(fmt, args);
<a name="l02635"></a>02635     va_end(args);
<a name="l02636"></a>02636     <span class="keywordflow">return</span>;
<a name="l02637"></a>02637   }
<a name="l02638"></a>02638 
<a name="l02639"></a>02639 <span class="preprocessor">#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l02640"></a>02640 <span class="preprocessor"></span>  <span class="keyword">const</span> HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);
<a name="l02641"></a>02641 
<a name="l02642"></a>02642   <span class="comment">// Gets the current text color.</span>
<a name="l02643"></a>02643   CONSOLE_SCREEN_BUFFER_INFO buffer_info;
<a name="l02644"></a>02644   GetConsoleScreenBufferInfo(stdout_handle, &amp;buffer_info);
<a name="l02645"></a>02645   <span class="keyword">const</span> WORD old_color_attrs = buffer_info.wAttributes;
<a name="l02646"></a>02646 
<a name="l02647"></a>02647   <span class="comment">// We need to flush the stream buffers into the console before each</span>
<a name="l02648"></a>02648   <span class="comment">// SetConsoleTextAttribute call lest it affect the text that is already</span>
<a name="l02649"></a>02649   <span class="comment">// printed but has not yet reached the console.</span>
<a name="l02650"></a>02650   fflush(stdout);
<a name="l02651"></a>02651   SetConsoleTextAttribute(stdout_handle,
<a name="l02652"></a>02652                           GetColorAttribute(color) | FOREGROUND_INTENSITY);
<a name="l02653"></a>02653   vprintf(fmt, args);
<a name="l02654"></a>02654 
<a name="l02655"></a>02655   fflush(stdout);
<a name="l02656"></a>02656   <span class="comment">// Restores the text color.</span>
<a name="l02657"></a>02657   SetConsoleTextAttribute(stdout_handle, old_color_attrs);
<a name="l02658"></a>02658 <span class="preprocessor">#else</span>
<a name="l02659"></a>02659 <span class="preprocessor"></span>  printf(<span class="stringliteral">&quot;\033[0;3%sm&quot;</span>, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a381864cc8cad6df85e53dcee3b0cea92">GetAnsiColorCode</a>(color));
<a name="l02660"></a>02660   vprintf(fmt, args);
<a name="l02661"></a>02661   printf(<span class="stringliteral">&quot;\033[m&quot;</span>);  <span class="comment">// Resets the terminal to default.</span>
<a name="l02662"></a>02662 <span class="preprocessor">#endif  // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l02663"></a>02663 <span class="preprocessor"></span>  va_end(args);
<a name="l02664"></a>02664 }
<a name="l02665"></a>02665 
<a name="l02666"></a>02666 <span class="keywordtype">void</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a75563c3d082e5343e8da2bad4e813b4d">PrintFullTestCommentIfPresent</a>(<span class="keyword">const</span> TestInfo&amp; test_info) {
<a name="l02667"></a>02667   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> type_param = test_info.type_param();
<a name="l02668"></a>02668   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> value_param = test_info.value_param();
<a name="l02669"></a>02669 
<a name="l02670"></a>02670   <span class="keywordflow">if</span> (type_param != NULL || value_param != NULL) {
<a name="l02671"></a>02671     printf(<span class="stringliteral">&quot;, where &quot;</span>);
<a name="l02672"></a>02672     <span class="keywordflow">if</span> (type_param != NULL) {
<a name="l02673"></a>02673       printf(<span class="stringliteral">&quot;TypeParam = %s&quot;</span>, type_param);
<a name="l02674"></a>02674       <span class="keywordflow">if</span> (value_param != NULL)
<a name="l02675"></a>02675         printf(<span class="stringliteral">&quot; and &quot;</span>);
<a name="l02676"></a>02676     }
<a name="l02677"></a>02677     <span class="keywordflow">if</span> (value_param != NULL) {
<a name="l02678"></a>02678       printf(<span class="stringliteral">&quot;GetParam() = %s&quot;</span>, value_param);
<a name="l02679"></a>02679     }
<a name="l02680"></a>02680   }
<a name="l02681"></a>02681 }
<a name="l02682"></a>02682 
<a name="l02683"></a>02683 <span class="comment">// This class implements the TestEventListener interface.</span>
<a name="l02684"></a>02684 <span class="comment">//</span>
<a name="l02685"></a>02685 <span class="comment">// Class PrettyUnitTestResultPrinter is copyable.</span>
<a name="l02686"></a>02686 <span class="keyword">class </span>PrettyUnitTestResultPrinter : <span class="keyword">public</span> TestEventListener {
<a name="l02687"></a>02687  <span class="keyword">public</span>:
<a name="l02688"></a><a class="code" href="../../d6/d49/classtesting_1_1internal_1_1PrettyUnitTestResultPrinter.html#a7a5522d7d82830d114fb19dedeff3d2f">02688</a>   <a class="code" href="../../d6/d49/classtesting_1_1internal_1_1PrettyUnitTestResultPrinter.html#a7a5522d7d82830d114fb19dedeff3d2f">PrettyUnitTestResultPrinter</a>() {}
<a name="l02689"></a><a class="code" href="../../d6/d49/classtesting_1_1internal_1_1PrettyUnitTestResultPrinter.html#a4ec2068e374e2e36d6c61dbae70d98a4">02689</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="../../d6/d49/classtesting_1_1internal_1_1PrettyUnitTestResultPrinter.html#a4ec2068e374e2e36d6c61dbae70d98a4">PrintTestName</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * test_case, <span class="keyword">const</span> <span class="keywordtype">char</span> * test) {
<a name="l02690"></a>02690     printf(<span class="stringliteral">&quot;%s.%s&quot;</span>, test_case, test);
<a name="l02691"></a>02691   }
<a name="l02692"></a>02692 
<a name="l02693"></a>02693   <span class="comment">// The following methods override what&#39;s in the TestEventListener class.</span>
<a name="l02694"></a><a class="code" href="../../d6/d49/classtesting_1_1internal_1_1PrettyUnitTestResultPrinter.html#a9d43d6e5c4c37ade824998de2d83bd20">02694</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="../../d6/d49/classtesting_1_1internal_1_1PrettyUnitTestResultPrinter.html#a9d43d6e5c4c37ade824998de2d83bd20">OnTestProgramStart</a>(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; <span class="comment">/*unit_test*/</span>) {}
<a name="l02695"></a>02695   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestIterationStart(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test, <span class="keywordtype">int</span> iteration);
<a name="l02696"></a>02696   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnEnvironmentsSetUpStart(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test);
<a name="l02697"></a><a class="code" href="../../d6/d49/classtesting_1_1internal_1_1PrettyUnitTestResultPrinter.html#a4ab2823e779a053ad65cf7f01bb76b54">02697</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="../../d6/d49/classtesting_1_1internal_1_1PrettyUnitTestResultPrinter.html#a4ab2823e779a053ad65cf7f01bb76b54">OnEnvironmentsSetUpEnd</a>(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; <span class="comment">/*unit_test*/</span>) {}
<a name="l02698"></a>02698   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestCaseStart(<span class="keyword">const</span> <a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html">TestCase</a>&amp; test_case);
<a name="l02699"></a>02699   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestStart(<span class="keyword">const</span> <a class="code" href="../../df/d65/classtesting_1_1TestInfo.html">TestInfo</a>&amp; test_info);
<a name="l02700"></a>02700   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestPartResult(<span class="keyword">const</span> <a class="code" href="../../d9/d98/classtesting_1_1TestPartResult.html">TestPartResult</a>&amp; result);
<a name="l02701"></a>02701   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestEnd(<span class="keyword">const</span> <a class="code" href="../../df/d65/classtesting_1_1TestInfo.html">TestInfo</a>&amp; test_info);
<a name="l02702"></a>02702   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestCaseEnd(<span class="keyword">const</span> <a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html">TestCase</a>&amp; test_case);
<a name="l02703"></a>02703   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnEnvironmentsTearDownStart(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test);
<a name="l02704"></a><a class="code" href="../../d6/d49/classtesting_1_1internal_1_1PrettyUnitTestResultPrinter.html#af00cb6141021245e02c511782ce66b46">02704</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="../../d6/d49/classtesting_1_1internal_1_1PrettyUnitTestResultPrinter.html#af00cb6141021245e02c511782ce66b46">OnEnvironmentsTearDownEnd</a>(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; <span class="comment">/*unit_test*/</span>) {}
<a name="l02705"></a>02705   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestIterationEnd(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test, <span class="keywordtype">int</span> iteration);
<a name="l02706"></a><a class="code" href="../../d6/d49/classtesting_1_1internal_1_1PrettyUnitTestResultPrinter.html#a79232f629150d6a1e560f6729271e729">02706</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="../../d6/d49/classtesting_1_1internal_1_1PrettyUnitTestResultPrinter.html#a79232f629150d6a1e560f6729271e729">OnTestProgramEnd</a>(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; <span class="comment">/*unit_test*/</span>) {}
<a name="l02707"></a>02707 
<a name="l02708"></a>02708  <span class="keyword">private</span>:
<a name="l02709"></a>02709   <span class="keyword">static</span> <span class="keywordtype">void</span> PrintFailedTests(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test);
<a name="l02710"></a>02710 
<a name="l02711"></a>02711   <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html">internal::String</a> test_case_name_;
<a name="l02712"></a>02712 };
<a name="l02713"></a>02713 
<a name="l02714"></a>02714   <span class="comment">// Fired before each iteration of tests starts.</span>
<a name="l02715"></a>02715 <span class="keywordtype">void</span> PrettyUnitTestResultPrinter::OnTestIterationStart(
<a name="l02716"></a>02716     <span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test, <span class="keywordtype">int</span> iteration) {
<a name="l02717"></a>02717   <span class="keywordflow">if</span> (<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(repeat) != 1)
<a name="l02718"></a>02718     printf(<span class="stringliteral">&quot;\nRepeating all tests (iteration %d) . . .\n\n&quot;</span>, iteration + 1);
<a name="l02719"></a>02719 
<a name="l02720"></a>02720   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> filter = <a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(filter).c_str();
<a name="l02721"></a>02721 
<a name="l02722"></a>02722   <span class="comment">// Prints the filter if it&#39;s not *.  This reminds the user that some</span>
<a name="l02723"></a>02723   <span class="comment">// tests may be skipped.</span>
<a name="l02724"></a>02724   <span class="keywordflow">if</span> (!internal::String::CStringEquals(filter, <a class="code" href="../../d0/d75/namespacetesting.html#a1bf2eaf73b98e0bc07b11550f91986a1">kUniversalFilter</a>)) {
<a name="l02725"></a>02725     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a220df2a47a11552fb8631253ef7c3f10">COLOR_YELLOW</a>,
<a name="l02726"></a>02726                   <span class="stringliteral">&quot;Note: %s filter = %s\n&quot;</span>, <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a13d98c217176bd8722c395b9225fc19d">GTEST_NAME_</a>, filter);
<a name="l02727"></a>02727   }
<a name="l02728"></a>02728 
<a name="l02729"></a>02729   <span class="keywordflow">if</span> (<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a57e2697262a419061fc4cd3377a9271e">internal::ShouldShard</a>(<a class="code" href="../../d0/d75/namespacetesting.html#a9d9ddd278cfbb5834dea812d0de529be">kTestTotalShards</a>, <a class="code" href="../../d0/d75/namespacetesting.html#a34e170fdd4ba4d2f80456cc37e2a8185">kTestShardIndex</a>, <span class="keyword">false</span>)) {
<a name="l02730"></a>02730     <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a8d84339888eecdb29b3d8f7607af3ecc">Int32</a> shard_index = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#afec7cf2eb159fa969f88d192ee507d23">Int32FromEnvOrDie</a>(<a class="code" href="../../d0/d75/namespacetesting.html#a34e170fdd4ba4d2f80456cc37e2a8185">kTestShardIndex</a>, -1);
<a name="l02731"></a>02731     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a220df2a47a11552fb8631253ef7c3f10">COLOR_YELLOW</a>,
<a name="l02732"></a>02732                   <span class="stringliteral">&quot;Note: This is test shard %d of %s.\n&quot;</span>,
<a name="l02733"></a>02733                   static_cast&lt;int&gt;(shard_index) + 1,
<a name="l02734"></a>02734                   <a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#a7ed11bcd211f76641b16e60b5f0594eb">internal::posix::GetEnv</a>(<a class="code" href="../../d0/d75/namespacetesting.html#a9d9ddd278cfbb5834dea812d0de529be">kTestTotalShards</a>));
<a name="l02735"></a>02735   }
<a name="l02736"></a>02736 
<a name="l02737"></a>02737   <span class="keywordflow">if</span> (<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(shuffle)) {
<a name="l02738"></a>02738     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a220df2a47a11552fb8631253ef7c3f10">COLOR_YELLOW</a>,
<a name="l02739"></a>02739                   <span class="stringliteral">&quot;Note: Randomizing tests&#39; orders with a seed of %d .\n&quot;</span>,
<a name="l02740"></a>02740                   unit_test.<a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#ac0bcee84bdc839bfabd0a829642ab4f7">random_seed</a>());
<a name="l02741"></a>02741   }
<a name="l02742"></a>02742 
<a name="l02743"></a>02743   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>,  <span class="stringliteral">&quot;[==========] &quot;</span>);
<a name="l02744"></a>02744   printf(<span class="stringliteral">&quot;Running %s from %s.\n&quot;</span>,
<a name="l02745"></a>02745          <a class="code" href="../../d0/d75/namespacetesting.html#a9e35e748b0be521a7c14047d3cab12b2">FormatTestCount</a>(unit_test.<a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#aa6eccf86072f4f8ddd0bea30dfd45912">test_to_run_count</a>()).c_str(),
<a name="l02746"></a>02746          <a class="code" href="../../d0/d75/namespacetesting.html#a62a889fb8f600d386c9c75951b0a45b7">FormatTestCaseCount</a>(unit_test.<a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#adf212bae576e88dfb77bd114f01bc117">test_case_to_run_count</a>()).c_str());
<a name="l02747"></a>02747   fflush(stdout);
<a name="l02748"></a>02748 }
<a name="l02749"></a>02749 
<a name="l02750"></a>02750 <span class="keywordtype">void</span> PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(
<a name="l02751"></a>02751     <span class="keyword">const</span> UnitTest&amp; <span class="comment">/*unit_test*/</span>) {
<a name="l02752"></a>02752   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>,  <span class="stringliteral">&quot;[----------] &quot;</span>);
<a name="l02753"></a>02753   printf(<span class="stringliteral">&quot;Global test environment set-up.\n&quot;</span>);
<a name="l02754"></a>02754   fflush(stdout);
<a name="l02755"></a>02755 }
<a name="l02756"></a>02756 
<a name="l02757"></a>02757 <span class="keywordtype">void</span> PrettyUnitTestResultPrinter::OnTestCaseStart(<span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>&amp; test_case) {
<a name="l02758"></a>02758   test_case_name_ = test_case.name();
<a name="l02759"></a>02759   <span class="keyword">const</span> internal::String counts =
<a name="l02760"></a>02760       <a class="code" href="../../d0/d75/namespacetesting.html#aefca65bdfcf981c1e55c7d90e14a263f">FormatCountableNoun</a>(test_case.test_to_run_count(), <span class="stringliteral">&quot;test&quot;</span>, <span class="stringliteral">&quot;tests&quot;</span>);
<a name="l02761"></a>02761   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>, <span class="stringliteral">&quot;[----------] &quot;</span>);
<a name="l02762"></a>02762   printf(<span class="stringliteral">&quot;%s from %s&quot;</span>, counts.c_str(), test_case_name_.c_str());
<a name="l02763"></a>02763   <span class="keywordflow">if</span> (test_case.type_param() == NULL) {
<a name="l02764"></a>02764     printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02765"></a>02765   } <span class="keywordflow">else</span> {
<a name="l02766"></a>02766     printf(<span class="stringliteral">&quot;, where TypeParam = %s\n&quot;</span>, test_case.type_param());
<a name="l02767"></a>02767   }
<a name="l02768"></a>02768   fflush(stdout);
<a name="l02769"></a>02769 }
<a name="l02770"></a>02770 
<a name="l02771"></a>02771 <span class="keywordtype">void</span> PrettyUnitTestResultPrinter::OnTestStart(<span class="keyword">const</span> TestInfo&amp; test_info) {
<a name="l02772"></a>02772   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>,  <span class="stringliteral">&quot;[ RUN      ] &quot;</span>);
<a name="l02773"></a>02773   PrintTestName(test_case_name_.c_str(), test_info.name());
<a name="l02774"></a>02774   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02775"></a>02775   fflush(stdout);
<a name="l02776"></a>02776 }
<a name="l02777"></a>02777 
<a name="l02778"></a>02778 <span class="comment">// Called after an assertion failure.</span>
<a name="l02779"></a>02779 <span class="keywordtype">void</span> PrettyUnitTestResultPrinter::OnTestPartResult(
<a name="l02780"></a>02780     <span class="keyword">const</span> TestPartResult&amp; result) {
<a name="l02781"></a>02781   <span class="comment">// If the test part succeeded, we don&#39;t need to do anything.</span>
<a name="l02782"></a>02782   <span class="keywordflow">if</span> (result.type() == TestPartResult::kSuccess)
<a name="l02783"></a>02783     <span class="keywordflow">return</span>;
<a name="l02784"></a>02784 
<a name="l02785"></a>02785   <span class="comment">// Print failure message from the assertion (e.g. expected this and got that).</span>
<a name="l02786"></a>02786   <a class="code" href="../../d0/d75/namespacetesting.html#af2baf2fe4307d85e2124466614b0108a">PrintTestPartResult</a>(result);
<a name="l02787"></a>02787   fflush(stdout);
<a name="l02788"></a>02788 }
<a name="l02789"></a>02789 
<a name="l02790"></a>02790 <span class="keywordtype">void</span> PrettyUnitTestResultPrinter::OnTestEnd(<span class="keyword">const</span> TestInfo&amp; test_info) {
<a name="l02791"></a>02791   <span class="keywordflow">if</span> (test_info.result()-&gt;Passed()) {
<a name="l02792"></a>02792     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>, <span class="stringliteral">&quot;[       OK ] &quot;</span>);
<a name="l02793"></a>02793   } <span class="keywordflow">else</span> {
<a name="l02794"></a>02794     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a55978b2a4d309f4f009fd1baa7808358">COLOR_RED</a>, <span class="stringliteral">&quot;[  FAILED  ] &quot;</span>);
<a name="l02795"></a>02795   }
<a name="l02796"></a>02796   PrintTestName(test_case_name_.c_str(), test_info.name());
<a name="l02797"></a>02797   <span class="keywordflow">if</span> (test_info.result()-&gt;Failed())
<a name="l02798"></a>02798     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a75563c3d082e5343e8da2bad4e813b4d">PrintFullTestCommentIfPresent</a>(test_info);
<a name="l02799"></a>02799 
<a name="l02800"></a>02800   <span class="keywordflow">if</span> (<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(print_time)) {
<a name="l02801"></a>02801     printf(<span class="stringliteral">&quot; (%s ms)\n&quot;</span>, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a66c1c8bcb19e8562b79bd8ef9bab2aa9">internal::StreamableToString</a>(
<a name="l02802"></a>02802            test_info.result()-&gt;elapsed_time()).c_str());
<a name="l02803"></a>02803   } <span class="keywordflow">else</span> {
<a name="l02804"></a>02804     printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02805"></a>02805   }
<a name="l02806"></a>02806   fflush(stdout);
<a name="l02807"></a>02807 }
<a name="l02808"></a>02808 
<a name="l02809"></a>02809 <span class="keywordtype">void</span> PrettyUnitTestResultPrinter::OnTestCaseEnd(<span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>&amp; test_case) {
<a name="l02810"></a>02810   <span class="keywordflow">if</span> (!<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(print_time)) <span class="keywordflow">return</span>;
<a name="l02811"></a>02811 
<a name="l02812"></a>02812   test_case_name_ = test_case.name();
<a name="l02813"></a>02813   <span class="keyword">const</span> internal::String counts =
<a name="l02814"></a>02814       <a class="code" href="../../d0/d75/namespacetesting.html#aefca65bdfcf981c1e55c7d90e14a263f">FormatCountableNoun</a>(test_case.test_to_run_count(), <span class="stringliteral">&quot;test&quot;</span>, <span class="stringliteral">&quot;tests&quot;</span>);
<a name="l02815"></a>02815   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>, <span class="stringliteral">&quot;[----------] &quot;</span>);
<a name="l02816"></a>02816   printf(<span class="stringliteral">&quot;%s from %s (%s ms total)\n\n&quot;</span>,
<a name="l02817"></a>02817          counts.c_str(), test_case_name_.c_str(),
<a name="l02818"></a>02818          <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a66c1c8bcb19e8562b79bd8ef9bab2aa9">internal::StreamableToString</a>(test_case.elapsed_time()).c_str());
<a name="l02819"></a>02819   fflush(stdout);
<a name="l02820"></a>02820 }
<a name="l02821"></a>02821 
<a name="l02822"></a>02822 <span class="keywordtype">void</span> PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(
<a name="l02823"></a>02823     <span class="keyword">const</span> UnitTest&amp; <span class="comment">/*unit_test*/</span>) {
<a name="l02824"></a>02824   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>,  <span class="stringliteral">&quot;[----------] &quot;</span>);
<a name="l02825"></a>02825   printf(<span class="stringliteral">&quot;Global test environment tear-down\n&quot;</span>);
<a name="l02826"></a>02826   fflush(stdout);
<a name="l02827"></a>02827 }
<a name="l02828"></a>02828 
<a name="l02829"></a>02829 <span class="comment">// Internal helper for printing the list of failed tests.</span>
<a name="l02830"></a>02830 <span class="keywordtype">void</span> PrettyUnitTestResultPrinter::PrintFailedTests(<span class="keyword">const</span> UnitTest&amp; unit_test) {
<a name="l02831"></a>02831   <span class="keyword">const</span> <span class="keywordtype">int</span> failed_test_count = unit_test.failed_test_count();
<a name="l02832"></a>02832   <span class="keywordflow">if</span> (failed_test_count == 0) {
<a name="l02833"></a>02833     <span class="keywordflow">return</span>;
<a name="l02834"></a>02834   }
<a name="l02835"></a>02835 
<a name="l02836"></a>02836   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; unit_test.total_test_case_count(); ++i) {
<a name="l02837"></a>02837     <span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>&amp; test_case = *unit_test.GetTestCase(i);
<a name="l02838"></a>02838     <span class="keywordflow">if</span> (!test_case.should_run() || (test_case.failed_test_count() == 0)) {
<a name="l02839"></a>02839       <span class="keywordflow">continue</span>;
<a name="l02840"></a>02840     }
<a name="l02841"></a>02841     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; test_case.total_test_count(); ++j) {
<a name="l02842"></a>02842       <span class="keyword">const</span> TestInfo&amp; test_info = *test_case.GetTestInfo(j);
<a name="l02843"></a>02843       <span class="keywordflow">if</span> (!test_info.should_run() || test_info.result()-&gt;Passed()) {
<a name="l02844"></a>02844         <span class="keywordflow">continue</span>;
<a name="l02845"></a>02845       }
<a name="l02846"></a>02846       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a55978b2a4d309f4f009fd1baa7808358">COLOR_RED</a>, <span class="stringliteral">&quot;[  FAILED  ] &quot;</span>);
<a name="l02847"></a>02847       printf(<span class="stringliteral">&quot;%s.%s&quot;</span>, test_case.name(), test_info.name());
<a name="l02848"></a>02848       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a75563c3d082e5343e8da2bad4e813b4d">PrintFullTestCommentIfPresent</a>(test_info);
<a name="l02849"></a>02849       printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02850"></a>02850     }
<a name="l02851"></a>02851   }
<a name="l02852"></a>02852 }
<a name="l02853"></a>02853 
<a name="l02854"></a>02854 <span class="keywordtype">void</span> PrettyUnitTestResultPrinter::OnTestIterationEnd(<span class="keyword">const</span> UnitTest&amp; unit_test,
<a name="l02855"></a>02855                                                      <span class="keywordtype">int</span> <span class="comment">/*iteration*/</span>) {
<a name="l02856"></a>02856   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>,  <span class="stringliteral">&quot;[==========] &quot;</span>);
<a name="l02857"></a>02857   printf(<span class="stringliteral">&quot;%s from %s ran.&quot;</span>,
<a name="l02858"></a>02858          <a class="code" href="../../d0/d75/namespacetesting.html#a9e35e748b0be521a7c14047d3cab12b2">FormatTestCount</a>(unit_test.test_to_run_count()).c_str(),
<a name="l02859"></a>02859          <a class="code" href="../../d0/d75/namespacetesting.html#a62a889fb8f600d386c9c75951b0a45b7">FormatTestCaseCount</a>(unit_test.test_case_to_run_count()).c_str());
<a name="l02860"></a>02860   <span class="keywordflow">if</span> (<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(print_time)) {
<a name="l02861"></a>02861     printf(<span class="stringliteral">&quot; (%s ms total)&quot;</span>,
<a name="l02862"></a>02862            <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a66c1c8bcb19e8562b79bd8ef9bab2aa9">internal::StreamableToString</a>(unit_test.elapsed_time()).c_str());
<a name="l02863"></a>02863   }
<a name="l02864"></a>02864   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02865"></a>02865   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>,  <span class="stringliteral">&quot;[  PASSED  ] &quot;</span>);
<a name="l02866"></a>02866   printf(<span class="stringliteral">&quot;%s.\n&quot;</span>, <a class="code" href="../../d0/d75/namespacetesting.html#a9e35e748b0be521a7c14047d3cab12b2">FormatTestCount</a>(unit_test.successful_test_count()).c_str());
<a name="l02867"></a>02867 
<a name="l02868"></a>02868   <span class="keywordtype">int</span> num_failures = unit_test.failed_test_count();
<a name="l02869"></a>02869   <span class="keywordflow">if</span> (!unit_test.Passed()) {
<a name="l02870"></a>02870     <span class="keyword">const</span> <span class="keywordtype">int</span> failed_test_count = unit_test.failed_test_count();
<a name="l02871"></a>02871     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a55978b2a4d309f4f009fd1baa7808358">COLOR_RED</a>,  <span class="stringliteral">&quot;[  FAILED  ] &quot;</span>);
<a name="l02872"></a>02872     printf(<span class="stringliteral">&quot;%s, listed below:\n&quot;</span>, <a class="code" href="../../d0/d75/namespacetesting.html#a9e35e748b0be521a7c14047d3cab12b2">FormatTestCount</a>(failed_test_count).c_str());
<a name="l02873"></a>02873     PrintFailedTests(unit_test);
<a name="l02874"></a>02874     printf(<span class="stringliteral">&quot;\n%2d FAILED %s\n&quot;</span>, num_failures,
<a name="l02875"></a>02875                         num_failures == 1 ? <span class="stringliteral">&quot;TEST&quot;</span> : <span class="stringliteral">&quot;TESTS&quot;</span>);
<a name="l02876"></a>02876   }
<a name="l02877"></a>02877 
<a name="l02878"></a>02878   <span class="keywordtype">int</span> num_disabled = unit_test.disabled_test_count();
<a name="l02879"></a>02879   <span class="keywordflow">if</span> (num_disabled &amp;&amp; !<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(also_run_disabled_tests)) {
<a name="l02880"></a>02880     <span class="keywordflow">if</span> (!num_failures) {
<a name="l02881"></a>02881       printf(<span class="stringliteral">&quot;\n&quot;</span>);  <span class="comment">// Add a spacer if no FAILURE banner is displayed.</span>
<a name="l02882"></a>02882     }
<a name="l02883"></a>02883     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a220df2a47a11552fb8631253ef7c3f10">COLOR_YELLOW</a>,
<a name="l02884"></a>02884                   <span class="stringliteral">&quot;  YOU HAVE %d DISABLED %s\n\n&quot;</span>,
<a name="l02885"></a>02885                   num_disabled,
<a name="l02886"></a>02886                   num_disabled == 1 ? <span class="stringliteral">&quot;TEST&quot;</span> : <span class="stringliteral">&quot;TESTS&quot;</span>);
<a name="l02887"></a>02887   }
<a name="l02888"></a>02888   <span class="comment">// Ensure that Google Test output is printed before, e.g., heapchecker output.</span>
<a name="l02889"></a>02889   fflush(stdout);
<a name="l02890"></a>02890 }
<a name="l02891"></a>02891 
<a name="l02892"></a>02892 <span class="comment">// End PrettyUnitTestResultPrinter</span>
<a name="l02893"></a>02893 
<a name="l02894"></a>02894 <span class="comment">// class TestEventRepeater</span>
<a name="l02895"></a>02895 <span class="comment">//</span>
<a name="l02896"></a>02896 <span class="comment">// This class forwards events to other event listeners.</span>
<a name="l02897"></a>02897 <span class="keyword">class </span>TestEventRepeater : <span class="keyword">public</span> TestEventListener {
<a name="l02898"></a>02898  <span class="keyword">public</span>:
<a name="l02899"></a><a class="code" href="../../d9/df1/classtesting_1_1internal_1_1TestEventRepeater.html#a75cb462a1faf8e97a8ea24af5a3730c7">02899</a>   <a class="code" href="../../d9/df1/classtesting_1_1internal_1_1TestEventRepeater.html#a75cb462a1faf8e97a8ea24af5a3730c7">TestEventRepeater</a>() : forwarding_enabled_(true) {}
<a name="l02900"></a>02900   <span class="keyword">virtual</span> ~<a class="code" href="../../d9/df1/classtesting_1_1internal_1_1TestEventRepeater.html">TestEventRepeater</a>();
<a name="l02901"></a>02901   <span class="keywordtype">void</span> Append(<a class="code" href="../../d0/d51/classtesting_1_1TestEventListener.html">TestEventListener</a> *listener);
<a name="l02902"></a>02902   <a class="code" href="../../d0/d51/classtesting_1_1TestEventListener.html">TestEventListener</a>* Release(<a class="code" href="../../d0/d51/classtesting_1_1TestEventListener.html">TestEventListener</a>* listener);
<a name="l02903"></a>02903 
<a name="l02904"></a>02904   <span class="comment">// Controls whether events will be forwarded to listeners_. Set to false</span>
<a name="l02905"></a>02905   <span class="comment">// in death test child processes.</span>
<a name="l02906"></a><a class="code" href="../../d9/df1/classtesting_1_1internal_1_1TestEventRepeater.html#a52998d5b896a7fdc74e14f713df0a2cb">02906</a>   <span class="keywordtype">bool</span> <a class="code" href="../../d9/df1/classtesting_1_1internal_1_1TestEventRepeater.html#a52998d5b896a7fdc74e14f713df0a2cb">forwarding_enabled</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> forwarding_enabled_; }
<a name="l02907"></a><a class="code" href="../../d9/df1/classtesting_1_1internal_1_1TestEventRepeater.html#a98d02212569aa17d23c98a0c4b742d08">02907</a>   <span class="keywordtype">void</span> <a class="code" href="../../d9/df1/classtesting_1_1internal_1_1TestEventRepeater.html#a98d02212569aa17d23c98a0c4b742d08">set_forwarding_enabled</a>(<span class="keywordtype">bool</span> enable) { forwarding_enabled_ = enable; }
<a name="l02908"></a>02908 
<a name="l02909"></a>02909   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestProgramStart(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test);
<a name="l02910"></a>02910   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestIterationStart(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test, <span class="keywordtype">int</span> iteration);
<a name="l02911"></a>02911   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnEnvironmentsSetUpStart(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test);
<a name="l02912"></a>02912   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnEnvironmentsSetUpEnd(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test);
<a name="l02913"></a>02913   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestCaseStart(<span class="keyword">const</span> <a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html">TestCase</a>&amp; test_case);
<a name="l02914"></a>02914   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestStart(<span class="keyword">const</span> <a class="code" href="../../df/d65/classtesting_1_1TestInfo.html">TestInfo</a>&amp; test_info);
<a name="l02915"></a>02915   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestPartResult(<span class="keyword">const</span> <a class="code" href="../../d9/d98/classtesting_1_1TestPartResult.html">TestPartResult</a>&amp; result);
<a name="l02916"></a>02916   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestEnd(<span class="keyword">const</span> <a class="code" href="../../df/d65/classtesting_1_1TestInfo.html">TestInfo</a>&amp; test_info);
<a name="l02917"></a>02917   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestCaseEnd(<span class="keyword">const</span> <a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html">TestCase</a>&amp; test_case);
<a name="l02918"></a>02918   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnEnvironmentsTearDownStart(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test);
<a name="l02919"></a>02919   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnEnvironmentsTearDownEnd(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test);
<a name="l02920"></a>02920   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestIterationEnd(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test, <span class="keywordtype">int</span> iteration);
<a name="l02921"></a>02921   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestProgramEnd(<span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test);
<a name="l02922"></a>02922 
<a name="l02923"></a>02923  <span class="keyword">private</span>:
<a name="l02924"></a>02924   <span class="comment">// Controls whether events will be forwarded to listeners_. Set to false</span>
<a name="l02925"></a>02925   <span class="comment">// in death test child processes.</span>
<a name="l02926"></a>02926   <span class="keywordtype">bool</span> forwarding_enabled_;
<a name="l02927"></a>02927   <span class="comment">// The list of listeners that receive events.</span>
<a name="l02928"></a>02928   std::vector&lt;TestEventListener*&gt; listeners_;
<a name="l02929"></a>02929 
<a name="l02930"></a>02930   <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(<a class="code" href="../../d9/df1/classtesting_1_1internal_1_1TestEventRepeater.html">TestEventRepeater</a>);
<a name="l02931"></a>02931 };
<a name="l02932"></a>02932 
<a name="l02933"></a>02933 TestEventRepeater::~TestEventRepeater() {
<a name="l02934"></a>02934   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af699259a2b1e5e06250ed075b735b1f6">ForEach</a>(listeners_, Delete&lt;TestEventListener&gt;);
<a name="l02935"></a>02935 }
<a name="l02936"></a>02936 
<a name="l02937"></a>02937 <span class="keywordtype">void</span> TestEventRepeater::Append(TestEventListener *listener) {
<a name="l02938"></a>02938   listeners_.push_back(listener);
<a name="l02939"></a>02939 }
<a name="l02940"></a>02940 
<a name="l02941"></a>02941 <span class="comment">// TODO(vladl@google.com): Factor the search functionality into Vector::Find.</span>
<a name="l02942"></a>02942 TestEventListener* TestEventRepeater::Release(TestEventListener *listener) {
<a name="l02943"></a>02943   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; listeners_.size(); ++i) {
<a name="l02944"></a>02944     <span class="keywordflow">if</span> (listeners_[i] == listener) {
<a name="l02945"></a>02945       listeners_.erase(listeners_.begin() + i);
<a name="l02946"></a>02946       <span class="keywordflow">return</span> listener;
<a name="l02947"></a>02947     }
<a name="l02948"></a>02948   }
<a name="l02949"></a>02949 
<a name="l02950"></a>02950   <span class="keywordflow">return</span> NULL;
<a name="l02951"></a>02951 }
<a name="l02952"></a>02952 
<a name="l02953"></a>02953 <span class="comment">// Since most methods are very similar, use macros to reduce boilerplate.</span>
<a name="l02954"></a>02954 <span class="comment">// This defines a member that forwards the call to all listeners.</span>
<a name="l02955"></a><a class="code" href="../../df/d5b/gtest_8cc.html#a87a475ab9e81de8b49525787665b9229">02955</a> <span class="preprocessor">#define GTEST_REPEATER_METHOD_(Name, Type) \</span>
<a name="l02956"></a>02956 <span class="preprocessor">void TestEventRepeater::Name(const Type&amp; parameter) { \</span>
<a name="l02957"></a>02957 <span class="preprocessor">  if (forwarding_enabled_) { \</span>
<a name="l02958"></a>02958 <span class="preprocessor">    for (size_t i = 0; i &lt; listeners_.size(); i++) { \</span>
<a name="l02959"></a>02959 <span class="preprocessor">      listeners_[i]-&gt;Name(parameter); \</span>
<a name="l02960"></a>02960 <span class="preprocessor">    } \</span>
<a name="l02961"></a>02961 <span class="preprocessor">  } \</span>
<a name="l02962"></a>02962 <span class="preprocessor">}</span>
<a name="l02963"></a>02963 <span class="preprocessor"></span><span class="comment">// This defines a member that forwards the call to all listeners in reverse</span>
<a name="l02964"></a>02964 <span class="comment">// order.</span>
<a name="l02965"></a><a class="code" href="../../df/d5b/gtest_8cc.html#aa7da32fd7da6a8cceeed6b448cb7b5f2">02965</a> <span class="preprocessor">#define GTEST_REVERSE_REPEATER_METHOD_(Name, Type) \</span>
<a name="l02966"></a>02966 <span class="preprocessor">void TestEventRepeater::Name(const Type&amp; parameter) { \</span>
<a name="l02967"></a>02967 <span class="preprocessor">  if (forwarding_enabled_) { \</span>
<a name="l02968"></a>02968 <span class="preprocessor">    for (int i = static_cast&lt;int&gt;(listeners_.size()) - 1; i &gt;= 0; i--) { \</span>
<a name="l02969"></a>02969 <span class="preprocessor">      listeners_[i]-&gt;Name(parameter); \</span>
<a name="l02970"></a>02970 <span class="preprocessor">    } \</span>
<a name="l02971"></a>02971 <span class="preprocessor">  } \</span>
<a name="l02972"></a>02972 <span class="preprocessor">}</span>
<a name="l02973"></a>02973 <span class="preprocessor"></span>
<a name="l02974"></a>02974 <a class="code" href="../../df/d5b/gtest_8cc.html#a87a475ab9e81de8b49525787665b9229">GTEST_REPEATER_METHOD_</a>(OnTestProgramStart, UnitTest)
<a name="l02975"></a>02975 <a class="code" href="../../df/d5b/gtest_8cc.html#a87a475ab9e81de8b49525787665b9229">GTEST_REPEATER_METHOD_</a>(OnEnvironmentsSetUpStart, UnitTest)
<a name="l02976"></a>02976 <a class="code" href="../../df/d5b/gtest_8cc.html#a87a475ab9e81de8b49525787665b9229">GTEST_REPEATER_METHOD_</a>(OnTestCaseStart, <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>)
<a name="l02977"></a>02977 <a class="code" href="../../df/d5b/gtest_8cc.html#a87a475ab9e81de8b49525787665b9229">GTEST_REPEATER_METHOD_</a>(OnTestStart, TestInfo)
<a name="l02978"></a>02978 <a class="code" href="../../df/d5b/gtest_8cc.html#a87a475ab9e81de8b49525787665b9229">GTEST_REPEATER_METHOD_</a>(OnTestPartResult, TestPartResult)
<a name="l02979"></a>02979 <a class="code" href="../../df/d5b/gtest_8cc.html#a87a475ab9e81de8b49525787665b9229">GTEST_REPEATER_METHOD_</a>(OnEnvironmentsTearDownStart, UnitTest)
<a name="l02980"></a>02980 <a class="code" href="../../df/d5b/gtest_8cc.html#aa7da32fd7da6a8cceeed6b448cb7b5f2">GTEST_REVERSE_REPEATER_METHOD_</a>(OnEnvironmentsSetUpEnd, UnitTest)
<a name="l02981"></a>02981 <a class="code" href="../../df/d5b/gtest_8cc.html#aa7da32fd7da6a8cceeed6b448cb7b5f2">GTEST_REVERSE_REPEATER_METHOD_</a>(OnEnvironmentsTearDownEnd, UnitTest)
<a name="l02982"></a>02982 <a class="code" href="../../df/d5b/gtest_8cc.html#aa7da32fd7da6a8cceeed6b448cb7b5f2">GTEST_REVERSE_REPEATER_METHOD_</a>(OnTestEnd, TestInfo)
<a name="l02983"></a>02983 <a class="code" href="../../df/d5b/gtest_8cc.html#aa7da32fd7da6a8cceeed6b448cb7b5f2">GTEST_REVERSE_REPEATER_METHOD_</a>(OnTestCaseEnd, <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>)
<a name="l02984"></a>02984 <a class="code" href="../../df/d5b/gtest_8cc.html#aa7da32fd7da6a8cceeed6b448cb7b5f2">GTEST_REVERSE_REPEATER_METHOD_</a>(OnTestProgramEnd, UnitTest)
<a name="l02985"></a>02985 
<a name="l02986"></a>02986 <span class="preprocessor">#undef GTEST_REPEATER_METHOD_</span>
<a name="l02987"></a>02987 <span class="preprocessor"></span><span class="preprocessor">#undef GTEST_REVERSE_REPEATER_METHOD_</span>
<a name="l02988"></a>02988 <span class="preprocessor"></span>
<a name="l02989"></a>02989 <span class="keywordtype">void</span> TestEventRepeater::OnTestIterationStart(<span class="keyword">const</span> UnitTest&amp; unit_test,
<a name="l02990"></a>02990                                              <span class="keywordtype">int</span> iteration) {
<a name="l02991"></a>02991   <span class="keywordflow">if</span> (forwarding_enabled_) {
<a name="l02992"></a>02992     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; listeners_.size(); i++) {
<a name="l02993"></a>02993       listeners_[i]-&gt;OnTestIterationStart(unit_test, iteration);
<a name="l02994"></a>02994     }
<a name="l02995"></a>02995   }
<a name="l02996"></a>02996 }
<a name="l02997"></a>02997 
<a name="l02998"></a>02998 <span class="keywordtype">void</span> TestEventRepeater::OnTestIterationEnd(<span class="keyword">const</span> UnitTest&amp; unit_test,
<a name="l02999"></a>02999                                            <span class="keywordtype">int</span> iteration) {
<a name="l03000"></a>03000   <span class="keywordflow">if</span> (forwarding_enabled_) {
<a name="l03001"></a>03001     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = static_cast&lt;int&gt;(listeners_.size()) - 1; i &gt;= 0; i--) {
<a name="l03002"></a>03002       listeners_[i]-&gt;OnTestIterationEnd(unit_test, iteration);
<a name="l03003"></a>03003     }
<a name="l03004"></a>03004   }
<a name="l03005"></a>03005 }
<a name="l03006"></a>03006 
<a name="l03007"></a>03007 <span class="comment">// End TestEventRepeater</span>
<a name="l03008"></a>03008 
<a name="l03009"></a>03009 <span class="comment">// This class generates an XML output file.</span>
<a name="l03010"></a>03010 <span class="keyword">class </span>XmlUnitTestResultPrinter : <span class="keyword">public</span> EmptyTestEventListener {
<a name="l03011"></a>03011  <span class="keyword">public</span>:
<a name="l03012"></a>03012   <span class="keyword">explicit</span> XmlUnitTestResultPrinter(<span class="keyword">const</span> <span class="keywordtype">char</span>* output_file);
<a name="l03013"></a>03013 
<a name="l03014"></a>03014   <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnTestIterationEnd(<span class="keyword">const</span> UnitTest&amp; unit_test, <span class="keywordtype">int</span> iteration);
<a name="l03015"></a>03015 
<a name="l03016"></a>03016  <span class="keyword">private</span>:
<a name="l03017"></a>03017   <span class="comment">// Is c a whitespace character that is normalized to a space character</span>
<a name="l03018"></a>03018   <span class="comment">// when it appears in an XML attribute value?</span>
<a name="l03019"></a><a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a3d910f5c6a752c629a276a8585640795">03019</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a3d910f5c6a752c629a276a8585640795">IsNormalizableWhitespace</a>(<span class="keywordtype">char</span> c) {
<a name="l03020"></a>03020     <span class="keywordflow">return</span> c == 0x9 || c == 0xA || c == 0xD;
<a name="l03021"></a>03021   }
<a name="l03022"></a>03022 
<a name="l03023"></a>03023   <span class="comment">// May c appear in a well-formed XML document?</span>
<a name="l03024"></a><a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a18cfed6b1b9d7aedd2c43129c7e46e95">03024</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a18cfed6b1b9d7aedd2c43129c7e46e95">IsValidXmlCharacter</a>(<span class="keywordtype">char</span> c) {
<a name="l03025"></a>03025     <span class="keywordflow">return</span> IsNormalizableWhitespace(c) || c &gt;= 0x20;
<a name="l03026"></a>03026   }
<a name="l03027"></a>03027 
<a name="l03028"></a>03028   <span class="comment">// Returns an XML-escaped copy of the input string str.  If</span>
<a name="l03029"></a>03029   <span class="comment">// is_attribute is true, the text is meant to appear as an attribute</span>
<a name="l03030"></a>03030   <span class="comment">// value, and normalizable whitespace is preserved by replacing it</span>
<a name="l03031"></a>03031   <span class="comment">// with character references.</span>
<a name="l03032"></a>03032   <span class="keyword">static</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html">String</a> EscapeXml(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">bool</span> is_attribute);
<a name="l03033"></a>03033 
<a name="l03034"></a>03034   <span class="comment">// Returns the given string with all characters invalid in XML removed.</span>
<a name="l03035"></a>03035   <span class="keyword">static</span> <span class="keywordtype">string</span> RemoveInvalidXmlCharacters(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str);
<a name="l03036"></a>03036 
<a name="l03037"></a>03037   <span class="comment">// Convenience wrapper around EscapeXml when str is an attribute value.</span>
<a name="l03038"></a><a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a96cf735f70894f043d9f39f02bff8535">03038</a>   <span class="keyword">static</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html">String</a> <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a96cf735f70894f043d9f39f02bff8535">EscapeXmlAttribute</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str) {
<a name="l03039"></a>03039     <span class="keywordflow">return</span> EscapeXml(str, <span class="keyword">true</span>);
<a name="l03040"></a>03040   }
<a name="l03041"></a>03041 
<a name="l03042"></a>03042   <span class="comment">// Convenience wrapper around EscapeXml when str is not an attribute value.</span>
<a name="l03043"></a><a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a18cfca127592a1649ac9a536b7d3a2be">03043</a>   <span class="keyword">static</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html">String</a> <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a18cfca127592a1649ac9a536b7d3a2be">EscapeXmlText</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str) { <span class="keywordflow">return</span> EscapeXml(str, <span class="keyword">false</span>); }
<a name="l03044"></a>03044 
<a name="l03045"></a>03045   <span class="comment">// Streams an XML CDATA section, escaping invalid CDATA sequences as needed.</span>
<a name="l03046"></a>03046   <span class="keyword">static</span> <span class="keywordtype">void</span> OutputXmlCDataSection(::std::ostream* stream, <span class="keyword">const</span> <span class="keywordtype">char</span>* data);
<a name="l03047"></a>03047 
<a name="l03048"></a>03048   <span class="comment">// Streams an XML representation of a TestInfo object.</span>
<a name="l03049"></a>03049   <span class="keyword">static</span> <span class="keywordtype">void</span> OutputXmlTestInfo(::std::ostream* stream,
<a name="l03050"></a>03050                                 <span class="keyword">const</span> <span class="keywordtype">char</span>* test_case_name,
<a name="l03051"></a>03051                                 <span class="keyword">const</span> <a class="code" href="../../df/d65/classtesting_1_1TestInfo.html">TestInfo</a>&amp; test_info);
<a name="l03052"></a>03052 
<a name="l03053"></a>03053   <span class="comment">// Prints an XML representation of a TestCase object</span>
<a name="l03054"></a>03054   <span class="keyword">static</span> <span class="keywordtype">void</span> PrintXmlTestCase(FILE* out, <span class="keyword">const</span> <a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html">TestCase</a>&amp; test_case);
<a name="l03055"></a>03055 
<a name="l03056"></a>03056   <span class="comment">// Prints an XML summary of unit_test to output stream out.</span>
<a name="l03057"></a>03057   <span class="keyword">static</span> <span class="keywordtype">void</span> PrintXmlUnitTest(FILE* out, <span class="keyword">const</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test);
<a name="l03058"></a>03058 
<a name="l03059"></a>03059   <span class="comment">// Produces a string representing the test properties in a result as space</span>
<a name="l03060"></a>03060   <span class="comment">// delimited XML attributes based on the property key=&quot;value&quot; pairs.</span>
<a name="l03061"></a>03061   <span class="comment">// When the String is not empty, it includes a space at the beginning,</span>
<a name="l03062"></a>03062   <span class="comment">// to delimit this attribute from prior attributes.</span>
<a name="l03063"></a>03063   <span class="keyword">static</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html">String</a> TestPropertiesAsXmlAttributes(<span class="keyword">const</span> <a class="code" href="../../d6/d6e/classtesting_1_1TestResult.html">TestResult</a>&amp; result);
<a name="l03064"></a>03064 
<a name="l03065"></a>03065   <span class="comment">// The output file.</span>
<a name="l03066"></a>03066   <span class="keyword">const</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html">String</a> output_file_;
<a name="l03067"></a>03067 
<a name="l03068"></a>03068   <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(<a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html">XmlUnitTestResultPrinter</a>);
<a name="l03069"></a>03069 };
<a name="l03070"></a>03070 
<a name="l03071"></a>03071 <span class="comment">// Creates a new XmlUnitTestResultPrinter.</span>
<a name="l03072"></a>03072 XmlUnitTestResultPrinter::XmlUnitTestResultPrinter(<span class="keyword">const</span> <span class="keywordtype">char</span>* output_file)
<a name="l03073"></a>03073     : output_file_(output_file) {
<a name="l03074"></a>03074   <span class="keywordflow">if</span> (<a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a20d1d061771050add045d968a88ab3ff">output_file_</a>.<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>() == NULL || <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a20d1d061771050add045d968a88ab3ff">output_file_</a>.<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#ac6e61de369e994009e36f344f99c15ad">empty</a>()) {
<a name="l03075"></a>03075     fprintf(stderr, <span class="stringliteral">&quot;XML output file may not be null\n&quot;</span>);
<a name="l03076"></a>03076     fflush(stderr);
<a name="l03077"></a>03077     exit(EXIT_FAILURE);
<a name="l03078"></a>03078   }
<a name="l03079"></a>03079 }
<a name="l03080"></a>03080 
<a name="l03081"></a>03081 <span class="comment">// Called after the unit test ends.</span>
<a name="l03082"></a>03082 <span class="keywordtype">void</span> <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#aa21b349a51378e47877ee6d153c37116">XmlUnitTestResultPrinter::OnTestIterationEnd</a>(<span class="keyword">const</span> UnitTest&amp; unit_test,
<a name="l03083"></a>03083                                                   <span class="keywordtype">int</span> <span class="comment">/*iteration*/</span>) {
<a name="l03084"></a>03084   FILE* xmlout = NULL;
<a name="l03085"></a>03085   FilePath output_file(<a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a20d1d061771050add045d968a88ab3ff">output_file_</a>);
<a name="l03086"></a>03086   FilePath <a class="code" href="../../d3/d03/namespaceversiongenerate.html#ae82ead30c0dfff23c81a0aa557d3602f">output_dir</a>(output_file.RemoveFileName());
<a name="l03087"></a>03087 
<a name="l03088"></a>03088   <span class="keywordflow">if</span> (<a class="code" href="../../d3/d03/namespaceversiongenerate.html#ae82ead30c0dfff23c81a0aa557d3602f">output_dir</a>.CreateDirectoriesRecursively()) {
<a name="l03089"></a>03089     xmlout = <a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#a71d8d763c7a5feba8bbb9a65fdc4cc87">posix::FOpen</a>(<a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a20d1d061771050add045d968a88ab3ff">output_file_</a>.<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>(), <span class="stringliteral">&quot;w&quot;</span>);
<a name="l03090"></a>03090   }
<a name="l03091"></a>03091   <span class="keywordflow">if</span> (xmlout == NULL) {
<a name="l03092"></a>03092     <span class="comment">// TODO(wan): report the reason of the failure.</span>
<a name="l03093"></a>03093     <span class="comment">//</span>
<a name="l03094"></a>03094     <span class="comment">// We don&#39;t do it for now as:</span>
<a name="l03095"></a>03095     <span class="comment">//</span>
<a name="l03096"></a>03096     <span class="comment">//   1. There is no urgent need for it.</span>
<a name="l03097"></a>03097     <span class="comment">//   2. It&#39;s a bit involved to make the errno variable thread-safe on</span>
<a name="l03098"></a>03098     <span class="comment">//      all three operating systems (Linux, Windows, and Mac OS).</span>
<a name="l03099"></a>03099     <span class="comment">//   3. To interpret the meaning of errno in a thread-safe way,</span>
<a name="l03100"></a>03100     <span class="comment">//      we need the strerror_r() function, which is not available on</span>
<a name="l03101"></a>03101     <span class="comment">//      Windows.</span>
<a name="l03102"></a>03102     fprintf(stderr,
<a name="l03103"></a>03103             <span class="stringliteral">&quot;Unable to open file \&quot;%s\&quot;\n&quot;</span>,
<a name="l03104"></a>03104             <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a20d1d061771050add045d968a88ab3ff">output_file_</a>.<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>());
<a name="l03105"></a>03105     fflush(stderr);
<a name="l03106"></a>03106     exit(EXIT_FAILURE);
<a name="l03107"></a>03107   }
<a name="l03108"></a>03108   <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#aec193026deaa7c08c5dd5a1ef7366c19">PrintXmlUnitTest</a>(xmlout, unit_test);
<a name="l03109"></a>03109   fclose(xmlout);
<a name="l03110"></a>03110 }
<a name="l03111"></a>03111 
<a name="l03112"></a>03112 <span class="comment">// Returns an XML-escaped copy of the input string str.  If is_attribute</span>
<a name="l03113"></a>03113 <span class="comment">// is true, the text is meant to appear as an attribute value, and</span>
<a name="l03114"></a>03114 <span class="comment">// normalizable whitespace is preserved by replacing it with character</span>
<a name="l03115"></a>03115 <span class="comment">// references.</span>
<a name="l03116"></a>03116 <span class="comment">//</span>
<a name="l03117"></a>03117 <span class="comment">// Invalid XML characters in str, if any, are stripped from the output.</span>
<a name="l03118"></a>03118 <span class="comment">// It is expected that most, if not all, of the text processed by this</span>
<a name="l03119"></a>03119 <span class="comment">// module will consist of ordinary English text.</span>
<a name="l03120"></a>03120 <span class="comment">// If this module is ever modified to produce version 1.1 XML output,</span>
<a name="l03121"></a>03121 <span class="comment">// most invalid characters can be retained using character references.</span>
<a name="l03122"></a>03122 <span class="comment">// TODO(wan): It might be nice to have a minimally invasive, human-readable</span>
<a name="l03123"></a>03123 <span class="comment">// escaping scheme for invalid characters, rather than dropping them.</span>
<a name="l03124"></a>03124 String <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a518c5e6812aa496afd62eac740a7d251">XmlUnitTestResultPrinter::EscapeXml</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">bool</span> is_attribute) {
<a name="l03125"></a>03125   Message m;
<a name="l03126"></a>03126 
<a name="l03127"></a>03127   <span class="keywordflow">if</span> (str != NULL) {
<a name="l03128"></a>03128     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>* src = str; *src; ++src) {
<a name="l03129"></a>03129       <span class="keywordflow">switch</span> (*src) {
<a name="l03130"></a>03130         <span class="keywordflow">case</span> <span class="charliteral">&#39;&lt;&#39;</span>:
<a name="l03131"></a>03131           m &lt;&lt; <span class="stringliteral">&quot;&amp;lt;&quot;</span>;
<a name="l03132"></a>03132           <span class="keywordflow">break</span>;
<a name="l03133"></a>03133         <span class="keywordflow">case</span> <span class="charliteral">&#39;&gt;&#39;</span>:
<a name="l03134"></a>03134           m &lt;&lt; <span class="stringliteral">&quot;&amp;gt;&quot;</span>;
<a name="l03135"></a>03135           <span class="keywordflow">break</span>;
<a name="l03136"></a>03136         <span class="keywordflow">case</span> <span class="charliteral">&#39;&amp;&#39;</span>:
<a name="l03137"></a>03137           m &lt;&lt; <span class="stringliteral">&quot;&amp;amp;&quot;</span>;
<a name="l03138"></a>03138           <span class="keywordflow">break</span>;
<a name="l03139"></a>03139         <span class="keywordflow">case</span> <span class="charliteral">&#39;\&#39;&#39;</span>:
<a name="l03140"></a>03140           <span class="keywordflow">if</span> (is_attribute)
<a name="l03141"></a>03141             m &lt;&lt; <span class="stringliteral">&quot;&amp;apos;&quot;</span>;
<a name="l03142"></a>03142           <span class="keywordflow">else</span>
<a name="l03143"></a>03143             m &lt;&lt; <span class="charliteral">&#39;\&#39;&#39;</span>;
<a name="l03144"></a>03144           <span class="keywordflow">break</span>;
<a name="l03145"></a>03145         <span class="keywordflow">case</span> <span class="charliteral">&#39;&quot;&#39;</span>:
<a name="l03146"></a>03146           <span class="keywordflow">if</span> (is_attribute)
<a name="l03147"></a>03147             m &lt;&lt; <span class="stringliteral">&quot;&amp;quot;&quot;</span>;
<a name="l03148"></a>03148           <span class="keywordflow">else</span>
<a name="l03149"></a>03149             m &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span>;
<a name="l03150"></a>03150           <span class="keywordflow">break</span>;
<a name="l03151"></a>03151         <span class="keywordflow">default</span>:
<a name="l03152"></a>03152           <span class="keywordflow">if</span> (<a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a18cfed6b1b9d7aedd2c43129c7e46e95">IsValidXmlCharacter</a>(*src)) {
<a name="l03153"></a>03153             <span class="keywordflow">if</span> (is_attribute &amp;&amp; <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a3d910f5c6a752c629a276a8585640795">IsNormalizableWhitespace</a>(*src))
<a name="l03154"></a>03154               m &lt;&lt; <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;&amp;#x%02X;&quot;</span>, <span class="keywordtype">unsigned</span>(*src));
<a name="l03155"></a>03155             <span class="keywordflow">else</span>
<a name="l03156"></a>03156               m &lt;&lt; *src;
<a name="l03157"></a>03157           }
<a name="l03158"></a>03158           <span class="keywordflow">break</span>;
<a name="l03159"></a>03159       }
<a name="l03160"></a>03160     }
<a name="l03161"></a>03161   }
<a name="l03162"></a>03162 
<a name="l03163"></a>03163   <span class="keywordflow">return</span> m.GetString();
<a name="l03164"></a>03164 }
<a name="l03165"></a>03165 
<a name="l03166"></a>03166 <span class="comment">// Returns the given string with all characters invalid in XML removed.</span>
<a name="l03167"></a>03167 <span class="comment">// Currently invalid characters are dropped from the string. An</span>
<a name="l03168"></a>03168 <span class="comment">// alternative is to replace them with certain characters such as . or ?.</span>
<a name="l03169"></a>03169 <span class="keywordtype">string</span> <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#aa1a7bc460bd584676198c6fea285be17">XmlUnitTestResultPrinter::RemoveInvalidXmlCharacters</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str) {
<a name="l03170"></a>03170   <span class="keywordtype">string</span> <a class="code" href="../../d6/dc2/namespacegtest__output__test.html#acf316e258896197f4e917a6547e49532">output</a>;
<a name="l03171"></a>03171   output.reserve(str.size());
<a name="l03172"></a>03172   <span class="keywordflow">for</span> (string::const_iterator it = str.begin(); it != str.end(); ++it)
<a name="l03173"></a>03173     <span class="keywordflow">if</span> (<a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a18cfed6b1b9d7aedd2c43129c7e46e95">IsValidXmlCharacter</a>(*it))
<a name="l03174"></a>03174       output.push_back(*it);
<a name="l03175"></a>03175 
<a name="l03176"></a>03176   <span class="keywordflow">return</span> <a class="code" href="../../d6/dc2/namespacegtest__output__test.html#acf316e258896197f4e917a6547e49532">output</a>;
<a name="l03177"></a>03177 }
<a name="l03178"></a>03178 
<a name="l03179"></a>03179 <span class="comment">// The following routines generate an XML representation of a UnitTest</span>
<a name="l03180"></a>03180 <span class="comment">// object.</span>
<a name="l03181"></a>03181 <span class="comment">//</span>
<a name="l03182"></a>03182 <span class="comment">// This is how Google Test concepts map to the DTD:</span>
<a name="l03183"></a>03183 <span class="comment">//</span>
<a name="l03184"></a>03184 <span class="comment">// &lt;testsuites name=&quot;AllTests&quot;&gt;        &lt;-- corresponds to a UnitTest object</span>
<a name="l03185"></a>03185 <span class="comment">//   &lt;testsuite name=&quot;testcase-name&quot;&gt;  &lt;-- corresponds to a TestCase object</span>
<a name="l03186"></a>03186 <span class="comment">//     &lt;testcase name=&quot;test-name&quot;&gt;     &lt;-- corresponds to a TestInfo object</span>
<a name="l03187"></a>03187 <span class="comment">//       &lt;failure message=&quot;...&quot;&gt;...&lt;/failure&gt;</span>
<a name="l03188"></a>03188 <span class="comment">//       &lt;failure message=&quot;...&quot;&gt;...&lt;/failure&gt;</span>
<a name="l03189"></a>03189 <span class="comment">//       &lt;failure message=&quot;...&quot;&gt;...&lt;/failure&gt;</span>
<a name="l03190"></a>03190 <span class="comment">//                                     &lt;-- individual assertion failures</span>
<a name="l03191"></a>03191 <span class="comment">//     &lt;/testcase&gt;</span>
<a name="l03192"></a>03192 <span class="comment">//   &lt;/testsuite&gt;</span>
<a name="l03193"></a>03193 <span class="comment">// &lt;/testsuites&gt;</span>
<a name="l03194"></a>03194 
<a name="l03195"></a>03195 <span class="comment">// Formats the given time in milliseconds as seconds.</span>
<a name="l03196"></a>03196 <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9882e571372fc19a02d2b2949e1f1557">std::string</a> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5802d68a85d566a0c82a0df5fd2aa58b">FormatTimeInMillisAsSeconds</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9e0fb32f592d143f031a3431366adae0">TimeInMillis</a> ms) {
<a name="l03197"></a>03197   ::std::stringstream ss;
<a name="l03198"></a>03198   ss &lt;&lt; ms/1000.0;
<a name="l03199"></a>03199   <span class="keywordflow">return</span> ss.str();
<a name="l03200"></a>03200 }
<a name="l03201"></a>03201 
<a name="l03202"></a>03202 <span class="comment">// Streams an XML CDATA section, escaping invalid CDATA sequences as needed.</span>
<a name="l03203"></a>03203 <span class="keywordtype">void</span> <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#abe3b759db2f664b7f61500b785d9f2a4">XmlUnitTestResultPrinter::OutputXmlCDataSection</a>(::std::ostream* stream,
<a name="l03204"></a>03204                                                      <span class="keyword">const</span> <span class="keywordtype">char</span>* data) {
<a name="l03205"></a>03205   <span class="keyword">const</span> <span class="keywordtype">char</span>* segment = data;
<a name="l03206"></a>03206   *stream &lt;&lt; <span class="stringliteral">&quot;&lt;![CDATA[&quot;</span>;
<a name="l03207"></a>03207   <span class="keywordflow">for</span> (;;) {
<a name="l03208"></a>03208     <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> next_segment = strstr(segment, <span class="stringliteral">&quot;]]&gt;&quot;</span>);
<a name="l03209"></a>03209     <span class="keywordflow">if</span> (next_segment != NULL) {
<a name="l03210"></a>03210       stream-&gt;write(
<a name="l03211"></a>03211           segment, static_cast&lt;std::streamsize&gt;(next_segment - segment));
<a name="l03212"></a>03212       *stream &lt;&lt; <span class="stringliteral">&quot;]]&gt;]]&amp;gt;&lt;![CDATA[&quot;</span>;
<a name="l03213"></a>03213       segment = next_segment + strlen(<span class="stringliteral">&quot;]]&gt;&quot;</span>);
<a name="l03214"></a>03214     } <span class="keywordflow">else</span> {
<a name="l03215"></a>03215       *stream &lt;&lt; segment;
<a name="l03216"></a>03216       <span class="keywordflow">break</span>;
<a name="l03217"></a>03217     }
<a name="l03218"></a>03218   }
<a name="l03219"></a>03219   *stream &lt;&lt; <span class="stringliteral">&quot;]]&gt;&quot;</span>;
<a name="l03220"></a>03220 }
<a name="l03221"></a>03221 
<a name="l03222"></a>03222 <span class="comment">// Prints an XML representation of a TestInfo object.</span>
<a name="l03223"></a>03223 <span class="comment">// TODO(wan): There is also value in printing properties with the plain printer.</span>
<a name="l03224"></a>03224 <span class="keywordtype">void</span> <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a1385d3994e1daf7d80693bc6936e9853">XmlUnitTestResultPrinter::OutputXmlTestInfo</a>(::std::ostream* stream,
<a name="l03225"></a>03225                                                  <span class="keyword">const</span> <span class="keywordtype">char</span>* test_case_name,
<a name="l03226"></a>03226                                                  <span class="keyword">const</span> TestInfo&amp; test_info) {
<a name="l03227"></a>03227   <span class="keyword">const</span> TestResult&amp; result = *test_info.result();
<a name="l03228"></a>03228   *stream &lt;&lt; <span class="stringliteral">&quot;    &lt;testcase name=\&quot;&quot;</span>
<a name="l03229"></a>03229           &lt;&lt; <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a96cf735f70894f043d9f39f02bff8535">EscapeXmlAttribute</a>(test_info.name()).c_str() &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l03230"></a>03230 
<a name="l03231"></a>03231   <span class="keywordflow">if</span> (test_info.value_param() != NULL) {
<a name="l03232"></a>03232     *stream &lt;&lt; <span class="stringliteral">&quot; value_param=\&quot;&quot;</span> &lt;&lt; <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a96cf735f70894f043d9f39f02bff8535">EscapeXmlAttribute</a>(test_info.value_param())
<a name="l03233"></a>03233             &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l03234"></a>03234   }
<a name="l03235"></a>03235   <span class="keywordflow">if</span> (test_info.type_param() != NULL) {
<a name="l03236"></a>03236     *stream &lt;&lt; <span class="stringliteral">&quot; type_param=\&quot;&quot;</span> &lt;&lt; <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a96cf735f70894f043d9f39f02bff8535">EscapeXmlAttribute</a>(test_info.type_param())
<a name="l03237"></a>03237             &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l03238"></a>03238   }
<a name="l03239"></a>03239 
<a name="l03240"></a>03240   *stream &lt;&lt; <span class="stringliteral">&quot; status=\&quot;&quot;</span>
<a name="l03241"></a>03241           &lt;&lt; (test_info.should_run() ? <span class="stringliteral">&quot;run&quot;</span> : <span class="stringliteral">&quot;notrun&quot;</span>)
<a name="l03242"></a>03242           &lt;&lt; <span class="stringliteral">&quot;\&quot; time=\&quot;&quot;</span>
<a name="l03243"></a>03243           &lt;&lt; <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5802d68a85d566a0c82a0df5fd2aa58b">FormatTimeInMillisAsSeconds</a>(result.elapsed_time())
<a name="l03244"></a>03244           &lt;&lt; <span class="stringliteral">&quot;\&quot; classname=\&quot;&quot;</span> &lt;&lt; <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a96cf735f70894f043d9f39f02bff8535">EscapeXmlAttribute</a>(test_case_name).<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>()
<a name="l03245"></a>03245           &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span> &lt;&lt; <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a7a77c4bf230869f9376a667fa768c294">TestPropertiesAsXmlAttributes</a>(result).<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>();
<a name="l03246"></a>03246 
<a name="l03247"></a>03247   <span class="keywordtype">int</span> failures = 0;
<a name="l03248"></a>03248   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; result.total_part_count(); ++i) {
<a name="l03249"></a>03249     <span class="keyword">const</span> TestPartResult&amp; part = result.GetTestPartResult(i);
<a name="l03250"></a>03250     <span class="keywordflow">if</span> (part.failed()) {
<a name="l03251"></a>03251       <span class="keywordflow">if</span> (++failures == 1)
<a name="l03252"></a>03252         *stream &lt;&lt; <span class="stringliteral">&quot;&gt;\n&quot;</span>;
<a name="l03253"></a>03253       *stream &lt;&lt; <span class="stringliteral">&quot;      &lt;failure message=\&quot;&quot;</span>
<a name="l03254"></a>03254               &lt;&lt; <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a96cf735f70894f043d9f39f02bff8535">EscapeXmlAttribute</a>(part.summary()).c_str()
<a name="l03255"></a>03255               &lt;&lt; <span class="stringliteral">&quot;\&quot; type=\&quot;\&quot;&gt;&quot;</span>;
<a name="l03256"></a>03256       <span class="keyword">const</span> <span class="keywordtype">string</span> location = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae75f0742876f6d9ba86daf5603bf2448">internal::FormatCompilerIndependentFileLocation</a>(
<a name="l03257"></a>03257           part.file_name(), part.line_number());
<a name="l03258"></a>03258       <span class="keyword">const</span> <span class="keywordtype">string</span> message = location + <span class="stringliteral">&quot;\n&quot;</span> + part.message();
<a name="l03259"></a>03259       <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#abe3b759db2f664b7f61500b785d9f2a4">OutputXmlCDataSection</a>(stream,
<a name="l03260"></a>03260                             <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#aa1a7bc460bd584676198c6fea285be17">RemoveInvalidXmlCharacters</a>(message).c_str());
<a name="l03261"></a>03261       *stream &lt;&lt; <span class="stringliteral">&quot;&lt;/failure&gt;\n&quot;</span>;
<a name="l03262"></a>03262     }
<a name="l03263"></a>03263   }
<a name="l03264"></a>03264 
<a name="l03265"></a>03265   <span class="keywordflow">if</span> (failures == 0)
<a name="l03266"></a>03266     *stream &lt;&lt; <span class="stringliteral">&quot; /&gt;\n&quot;</span>;
<a name="l03267"></a>03267   <span class="keywordflow">else</span>
<a name="l03268"></a>03268     *stream &lt;&lt; <span class="stringliteral">&quot;    &lt;/testcase&gt;\n&quot;</span>;
<a name="l03269"></a>03269 }
<a name="l03270"></a>03270 
<a name="l03271"></a>03271 <span class="comment">// Prints an XML representation of a TestCase object</span>
<a name="l03272"></a>03272 <span class="keywordtype">void</span> <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a99988d51cbfd1b80223fa052c673395f">XmlUnitTestResultPrinter::PrintXmlTestCase</a>(FILE* out,
<a name="l03273"></a>03273                                                 <span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>&amp; test_case) {
<a name="l03274"></a>03274   fprintf(out,
<a name="l03275"></a>03275           <span class="stringliteral">&quot;  &lt;testsuite name=\&quot;%s\&quot; tests=\&quot;%d\&quot; failures=\&quot;%d\&quot; &quot;</span>
<a name="l03276"></a>03276           <span class="stringliteral">&quot;disabled=\&quot;%d\&quot; &quot;</span>,
<a name="l03277"></a>03277           <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a96cf735f70894f043d9f39f02bff8535">EscapeXmlAttribute</a>(test_case.name()).c_str(),
<a name="l03278"></a>03278           test_case.total_test_count(),
<a name="l03279"></a>03279           test_case.failed_test_count(),
<a name="l03280"></a>03280           test_case.disabled_test_count());
<a name="l03281"></a>03281   fprintf(out,
<a name="l03282"></a>03282           <span class="stringliteral">&quot;errors=\&quot;0\&quot; time=\&quot;%s\&quot;&gt;\n&quot;</span>,
<a name="l03283"></a>03283           <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5802d68a85d566a0c82a0df5fd2aa58b">FormatTimeInMillisAsSeconds</a>(test_case.elapsed_time()).c_str());
<a name="l03284"></a>03284   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; test_case.total_test_count(); ++i) {
<a name="l03285"></a>03285     ::std::stringstream stream;
<a name="l03286"></a>03286     <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a1385d3994e1daf7d80693bc6936e9853">OutputXmlTestInfo</a>(&amp;stream, test_case.name(), *test_case.GetTestInfo(i));
<a name="l03287"></a>03287     fprintf(out, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#abf99dee8db2ca5a9bc512dd6cc34f048">StringStreamToString</a>(&amp;stream).c_str());
<a name="l03288"></a>03288   }
<a name="l03289"></a>03289   fprintf(out, <span class="stringliteral">&quot;  &lt;/testsuite&gt;\n&quot;</span>);
<a name="l03290"></a>03290 }
<a name="l03291"></a>03291 
<a name="l03292"></a>03292 <span class="comment">// Prints an XML summary of unit_test to output stream out.</span>
<a name="l03293"></a>03293 <span class="keywordtype">void</span> <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#aec193026deaa7c08c5dd5a1ef7366c19">XmlUnitTestResultPrinter::PrintXmlUnitTest</a>(FILE* out,
<a name="l03294"></a>03294                                                 <span class="keyword">const</span> UnitTest&amp; unit_test) {
<a name="l03295"></a>03295   fprintf(out, <span class="stringliteral">&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;</span>);
<a name="l03296"></a>03296   fprintf(out,
<a name="l03297"></a>03297           <span class="stringliteral">&quot;&lt;testsuites tests=\&quot;%d\&quot; failures=\&quot;%d\&quot; disabled=\&quot;%d\&quot; &quot;</span>
<a name="l03298"></a>03298           <span class="stringliteral">&quot;errors=\&quot;0\&quot; time=\&quot;%s\&quot; &quot;</span>,
<a name="l03299"></a>03299           unit_test.total_test_count(),
<a name="l03300"></a>03300           unit_test.failed_test_count(),
<a name="l03301"></a>03301           unit_test.disabled_test_count(),
<a name="l03302"></a>03302           <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5802d68a85d566a0c82a0df5fd2aa58b">FormatTimeInMillisAsSeconds</a>(unit_test.elapsed_time()).c_str());
<a name="l03303"></a>03303   <span class="keywordflow">if</span> (<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(shuffle)) {
<a name="l03304"></a>03304     fprintf(out, <span class="stringliteral">&quot;random_seed=\&quot;%d\&quot; &quot;</span>, unit_test.random_seed());
<a name="l03305"></a>03305   }
<a name="l03306"></a>03306   fprintf(out, <span class="stringliteral">&quot;name=\&quot;AllTests\&quot;&gt;\n&quot;</span>);
<a name="l03307"></a>03307   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; unit_test.total_test_case_count(); ++i)
<a name="l03308"></a>03308     <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a99988d51cbfd1b80223fa052c673395f">PrintXmlTestCase</a>(out, *unit_test.GetTestCase(i));
<a name="l03309"></a>03309   fprintf(out, <span class="stringliteral">&quot;&lt;/testsuites&gt;\n&quot;</span>);
<a name="l03310"></a>03310 }
<a name="l03311"></a>03311 
<a name="l03312"></a>03312 <span class="comment">// Produces a string representing the test properties in a result as space</span>
<a name="l03313"></a>03313 <span class="comment">// delimited XML attributes based on the property key=&quot;value&quot; pairs.</span>
<a name="l03314"></a>03314 String <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a7a77c4bf230869f9376a667fa768c294">XmlUnitTestResultPrinter::TestPropertiesAsXmlAttributes</a>(
<a name="l03315"></a>03315     <span class="keyword">const</span> TestResult&amp; result) {
<a name="l03316"></a>03316   Message attributes;
<a name="l03317"></a>03317   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; result.test_property_count(); ++i) {
<a name="l03318"></a>03318     <span class="keyword">const</span> TestProperty&amp; <span class="keyword">property</span> = result.GetTestProperty(i);
<a name="l03319"></a>03319     attributes &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <span class="keyword">property</span>.key() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span>
<a name="l03320"></a>03320         &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span> &lt;&lt; <a class="code" href="../../d6/de5/classtesting_1_1internal_1_1XmlUnitTestResultPrinter.html#a96cf735f70894f043d9f39f02bff8535">EscapeXmlAttribute</a>(property.value()) &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l03321"></a>03321   }
<a name="l03322"></a>03322   <span class="keywordflow">return</span> attributes.GetString();
<a name="l03323"></a>03323 }
<a name="l03324"></a>03324 
<a name="l03325"></a>03325 <span class="comment">// End XmlUnitTestResultPrinter</span>
<a name="l03326"></a>03326 
<a name="l03327"></a>03327 <span class="preprocessor">#if GTEST_CAN_STREAM_RESULTS_</span>
<a name="l03328"></a>03328 <span class="preprocessor"></span>
<a name="l03329"></a>03329 <span class="comment">// Streams test results to the given port on the given host machine.</span>
<a name="l03330"></a>03330 <span class="keyword">class </span>StreamingListener : <span class="keyword">public</span> EmptyTestEventListener {
<a name="l03331"></a>03331  <span class="keyword">public</span>:
<a name="l03332"></a>03332   <span class="comment">// Escapes &#39;=&#39;, &#39;&amp;&#39;, &#39;%&#39;, and &#39;\n&#39; characters in str as &quot;%xx&quot;.</span>
<a name="l03333"></a>03333   <span class="keyword">static</span> <span class="keywordtype">string</span> UrlEncode(<span class="keyword">const</span> <span class="keywordtype">char</span>* str);
<a name="l03334"></a>03334 
<a name="l03335"></a>03335   StreamingListener(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; host, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; port)
<a name="l03336"></a>03336       : sockfd_(-1), host_name_(host), port_num_(port) {
<a name="l03337"></a>03337     MakeConnection();
<a name="l03338"></a>03338     Send(<span class="stringliteral">&quot;gtest_streaming_protocol_version=1.0\n&quot;</span>);
<a name="l03339"></a>03339   }
<a name="l03340"></a>03340 
<a name="l03341"></a>03341   <span class="keyword">virtual</span> ~StreamingListener() {
<a name="l03342"></a>03342     <span class="keywordflow">if</span> (sockfd_ != -1)
<a name="l03343"></a>03343       CloseConnection();
<a name="l03344"></a>03344   }
<a name="l03345"></a>03345 
<a name="l03346"></a>03346   <span class="keywordtype">void</span> OnTestProgramStart(<span class="keyword">const</span> UnitTest&amp; <span class="comment">/* unit_test */</span>) {
<a name="l03347"></a>03347     Send(<span class="stringliteral">&quot;event=TestProgramStart\n&quot;</span>);
<a name="l03348"></a>03348   }
<a name="l03349"></a>03349 
<a name="l03350"></a>03350   <span class="keywordtype">void</span> OnTestProgramEnd(<span class="keyword">const</span> UnitTest&amp; unit_test) {
<a name="l03351"></a>03351     <span class="comment">// Note that Google Test current only report elapsed time for each</span>
<a name="l03352"></a>03352     <span class="comment">// test iteration, not for the entire test program.</span>
<a name="l03353"></a>03353     Send(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;event=TestProgramEnd&amp;passed=%d\n&quot;</span>,
<a name="l03354"></a>03354                         unit_test.Passed()));
<a name="l03355"></a>03355 
<a name="l03356"></a>03356     <span class="comment">// Notify the streaming server to stop.</span>
<a name="l03357"></a>03357     CloseConnection();
<a name="l03358"></a>03358   }
<a name="l03359"></a>03359 
<a name="l03360"></a>03360   <span class="keywordtype">void</span> OnTestIterationStart(<span class="keyword">const</span> UnitTest&amp; <span class="comment">/* unit_test */</span>, <span class="keywordtype">int</span> iteration) {
<a name="l03361"></a>03361     Send(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;event=TestIterationStart&amp;iteration=%d\n&quot;</span>,
<a name="l03362"></a>03362                         iteration));
<a name="l03363"></a>03363   }
<a name="l03364"></a>03364 
<a name="l03365"></a>03365   <span class="keywordtype">void</span> OnTestIterationEnd(<span class="keyword">const</span> UnitTest&amp; unit_test, <span class="keywordtype">int</span> <span class="comment">/* iteration */</span>) {
<a name="l03366"></a>03366     Send(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;event=TestIterationEnd&amp;passed=%d&amp;elapsed_time=%sms\n&quot;</span>,
<a name="l03367"></a>03367                         unit_test.Passed(),
<a name="l03368"></a>03368                         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a66c1c8bcb19e8562b79bd8ef9bab2aa9">StreamableToString</a>(unit_test.elapsed_time()).c_str()));
<a name="l03369"></a>03369   }
<a name="l03370"></a>03370 
<a name="l03371"></a>03371   <span class="keywordtype">void</span> OnTestCaseStart(<span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>&amp; test_case) {
<a name="l03372"></a>03372     Send(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;event=TestCaseStart&amp;name=%s\n&quot;</span>, test_case.name()));
<a name="l03373"></a>03373   }
<a name="l03374"></a>03374 
<a name="l03375"></a>03375   <span class="keywordtype">void</span> OnTestCaseEnd(<span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>&amp; test_case) {
<a name="l03376"></a>03376     Send(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;event=TestCaseEnd&amp;passed=%d&amp;elapsed_time=%sms\n&quot;</span>,
<a name="l03377"></a>03377                         test_case.Passed(),
<a name="l03378"></a>03378                         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a66c1c8bcb19e8562b79bd8ef9bab2aa9">StreamableToString</a>(test_case.elapsed_time()).c_str()));
<a name="l03379"></a>03379   }
<a name="l03380"></a>03380 
<a name="l03381"></a>03381   <span class="keywordtype">void</span> OnTestStart(<span class="keyword">const</span> TestInfo&amp; test_info) {
<a name="l03382"></a>03382     Send(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;event=TestStart&amp;name=%s\n&quot;</span>, test_info.name()));
<a name="l03383"></a>03383   }
<a name="l03384"></a>03384 
<a name="l03385"></a>03385   <span class="keywordtype">void</span> OnTestEnd(<span class="keyword">const</span> TestInfo&amp; test_info) {
<a name="l03386"></a>03386     Send(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(
<a name="l03387"></a>03387         <span class="stringliteral">&quot;event=TestEnd&amp;passed=%d&amp;elapsed_time=%sms\n&quot;</span>,
<a name="l03388"></a>03388         (test_info.result())-&gt;Passed(),
<a name="l03389"></a>03389         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a66c1c8bcb19e8562b79bd8ef9bab2aa9">StreamableToString</a>((test_info.result())-&gt;elapsed_time()).c_str()));
<a name="l03390"></a>03390   }
<a name="l03391"></a>03391 
<a name="l03392"></a>03392   <span class="keywordtype">void</span> OnTestPartResult(<span class="keyword">const</span> TestPartResult&amp; test_part_result) {
<a name="l03393"></a>03393     <span class="keyword">const</span> <span class="keywordtype">char</span>* file_name = test_part_result.file_name();
<a name="l03394"></a>03394     <span class="keywordflow">if</span> (file_name == NULL)
<a name="l03395"></a>03395       file_name = <span class="stringliteral">&quot;&quot;</span>;
<a name="l03396"></a>03396     Send(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;event=TestPartResult&amp;file=%s&amp;line=%d&amp;message=&quot;</span>,
<a name="l03397"></a>03397                         UrlEncode(file_name).c_str(),
<a name="l03398"></a>03398                         test_part_result.line_number()));
<a name="l03399"></a>03399     Send(UrlEncode(test_part_result.message()) + <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03400"></a>03400   }
<a name="l03401"></a>03401 
<a name="l03402"></a>03402  <span class="keyword">private</span>:
<a name="l03403"></a>03403   <span class="comment">// Creates a client socket and connects to the server.</span>
<a name="l03404"></a>03404   <span class="keywordtype">void</span> MakeConnection();
<a name="l03405"></a>03405 
<a name="l03406"></a>03406   <span class="comment">// Closes the socket.</span>
<a name="l03407"></a>03407   <span class="keywordtype">void</span> CloseConnection() {
<a name="l03408"></a>03408     <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#ab54343f0a36dc4cb0ce8a478dd7847b8">GTEST_CHECK_</a>(sockfd_ != -1)
<a name="l03409"></a>03409         &lt;&lt; <span class="stringliteral">&quot;CloseConnection() can be called only when there is a connection.&quot;</span>;
<a name="l03410"></a>03410 
<a name="l03411"></a>03411     close(sockfd_);
<a name="l03412"></a>03412     sockfd_ = -1;
<a name="l03413"></a>03413   }
<a name="l03414"></a>03414 
<a name="l03415"></a>03415   <span class="comment">// Sends a string to the socket.</span>
<a name="l03416"></a>03416   <span class="keywordtype">void</span> Send(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; message) {
<a name="l03417"></a>03417     <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#ab54343f0a36dc4cb0ce8a478dd7847b8">GTEST_CHECK_</a>(sockfd_ != -1)
<a name="l03418"></a>03418         &lt;&lt; <span class="stringliteral">&quot;Send() can be called only when there is a connection.&quot;</span>;
<a name="l03419"></a>03419 
<a name="l03420"></a>03420     <span class="keyword">const</span> <span class="keywordtype">int</span> len = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(message.length());
<a name="l03421"></a>03421     <span class="keywordflow">if</span> (write(sockfd_, message.c_str(), len) != len) {
<a name="l03422"></a>03422       <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a8ef4cb4c465db8c15464aecc6d9510ef">GTEST_LOG_</a>(WARNING)
<a name="l03423"></a>03423           &lt;&lt; <span class="stringliteral">&quot;stream_result_to: failed to stream to &quot;</span>
<a name="l03424"></a>03424           &lt;&lt; host_name_ &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; port_num_;
<a name="l03425"></a>03425     }
<a name="l03426"></a>03426   }
<a name="l03427"></a>03427 
<a name="l03428"></a>03428   <span class="keywordtype">int</span> sockfd_;   <span class="comment">// socket file descriptor</span>
<a name="l03429"></a>03429   <span class="keyword">const</span> <span class="keywordtype">string</span> host_name_;
<a name="l03430"></a>03430   <span class="keyword">const</span> <span class="keywordtype">string</span> port_num_;
<a name="l03431"></a>03431 
<a name="l03432"></a>03432   <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(StreamingListener);
<a name="l03433"></a>03433 };  <span class="comment">// class StreamingListener</span>
<a name="l03434"></a>03434 
<a name="l03435"></a>03435 <span class="comment">// Checks if str contains &#39;=&#39;, &#39;&amp;&#39;, &#39;%&#39; or &#39;\n&#39; characters. If yes,</span>
<a name="l03436"></a>03436 <span class="comment">// replaces them by &quot;%xx&quot; where xx is their hexadecimal value. For</span>
<a name="l03437"></a>03437 <span class="comment">// example, replaces &quot;=&quot; with &quot;%3D&quot;.  This algorithm is O(strlen(str))</span>
<a name="l03438"></a>03438 <span class="comment">// in both time and space -- important as the input str may contain an</span>
<a name="l03439"></a>03439 <span class="comment">// arbitrarily long test failure message and stack trace.</span>
<a name="l03440"></a>03440 <span class="keywordtype">string</span> StreamingListener::UrlEncode(<span class="keyword">const</span> <span class="keywordtype">char</span>* str) {
<a name="l03441"></a>03441   <span class="keywordtype">string</span> result;
<a name="l03442"></a>03442   result.reserve(strlen(str) + 1);
<a name="l03443"></a>03443   <span class="keywordflow">for</span> (<span class="keywordtype">char</span> ch = *str; ch != <span class="charliteral">&#39;\0&#39;</span>; ch = *++str) {
<a name="l03444"></a>03444     <span class="keywordflow">switch</span> (ch) {
<a name="l03445"></a>03445       <span class="keywordflow">case</span> <span class="charliteral">&#39;%&#39;</span>:
<a name="l03446"></a>03446       <span class="keywordflow">case</span> <span class="charliteral">&#39;=&#39;</span>:
<a name="l03447"></a>03447       <span class="keywordflow">case</span> <span class="charliteral">&#39;&amp;&#39;</span>:
<a name="l03448"></a>03448       <span class="keywordflow">case</span> <span class="charliteral">&#39;\n&#39;</span>:
<a name="l03449"></a>03449         result.append(<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;%%%02x&quot;</span>, static_cast&lt;unsigned char&gt;(ch)));
<a name="l03450"></a>03450         <span class="keywordflow">break</span>;
<a name="l03451"></a>03451       <span class="keywordflow">default</span>:
<a name="l03452"></a>03452         result.push_back(ch);
<a name="l03453"></a>03453         <span class="keywordflow">break</span>;
<a name="l03454"></a>03454     }
<a name="l03455"></a>03455   }
<a name="l03456"></a>03456   <span class="keywordflow">return</span> result;
<a name="l03457"></a>03457 }
<a name="l03458"></a>03458 
<a name="l03459"></a>03459 <span class="keywordtype">void</span> StreamingListener::MakeConnection() {
<a name="l03460"></a>03460   <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#ab54343f0a36dc4cb0ce8a478dd7847b8">GTEST_CHECK_</a>(sockfd_ == -1)
<a name="l03461"></a>03461       &lt;&lt; <span class="stringliteral">&quot;MakeConnection() can&#39;t be called when there is already a connection.&quot;</span>;
<a name="l03462"></a>03462 
<a name="l03463"></a>03463   addrinfo hints;
<a name="l03464"></a>03464   memset(&amp;hints, 0, <span class="keyword">sizeof</span>(hints));
<a name="l03465"></a>03465   hints.ai_family = AF_UNSPEC;    <span class="comment">// To allow both IPv4 and IPv6 addresses.</span>
<a name="l03466"></a>03466   hints.ai_socktype = SOCK_STREAM;
<a name="l03467"></a>03467   addrinfo* servinfo = NULL;
<a name="l03468"></a>03468 
<a name="l03469"></a>03469   <span class="comment">// Use the getaddrinfo() to get a linked list of IP addresses for</span>
<a name="l03470"></a>03470   <span class="comment">// the given host name.</span>
<a name="l03471"></a>03471   <span class="keyword">const</span> <span class="keywordtype">int</span> error_num = getaddrinfo(
<a name="l03472"></a>03472       host_name_.c_str(), port_num_.c_str(), &amp;hints, &amp;servinfo);
<a name="l03473"></a>03473   <span class="keywordflow">if</span> (error_num != 0) {
<a name="l03474"></a>03474     <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a8ef4cb4c465db8c15464aecc6d9510ef">GTEST_LOG_</a>(WARNING) &lt;&lt; <span class="stringliteral">&quot;stream_result_to: getaddrinfo() failed: &quot;</span>
<a name="l03475"></a>03475                         &lt;&lt; gai_strerror(error_num);
<a name="l03476"></a>03476   }
<a name="l03477"></a>03477 
<a name="l03478"></a>03478   <span class="comment">// Loop through all the results and connect to the first we can.</span>
<a name="l03479"></a>03479   <span class="keywordflow">for</span> (addrinfo* cur_addr = servinfo; sockfd_ == -1 &amp;&amp; cur_addr != NULL;
<a name="l03480"></a>03480        cur_addr = cur_addr-&gt;ai_next) {
<a name="l03481"></a>03481     sockfd_ = socket(
<a name="l03482"></a>03482         cur_addr-&gt;ai_family, cur_addr-&gt;ai_socktype, cur_addr-&gt;ai_protocol);
<a name="l03483"></a>03483     <span class="keywordflow">if</span> (sockfd_ != -1) {
<a name="l03484"></a>03484       <span class="comment">// Connect the client socket to the server socket.</span>
<a name="l03485"></a>03485       <span class="keywordflow">if</span> (connect(sockfd_, cur_addr-&gt;ai_addr, cur_addr-&gt;ai_addrlen) == -1) {
<a name="l03486"></a>03486         close(sockfd_);
<a name="l03487"></a>03487         sockfd_ = -1;
<a name="l03488"></a>03488       }
<a name="l03489"></a>03489     }
<a name="l03490"></a>03490   }
<a name="l03491"></a>03491 
<a name="l03492"></a>03492   freeaddrinfo(servinfo);  <span class="comment">// all done with this structure</span>
<a name="l03493"></a>03493 
<a name="l03494"></a>03494   <span class="keywordflow">if</span> (sockfd_ == -1) {
<a name="l03495"></a>03495     <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a8ef4cb4c465db8c15464aecc6d9510ef">GTEST_LOG_</a>(WARNING) &lt;&lt; <span class="stringliteral">&quot;stream_result_to: failed to connect to &quot;</span>
<a name="l03496"></a>03496                         &lt;&lt; host_name_ &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; port_num_;
<a name="l03497"></a>03497   }
<a name="l03498"></a>03498 }
<a name="l03499"></a>03499 
<a name="l03500"></a>03500 <span class="comment">// End of class Streaming Listener</span>
<a name="l03501"></a>03501 <span class="preprocessor">#endif  // GTEST_CAN_STREAM_RESULTS__</span>
<a name="l03502"></a>03502 <span class="preprocessor"></span>
<a name="l03503"></a>03503 <span class="comment">// Class ScopedTrace</span>
<a name="l03504"></a>03504 
<a name="l03505"></a>03505 <span class="comment">// Pushes the given source file location and message onto a per-thread</span>
<a name="l03506"></a>03506 <span class="comment">// trace stack maintained by Google Test.</span>
<a name="l03507"></a>03507 <span class="comment">// L &lt; UnitTest::mutex_</span>
<a name="l03508"></a>03508 <a class="code" href="../../d8/d68/classtesting_1_1internal_1_1ScopedTrace.html#a4c2fc42261af156212deb572aab8e88b">ScopedTrace::ScopedTrace</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* file, <span class="keywordtype">int</span> line, <span class="keyword">const</span> Message&amp; message) {
<a name="l03509"></a>03509   TraceInfo trace;
<a name="l03510"></a>03510   trace.file = file;
<a name="l03511"></a>03511   trace.line = line;
<a name="l03512"></a>03512   trace.message = message.GetString();
<a name="l03513"></a>03513 
<a name="l03514"></a>03514   <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#ad200090b11104aca39f25043701886cf">UnitTest::GetInstance</a>()-&gt;<a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a5ea77a45b0cd359476236407bff9bb51">PushGTestTrace</a>(trace);
<a name="l03515"></a>03515 }
<a name="l03516"></a>03516 
<a name="l03517"></a>03517 <span class="comment">// Pops the info pushed by the c&#39;tor.</span>
<a name="l03518"></a>03518 <span class="comment">// L &lt; UnitTest::mutex_</span>
<a name="l03519"></a>03519 <a class="code" href="../../d8/d68/classtesting_1_1internal_1_1ScopedTrace.html#a0bd652af94f27e7d9b40cf9369df948c">ScopedTrace::~ScopedTrace</a>() {
<a name="l03520"></a>03520   <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#ad200090b11104aca39f25043701886cf">UnitTest::GetInstance</a>()-&gt;<a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a89acfaaaf4015731b91b26fd8a6f0887">PopGTestTrace</a>();
<a name="l03521"></a>03521 }
<a name="l03522"></a>03522 
<a name="l03523"></a>03523 
<a name="l03524"></a>03524 <span class="comment">// class OsStackTraceGetter</span>
<a name="l03525"></a>03525 
<a name="l03526"></a>03526 <span class="comment">// Returns the current OS stack trace as a String.  Parameters:</span>
<a name="l03527"></a>03527 <span class="comment">//</span>
<a name="l03528"></a>03528 <span class="comment">//   max_depth  - the maximum number of stack frames to be included</span>
<a name="l03529"></a>03529 <span class="comment">//                in the trace.</span>
<a name="l03530"></a>03530 <span class="comment">//   skip_count - the number of top frames to be skipped; doesn&#39;t count</span>
<a name="l03531"></a>03531 <span class="comment">//                against max_depth.</span>
<a name="l03532"></a>03532 <span class="comment">//</span>
<a name="l03533"></a>03533 <span class="comment">// L &lt; mutex_</span>
<a name="l03534"></a>03534 <span class="comment">// We use &quot;L &lt; mutex_&quot; to denote that the function may acquire mutex_.</span>
<a name="l03535"></a>03535 String <a class="code" href="../../df/de4/classtesting_1_1internal_1_1OsStackTraceGetter.html#aaa023d94e63f7975bfbe9ca54a9acd07">OsStackTraceGetter::CurrentStackTrace</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>) {
<a name="l03536"></a>03536   <span class="keywordflow">return</span> String(<span class="stringliteral">&quot;&quot;</span>);
<a name="l03537"></a>03537 }
<a name="l03538"></a>03538 
<a name="l03539"></a>03539 <span class="comment">// L &lt; mutex_</span>
<a name="l03540"></a>03540 <span class="keywordtype">void</span> <a class="code" href="../../df/de4/classtesting_1_1internal_1_1OsStackTraceGetter.html#aa97e532da98f524272b1256f018c0f07">OsStackTraceGetter::UponLeavingGTest</a>() {
<a name="l03541"></a>03541 }
<a name="l03542"></a>03542 
<a name="l03543"></a>03543 <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>
<a name="l03544"></a>03544 <a class="code" href="../../df/de4/classtesting_1_1internal_1_1OsStackTraceGetter.html#adf15738d11421bb96e42bd0baa4ab1cd">OsStackTraceGetter::kElidedFramesMarker</a> =
<a name="l03545"></a>03545     <span class="stringliteral">&quot;... &quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a13d98c217176bd8722c395b9225fc19d">GTEST_NAME_</a> <span class="stringliteral">&quot; internal frames ...&quot;</span>;
<a name="l03546"></a>03546 
<a name="l03547"></a>03547 }  <span class="comment">// namespace internal</span>
<a name="l03548"></a>03548 
<a name="l03549"></a>03549 <span class="comment">// class TestEventListeners</span>
<a name="l03550"></a>03550 
<a name="l03551"></a>03551 <a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#a0d220264f48a921da04205ae52f77dcc">TestEventListeners::TestEventListeners</a>()
<a name="l03552"></a>03552     : repeater_(new internal::TestEventRepeater()),
<a name="l03553"></a>03553       default_result_printer_(NULL),
<a name="l03554"></a>03554       default_xml_generator_(NULL) {
<a name="l03555"></a>03555 }
<a name="l03556"></a>03556 
<a name="l03557"></a>03557 <a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#a64868cfad376fa452e2f5d27c3a7c37d">TestEventListeners::~TestEventListeners</a>() { <span class="keyword">delete</span> repeater_; }
<a name="l03558"></a>03558 
<a name="l03559"></a>03559 <span class="comment">// Returns the standard listener responsible for the default console</span>
<a name="l03560"></a>03560 <span class="comment">// output.  Can be removed from the listeners list to shut down default</span>
<a name="l03561"></a>03561 <span class="comment">// console output.  Note that removing this object from the listener list</span>
<a name="l03562"></a>03562 <span class="comment">// with Release transfers its ownership to the user.</span>
<a name="l03563"></a>03563 <span class="keywordtype">void</span> <a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#ad98bf37c3296d62b69659734cb6c7cf8">TestEventListeners::Append</a>(TestEventListener* listener) {
<a name="l03564"></a>03564   repeater_-&gt;Append(listener);
<a name="l03565"></a>03565 }
<a name="l03566"></a>03566 
<a name="l03567"></a>03567 <span class="comment">// Removes the given event listener from the list and returns it.  It then</span>
<a name="l03568"></a>03568 <span class="comment">// becomes the caller&#39;s responsibility to delete the listener. Returns</span>
<a name="l03569"></a>03569 <span class="comment">// NULL if the listener is not found in the list.</span>
<a name="l03570"></a>03570 TestEventListener* <a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#aac8fdc5e2ed8269a0c227dd554b00d27">TestEventListeners::Release</a>(TestEventListener* listener) {
<a name="l03571"></a>03571   <span class="keywordflow">if</span> (listener == default_result_printer_)
<a name="l03572"></a>03572     default_result_printer_ = NULL;
<a name="l03573"></a>03573   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (listener == default_xml_generator_)
<a name="l03574"></a>03574     default_xml_generator_ = NULL;
<a name="l03575"></a>03575   <span class="keywordflow">return</span> repeater_-&gt;Release(listener);
<a name="l03576"></a>03576 }
<a name="l03577"></a>03577 
<a name="l03578"></a>03578 <span class="comment">// Returns repeater that broadcasts the TestEventListener events to all</span>
<a name="l03579"></a>03579 <span class="comment">// subscribers.</span>
<a name="l03580"></a>03580 TestEventListener* <a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#af7cfacdf90b4ba59566c16d95ee5d6cc">TestEventListeners::repeater</a>() { <span class="keywordflow">return</span> repeater_; }
<a name="l03581"></a>03581 
<a name="l03582"></a>03582 <span class="comment">// Sets the default_result_printer attribute to the provided listener.</span>
<a name="l03583"></a>03583 <span class="comment">// The listener is also added to the listener list and previous</span>
<a name="l03584"></a>03584 <span class="comment">// default_result_printer is removed from it and deleted. The listener can</span>
<a name="l03585"></a>03585 <span class="comment">// also be NULL in which case it will not be added to the list. Does</span>
<a name="l03586"></a>03586 <span class="comment">// nothing if the previous and the current listener objects are the same.</span>
<a name="l03587"></a>03587 <span class="keywordtype">void</span> <a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#a961d3f9b9dabd19bef6758afe2f6f814">TestEventListeners::SetDefaultResultPrinter</a>(TestEventListener* listener) {
<a name="l03588"></a>03588   <span class="keywordflow">if</span> (default_result_printer_ != listener) {
<a name="l03589"></a>03589     <span class="comment">// It is an error to pass this method a listener that is already in the</span>
<a name="l03590"></a>03590     <span class="comment">// list.</span>
<a name="l03591"></a>03591     <span class="keyword">delete</span> Release(default_result_printer_);
<a name="l03592"></a>03592     default_result_printer_ = listener;
<a name="l03593"></a>03593     <span class="keywordflow">if</span> (listener != NULL)
<a name="l03594"></a>03594       Append(listener);
<a name="l03595"></a>03595   }
<a name="l03596"></a>03596 }
<a name="l03597"></a>03597 
<a name="l03598"></a>03598 <span class="comment">// Sets the default_xml_generator attribute to the provided listener.  The</span>
<a name="l03599"></a>03599 <span class="comment">// listener is also added to the listener list and previous</span>
<a name="l03600"></a>03600 <span class="comment">// default_xml_generator is removed from it and deleted. The listener can</span>
<a name="l03601"></a>03601 <span class="comment">// also be NULL in which case it will not be added to the list. Does</span>
<a name="l03602"></a>03602 <span class="comment">// nothing if the previous and the current listener objects are the same.</span>
<a name="l03603"></a>03603 <span class="keywordtype">void</span> <a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#a1e86c96ef131392c2b0bd302f16fb735">TestEventListeners::SetDefaultXmlGenerator</a>(TestEventListener* listener) {
<a name="l03604"></a>03604   <span class="keywordflow">if</span> (default_xml_generator_ != listener) {
<a name="l03605"></a>03605     <span class="comment">// It is an error to pass this method a listener that is already in the</span>
<a name="l03606"></a>03606     <span class="comment">// list.</span>
<a name="l03607"></a>03607     <span class="keyword">delete</span> Release(default_xml_generator_);
<a name="l03608"></a>03608     default_xml_generator_ = listener;
<a name="l03609"></a>03609     <span class="keywordflow">if</span> (listener != NULL)
<a name="l03610"></a>03610       Append(listener);
<a name="l03611"></a>03611   }
<a name="l03612"></a>03612 }
<a name="l03613"></a>03613 
<a name="l03614"></a>03614 <span class="comment">// Controls whether events will be forwarded by the repeater to the</span>
<a name="l03615"></a>03615 <span class="comment">// listeners in the list.</span>
<a name="l03616"></a>03616 <span class="keywordtype">bool</span> <a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#acb09364f2ea34dec945e6cf378b03ac8">TestEventListeners::EventForwardingEnabled</a>()<span class="keyword"> const </span>{
<a name="l03617"></a>03617   <span class="keywordflow">return</span> repeater_-&gt;forwarding_enabled();
<a name="l03618"></a>03618 }
<a name="l03619"></a>03619 
<a name="l03620"></a>03620 <span class="keywordtype">void</span> <a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#ac2231ac2b553e0f6a1cc2923224b9623">TestEventListeners::SuppressEventForwarding</a>() {
<a name="l03621"></a>03621   repeater_-&gt;set_forwarding_enabled(<span class="keyword">false</span>);
<a name="l03622"></a>03622 }
<a name="l03623"></a>03623 
<a name="l03624"></a>03624 <span class="comment">// class UnitTest</span>
<a name="l03625"></a>03625 
<a name="l03626"></a>03626 <span class="comment">// Gets the singleton UnitTest object.  The first time this method is</span>
<a name="l03627"></a>03627 <span class="comment">// called, a UnitTest object is constructed and returned.  Consecutive</span>
<a name="l03628"></a>03628 <span class="comment">// calls will return the same object.</span>
<a name="l03629"></a>03629 <span class="comment">//</span>
<a name="l03630"></a>03630 <span class="comment">// We don&#39;t protect this under mutex_ as a user is not supposed to</span>
<a name="l03631"></a>03631 <span class="comment">// call this before main() starts, from which point on the return</span>
<a name="l03632"></a>03632 <span class="comment">// value will never change.</span>
<a name="l03633"></a>03633 UnitTest * <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#ad200090b11104aca39f25043701886cf">UnitTest::GetInstance</a>() {
<a name="l03634"></a>03634   <span class="comment">// When compiled with MSVC 7.1 in optimized mode, destroying the</span>
<a name="l03635"></a>03635   <span class="comment">// UnitTest object upon exiting the program messes up the exit code,</span>
<a name="l03636"></a>03636   <span class="comment">// causing successful tests to appear failed.  We have to use a</span>
<a name="l03637"></a>03637   <span class="comment">// different implementation in this case to bypass the compiler bug.</span>
<a name="l03638"></a>03638   <span class="comment">// This implementation makes the compiler happy, at the cost of</span>
<a name="l03639"></a>03639   <span class="comment">// leaking the UnitTest object.</span>
<a name="l03640"></a>03640 
<a name="l03641"></a>03641   <span class="comment">// CodeGear C++Builder insists on a public destructor for the</span>
<a name="l03642"></a>03642   <span class="comment">// default implementation.  Use this implementation to keep good OO</span>
<a name="l03643"></a>03643   <span class="comment">// design with private destructor.</span>
<a name="l03644"></a>03644 
<a name="l03645"></a>03645 <span class="preprocessor">#if (_MSC_VER == 1310 &amp;&amp; !defined(_DEBUG)) || defined(__BORLANDC__)</span>
<a name="l03646"></a>03646 <span class="preprocessor"></span>  <span class="keyword">static</span> UnitTest* <span class="keyword">const</span> instance = <span class="keyword">new</span> UnitTest;
<a name="l03647"></a>03647   <span class="keywordflow">return</span> instance;
<a name="l03648"></a>03648 <span class="preprocessor">#else</span>
<a name="l03649"></a>03649 <span class="preprocessor"></span>  <span class="keyword">static</span> UnitTest instance;
<a name="l03650"></a>03650   <span class="keywordflow">return</span> &amp;instance;
<a name="l03651"></a>03651 <span class="preprocessor">#endif  // (_MSC_VER == 1310 &amp;&amp; !defined(_DEBUG)) || defined(__BORLANDC__)</span>
<a name="l03652"></a>03652 <span class="preprocessor"></span>}
<a name="l03653"></a>03653 
<a name="l03654"></a>03654 <span class="comment">// Gets the number of successful test cases.</span>
<a name="l03655"></a>03655 <span class="keywordtype">int</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a846de5ff509b207bca6a55237d035a1f">UnitTest::successful_test_case_count</a>()<span class="keyword"> const </span>{
<a name="l03656"></a>03656   <span class="keywordflow">return</span> impl()-&gt;successful_test_case_count();
<a name="l03657"></a>03657 }
<a name="l03658"></a>03658 
<a name="l03659"></a>03659 <span class="comment">// Gets the number of failed test cases.</span>
<a name="l03660"></a>03660 <span class="keywordtype">int</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a48f76adebf95bff36f0026f0a66c7057">UnitTest::failed_test_case_count</a>()<span class="keyword"> const </span>{
<a name="l03661"></a>03661   <span class="keywordflow">return</span> impl()-&gt;failed_test_case_count();
<a name="l03662"></a>03662 }
<a name="l03663"></a>03663 
<a name="l03664"></a>03664 <span class="comment">// Gets the number of all test cases.</span>
<a name="l03665"></a>03665 <span class="keywordtype">int</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#aba8c18261c58f301e1e80049a0781d84">UnitTest::total_test_case_count</a>()<span class="keyword"> const </span>{
<a name="l03666"></a>03666   <span class="keywordflow">return</span> impl()-&gt;total_test_case_count();
<a name="l03667"></a>03667 }
<a name="l03668"></a>03668 
<a name="l03669"></a>03669 <span class="comment">// Gets the number of all test cases that contain at least one test</span>
<a name="l03670"></a>03670 <span class="comment">// that should run.</span>
<a name="l03671"></a>03671 <span class="keywordtype">int</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#adf212bae576e88dfb77bd114f01bc117">UnitTest::test_case_to_run_count</a>()<span class="keyword"> const </span>{
<a name="l03672"></a>03672   <span class="keywordflow">return</span> impl()-&gt;test_case_to_run_count();
<a name="l03673"></a>03673 }
<a name="l03674"></a>03674 
<a name="l03675"></a>03675 <span class="comment">// Gets the number of successful tests.</span>
<a name="l03676"></a>03676 <span class="keywordtype">int</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#ab955f67bc1fe8ef62a7e72906ccece2a">UnitTest::successful_test_count</a>()<span class="keyword"> const </span>{
<a name="l03677"></a>03677   <span class="keywordflow">return</span> impl()-&gt;successful_test_count();
<a name="l03678"></a>03678 }
<a name="l03679"></a>03679 
<a name="l03680"></a>03680 <span class="comment">// Gets the number of failed tests.</span>
<a name="l03681"></a>03681 <span class="keywordtype">int</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#afd8bbd35c7ee99960abb321cfdff3119">UnitTest::failed_test_count</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> impl()-&gt;failed_test_count(); }
<a name="l03682"></a>03682 
<a name="l03683"></a>03683 <span class="comment">// Gets the number of disabled tests.</span>
<a name="l03684"></a>03684 <span class="keywordtype">int</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a10ec677118627074973fc20c9271b204">UnitTest::disabled_test_count</a>()<span class="keyword"> const </span>{
<a name="l03685"></a>03685   <span class="keywordflow">return</span> impl()-&gt;disabled_test_count();
<a name="l03686"></a>03686 }
<a name="l03687"></a>03687 
<a name="l03688"></a>03688 <span class="comment">// Gets the number of all tests.</span>
<a name="l03689"></a>03689 <span class="keywordtype">int</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a0eb7286957aeb126d9926c33407a15a3">UnitTest::total_test_count</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> impl()-&gt;total_test_count(); }
<a name="l03690"></a>03690 
<a name="l03691"></a>03691 <span class="comment">// Gets the number of tests that should run.</span>
<a name="l03692"></a>03692 <span class="keywordtype">int</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#aa6eccf86072f4f8ddd0bea30dfd45912">UnitTest::test_to_run_count</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> impl()-&gt;test_to_run_count(); }
<a name="l03693"></a>03693 
<a name="l03694"></a>03694 <span class="comment">// Gets the elapsed time, in milliseconds.</span>
<a name="l03695"></a>03695 <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9e0fb32f592d143f031a3431366adae0">internal::TimeInMillis</a> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a10ad329997f481d3f6af8ff075dacf76">UnitTest::elapsed_time</a>()<span class="keyword"> const </span>{
<a name="l03696"></a>03696   <span class="keywordflow">return</span> impl()-&gt;elapsed_time();
<a name="l03697"></a>03697 }
<a name="l03698"></a>03698 
<a name="l03699"></a>03699 <span class="comment">// Returns true iff the unit test passed (i.e. all test cases passed).</span>
<a name="l03700"></a>03700 <span class="keywordtype">bool</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#ac97d5073365af8a73262fd9f6bf18656">UnitTest::Passed</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> impl()-&gt;Passed(); }
<a name="l03701"></a>03701 
<a name="l03702"></a>03702 <span class="comment">// Returns true iff the unit test failed (i.e. some test case failed</span>
<a name="l03703"></a>03703 <span class="comment">// or something outside of all tests failed).</span>
<a name="l03704"></a>03704 <span class="keywordtype">bool</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a7cf078354304c964c1934f53bf2bb4d7">UnitTest::Failed</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> impl()-&gt;Failed(); }
<a name="l03705"></a>03705 
<a name="l03706"></a>03706 <span class="comment">// Gets the i-th test case among all the test cases. i can range from 0 to</span>
<a name="l03707"></a>03707 <span class="comment">// total_test_case_count() - 1. If i is not in that range, returns NULL.</span>
<a name="l03708"></a>03708 <span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>* <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a20fd6bc6d3cb5467f228ce22997455b1">UnitTest::GetTestCase</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{
<a name="l03709"></a>03709   <span class="keywordflow">return</span> impl()-&gt;GetTestCase(i);
<a name="l03710"></a>03710 }
<a name="l03711"></a>03711 
<a name="l03712"></a>03712 <span class="comment">// Gets the i-th test case among all the test cases. i can range from 0 to</span>
<a name="l03713"></a>03713 <span class="comment">// total_test_case_count() - 1. If i is not in that range, returns NULL.</span>
<a name="l03714"></a>03714 <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>* <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#aed9ba9977fbd9b36e14b42fe9d72bfed">UnitTest::GetMutableTestCase</a>(<span class="keywordtype">int</span> i) {
<a name="l03715"></a>03715   <span class="keywordflow">return</span> impl()-&gt;GetMutableTestCase(i);
<a name="l03716"></a>03716 }
<a name="l03717"></a>03717 
<a name="l03718"></a>03718 <span class="comment">// Returns the list of event listeners that can be used to track events</span>
<a name="l03719"></a>03719 <span class="comment">// inside Google Test.</span>
<a name="l03720"></a>03720 TestEventListeners&amp; <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#aeb82a98c4da4afafa5b68547c8ac380a">UnitTest::listeners</a>() {
<a name="l03721"></a>03721   <span class="keywordflow">return</span> *impl()-&gt;listeners();
<a name="l03722"></a>03722 }
<a name="l03723"></a>03723 
<a name="l03724"></a>03724 <span class="comment">// Registers and returns a global test environment.  When a test</span>
<a name="l03725"></a>03725 <span class="comment">// program is run, all global test environments will be set-up in the</span>
<a name="l03726"></a>03726 <span class="comment">// order they were registered.  After all tests in the program have</span>
<a name="l03727"></a>03727 <span class="comment">// finished, all global test environments will be torn-down in the</span>
<a name="l03728"></a>03728 <span class="comment">// *reverse* order they were registered.</span>
<a name="l03729"></a>03729 <span class="comment">//</span>
<a name="l03730"></a>03730 <span class="comment">// The UnitTest object takes ownership of the given environment.</span>
<a name="l03731"></a>03731 <span class="comment">//</span>
<a name="l03732"></a>03732 <span class="comment">// We don&#39;t protect this under mutex_, as we only support calling it</span>
<a name="l03733"></a>03733 <span class="comment">// from the main thread.</span>
<a name="l03734"></a>03734 Environment* <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a615f6515c254c5ddda5f695e25da3da3">UnitTest::AddEnvironment</a>(Environment* env) {
<a name="l03735"></a>03735   <span class="keywordflow">if</span> (env == NULL) {
<a name="l03736"></a>03736     <span class="keywordflow">return</span> NULL;
<a name="l03737"></a>03737   }
<a name="l03738"></a>03738 
<a name="l03739"></a>03739   impl_-&gt;environments().push_back(env);
<a name="l03740"></a>03740   <span class="keywordflow">return</span> env;
<a name="l03741"></a>03741 }
<a name="l03742"></a>03742 
<a name="l03743"></a>03743 <span class="comment">// Adds a TestPartResult to the current TestResult object.  All Google Test</span>
<a name="l03744"></a>03744 <span class="comment">// assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc) eventually call</span>
<a name="l03745"></a>03745 <span class="comment">// this to report their results.  The user code should use the</span>
<a name="l03746"></a>03746 <span class="comment">// assertion macros instead of calling this directly.</span>
<a name="l03747"></a>03747 <span class="comment">// L &lt; mutex_</span>
<a name="l03748"></a>03748 <span class="keywordtype">void</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a4b89ae9b48ae834488a0831f0bd19e80">UnitTest::AddTestPartResult</a>(<a class="code" href="../../d9/d98/classtesting_1_1TestPartResult.html#a1d1cfd8ffb84e947f82999c682b666a7">TestPartResult::Type</a> result_type,
<a name="l03749"></a>03749                                  <span class="keyword">const</span> <span class="keywordtype">char</span>* file_name,
<a name="l03750"></a>03750                                  <span class="keywordtype">int</span> line_number,
<a name="l03751"></a>03751                                  <span class="keyword">const</span> internal::String&amp; message,
<a name="l03752"></a>03752                                  <span class="keyword">const</span> internal::String&amp; os_stack_trace) {
<a name="l03753"></a>03753   Message msg;
<a name="l03754"></a>03754   msg &lt;&lt; <a class="code" href="../../d6/dc2/namespacegtest__output__test.html#a536593b2a92b75b5c370d337feb4f615">message</a>;
<a name="l03755"></a>03755 
<a name="l03756"></a>03756   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0ceb93bd27638edfa3ced2469951fd99">internal::MutexLock</a> lock(&amp;mutex_);
<a name="l03757"></a>03757   <span class="keywordflow">if</span> (impl_-&gt;gtest_trace_stack().size() &gt; 0) {
<a name="l03758"></a>03758     msg &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a13d98c217176bd8722c395b9225fc19d">GTEST_NAME_</a> &lt;&lt; <span class="stringliteral">&quot; trace:&quot;</span>;
<a name="l03759"></a>03759 
<a name="l03760"></a>03760     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = static_cast&lt;int&gt;(impl_-&gt;gtest_trace_stack().size());
<a name="l03761"></a>03761          i &gt; 0; --i) {
<a name="l03762"></a>03762       <span class="keyword">const</span> internal::TraceInfo&amp; trace = impl_-&gt;gtest_trace_stack()[i - 1];
<a name="l03763"></a>03763       msg &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a6264f0605b7d7d0609eae663c58662c0">internal::FormatFileLocation</a>(trace.file, trace.line)
<a name="l03764"></a>03764           &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; trace.message;
<a name="l03765"></a>03765     }
<a name="l03766"></a>03766   }
<a name="l03767"></a>03767 
<a name="l03768"></a>03768   <span class="keywordflow">if</span> (os_stack_trace.c_str() != NULL &amp;&amp; !os_stack_trace.empty()) {
<a name="l03769"></a>03769     msg &lt;&lt; <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a735beafdf3dc508442f783a0269ca0f5">internal::kStackTraceMarker</a> &lt;&lt; os_stack_trace;
<a name="l03770"></a>03770   }
<a name="l03771"></a>03771 
<a name="l03772"></a>03772   <span class="keyword">const</span> TestPartResult result =
<a name="l03773"></a>03773     TestPartResult(result_type, file_name, line_number,
<a name="l03774"></a>03774                    msg.GetString().c_str());
<a name="l03775"></a>03775   impl_-&gt;GetTestPartResultReporterForCurrentThread()-&gt;
<a name="l03776"></a>03776       ReportTestPartResult(result);
<a name="l03777"></a>03777 
<a name="l03778"></a>03778   <span class="keywordflow">if</span> (result_type != <a class="code" href="../../d9/d98/classtesting_1_1TestPartResult.html#a1d1cfd8ffb84e947f82999c682b666a7a266017ca395108407d14b7be595574c1">TestPartResult::kSuccess</a>) {
<a name="l03779"></a>03779     <span class="comment">// gtest_break_on_failure takes precedence over</span>
<a name="l03780"></a>03780     <span class="comment">// gtest_throw_on_failure.  This allows a user to set the latter</span>
<a name="l03781"></a>03781     <span class="comment">// in the code (perhaps in order to use Google Test assertions</span>
<a name="l03782"></a>03782     <span class="comment">// with another testing framework) and specify the former on the</span>
<a name="l03783"></a>03783     <span class="comment">// command line for debugging.</span>
<a name="l03784"></a>03784     <span class="keywordflow">if</span> (<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(break_on_failure)) {
<a name="l03785"></a>03785 <span class="preprocessor">#if GTEST_OS_WINDOWS</span>
<a name="l03786"></a>03786 <span class="preprocessor"></span>      <span class="comment">// Using DebugBreak on Windows allows gtest to still break into a debugger</span>
<a name="l03787"></a>03787       <span class="comment">// when a failure happens and both the --gtest_break_on_failure and</span>
<a name="l03788"></a>03788       <span class="comment">// the --gtest_catch_exceptions flags are specified.</span>
<a name="l03789"></a>03789       DebugBreak();
<a name="l03790"></a>03790 <span class="preprocessor">#else</span>
<a name="l03791"></a>03791 <span class="preprocessor"></span>      <span class="comment">// Dereference NULL through a volatile pointer to prevent the compiler</span>
<a name="l03792"></a>03792       <span class="comment">// from removing. We use this rather than abort() or __builtin_trap() for</span>
<a name="l03793"></a>03793       <span class="comment">// portability: Symbian doesn&#39;t implement abort() well, and some debuggers</span>
<a name="l03794"></a>03794       <span class="comment">// don&#39;t correctly trap abort().</span>
<a name="l03795"></a>03795       *<span class="keyword">static_cast&lt;</span><span class="keyword">volatile </span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(NULL) = 1;
<a name="l03796"></a>03796 <span class="preprocessor">#endif  // GTEST_OS_WINDOWS</span>
<a name="l03797"></a>03797 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(throw_on_failure)) {
<a name="l03798"></a>03798 <span class="preprocessor">#if GTEST_HAS_EXCEPTIONS</span>
<a name="l03799"></a>03799 <span class="preprocessor"></span>      <span class="keywordflow">throw</span> GoogleTestFailureException(result);
<a name="l03800"></a>03800 <span class="preprocessor">#else</span>
<a name="l03801"></a>03801 <span class="preprocessor"></span>      <span class="comment">// We cannot call abort() as it generates a pop-up in debug mode</span>
<a name="l03802"></a>03802       <span class="comment">// that cannot be suppressed in VC 7.1 or below.</span>
<a name="l03803"></a>03803       exit(1);
<a name="l03804"></a>03804 <span class="preprocessor">#endif</span>
<a name="l03805"></a>03805 <span class="preprocessor"></span>    }
<a name="l03806"></a>03806   }
<a name="l03807"></a>03807 }
<a name="l03808"></a>03808 
<a name="l03809"></a>03809 <span class="comment">// Creates and adds a property to the current TestResult. If a property matching</span>
<a name="l03810"></a>03810 <span class="comment">// the supplied value already exists, updates its value instead.</span>
<a name="l03811"></a>03811 <span class="keywordtype">void</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#aa7b2e142a716c9c6653a6f35a722ec9e">UnitTest::RecordPropertyForCurrentTest</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* key,
<a name="l03812"></a>03812                                             <span class="keyword">const</span> <span class="keywordtype">char</span>* value) {
<a name="l03813"></a>03813   <span class="keyword">const</span> TestProperty test_property(key, value);
<a name="l03814"></a>03814   impl_-&gt;current_test_result()-&gt;RecordProperty(test_property);
<a name="l03815"></a>03815 }
<a name="l03816"></a>03816 
<a name="l03817"></a>03817 <span class="comment">// Runs all tests in this UnitTest object and prints the result.</span>
<a name="l03818"></a>03818 <span class="comment">// Returns 0 if successful, or 1 otherwise.</span>
<a name="l03819"></a>03819 <span class="comment">//</span>
<a name="l03820"></a>03820 <span class="comment">// We don&#39;t protect this under mutex_, as we only support calling it</span>
<a name="l03821"></a>03821 <span class="comment">// from the main thread.</span>
<a name="l03822"></a>03822 <span class="keywordtype">int</span> <a class="code" href="../../d2/dcc/namespacegtest__break__on__failure__unittest.html#ae784214748d2010e70d5519ce618af5f">UnitTest::Run</a>() {
<a name="l03823"></a>03823   <span class="comment">// Captures the value of GTEST_FLAG(catch_exceptions).  This value will be</span>
<a name="l03824"></a>03824   <span class="comment">// used for the duration of the program.</span>
<a name="l03825"></a>03825   impl()-&gt;set_catch_exceptions(<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(catch_exceptions));
<a name="l03826"></a>03826 
<a name="l03827"></a>03827 <span class="preprocessor">#if GTEST_HAS_SEH</span>
<a name="l03828"></a>03828 <span class="preprocessor"></span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> in_death_test_child_process =
<a name="l03829"></a>03829       <a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">internal::GTEST_FLAG</a>(internal_run_death_test).length() &gt; 0;
<a name="l03830"></a>03830 
<a name="l03831"></a>03831   <span class="comment">// Either the user wants Google Test to catch exceptions thrown by the</span>
<a name="l03832"></a>03832   <span class="comment">// tests or this is executing in the context of death test child</span>
<a name="l03833"></a>03833   <span class="comment">// process. In either case the user does not want to see pop-up dialogs</span>
<a name="l03834"></a>03834   <span class="comment">// about crashes - they are expected.</span>
<a name="l03835"></a>03835   <span class="keywordflow">if</span> (impl()-&gt;catch_exceptions() || in_death_test_child_process) {
<a name="l03836"></a>03836 
<a name="l03837"></a>03837 <span class="preprocessor"># if !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l03838"></a>03838 <span class="preprocessor"></span>    <span class="comment">// SetErrorMode doesn&#39;t exist on CE.</span>
<a name="l03839"></a>03839     SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |
<a name="l03840"></a>03840                  SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);
<a name="l03841"></a>03841 <span class="preprocessor"># endif  // !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l03842"></a>03842 <span class="preprocessor"></span>
<a name="l03843"></a>03843 <span class="preprocessor"># if (defined(_MSC_VER) || GTEST_OS_WINDOWS_MINGW) &amp;&amp; !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l03844"></a>03844 <span class="preprocessor"></span>    <span class="comment">// Death test children can be terminated with _abort().  On Windows,</span>
<a name="l03845"></a>03845     <span class="comment">// _abort() can show a dialog with a warning message.  This forces the</span>
<a name="l03846"></a>03846     <span class="comment">// abort message to go to stderr instead.</span>
<a name="l03847"></a>03847     _set_error_mode(_OUT_TO_STDERR);
<a name="l03848"></a>03848 <span class="preprocessor"># endif</span>
<a name="l03849"></a>03849 <span class="preprocessor"></span>
<a name="l03850"></a>03850 <span class="preprocessor"># if _MSC_VER &gt;= 1400 &amp;&amp; !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l03851"></a>03851 <span class="preprocessor"></span>    <span class="comment">// In the debug version, Visual Studio pops up a separate dialog</span>
<a name="l03852"></a>03852     <span class="comment">// offering a choice to debug the aborted program. We need to suppress</span>
<a name="l03853"></a>03853     <span class="comment">// this dialog or it will pop up for every EXPECT/ASSERT_DEATH statement</span>
<a name="l03854"></a>03854     <span class="comment">// executed. Google Test will notify the user of any unexpected</span>
<a name="l03855"></a>03855     <span class="comment">// failure via stderr.</span>
<a name="l03856"></a>03856     <span class="comment">//</span>
<a name="l03857"></a>03857     <span class="comment">// VC++ doesn&#39;t define _set_abort_behavior() prior to the version 8.0.</span>
<a name="l03858"></a>03858     <span class="comment">// Users of prior VC versions shall suffer the agony and pain of</span>
<a name="l03859"></a>03859     <span class="comment">// clicking through the countless debug dialogs.</span>
<a name="l03860"></a>03860     <span class="comment">// TODO(vladl@google.com): find a way to suppress the abort dialog() in the</span>
<a name="l03861"></a>03861     <span class="comment">// debug mode when compiled with VC 7.1 or lower.</span>
<a name="l03862"></a>03862     <span class="keywordflow">if</span> (!<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(break_on_failure))
<a name="l03863"></a>03863       _set_abort_behavior(
<a name="l03864"></a>03864           0x0,                                    <span class="comment">// Clear the following flags:</span>
<a name="l03865"></a>03865           _WRITE_ABORT_MSG | _CALL_REPORTFAULT);  <span class="comment">// pop-up window, core dump.</span>
<a name="l03866"></a>03866 <span class="preprocessor"># endif</span>
<a name="l03867"></a>03867 <span class="preprocessor"></span>
<a name="l03868"></a>03868   }
<a name="l03869"></a>03869 <span class="preprocessor">#endif  // GTEST_HAS_SEH</span>
<a name="l03870"></a>03870 <span class="preprocessor"></span>
<a name="l03871"></a>03871   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0034a1799f52bef77bb3b810af8b8969">internal::HandleExceptionsInMethodIfSupported</a>(
<a name="l03872"></a>03872       impl(),
<a name="l03873"></a>03873       &amp;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a4d5d6a2e8fa3b918a284252602a98279">internal::UnitTestImpl::RunAllTests</a>,
<a name="l03874"></a>03874       <span class="stringliteral">&quot;auxiliary test code (environments or event listeners)&quot;</span>) ? 0 : 1;
<a name="l03875"></a>03875 }
<a name="l03876"></a>03876 
<a name="l03877"></a>03877 <span class="comment">// Returns the working directory when the first TEST() or TEST_F() was</span>
<a name="l03878"></a>03878 <span class="comment">// executed.</span>
<a name="l03879"></a>03879 <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#aadc59d7d9d4cabd496a37c2362d70fb8">UnitTest::original_working_dir</a>()<span class="keyword"> const </span>{
<a name="l03880"></a>03880   <span class="keywordflow">return</span> impl_-&gt;original_working_dir_.c_str();
<a name="l03881"></a>03881 }
<a name="l03882"></a>03882 
<a name="l03883"></a>03883 <span class="comment">// Returns the TestCase object for the test that&#39;s currently running,</span>
<a name="l03884"></a>03884 <span class="comment">// or NULL if no test is running.</span>
<a name="l03885"></a>03885 <span class="comment">// L &lt; mutex_</span>
<a name="l03886"></a>03886 <span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>* <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a6091b91bf1da1f3994b62bad39d5eb18">UnitTest::current_test_case</a>()<span class="keyword"> const </span>{
<a name="l03887"></a>03887   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0ceb93bd27638edfa3ced2469951fd99">internal::MutexLock</a> lock(&amp;mutex_);
<a name="l03888"></a>03888   <span class="keywordflow">return</span> impl_-&gt;current_test_case();
<a name="l03889"></a>03889 }
<a name="l03890"></a>03890 
<a name="l03891"></a>03891 <span class="comment">// Returns the TestInfo object for the test that&#39;s currently running,</span>
<a name="l03892"></a>03892 <span class="comment">// or NULL if no test is running.</span>
<a name="l03893"></a>03893 <span class="comment">// L &lt; mutex_</span>
<a name="l03894"></a>03894 <span class="keyword">const</span> TestInfo* <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a1c2bc6c2c4b47028c19b32ecc625d121">UnitTest::current_test_info</a>()<span class="keyword"> const </span>{
<a name="l03895"></a>03895   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0ceb93bd27638edfa3ced2469951fd99">internal::MutexLock</a> lock(&amp;mutex_);
<a name="l03896"></a>03896   <span class="keywordflow">return</span> impl_-&gt;current_test_info();
<a name="l03897"></a>03897 }
<a name="l03898"></a>03898 
<a name="l03899"></a>03899 <span class="comment">// Returns the random seed used at the start of the current test run.</span>
<a name="l03900"></a>03900 <span class="keywordtype">int</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#ac0bcee84bdc839bfabd0a829642ab4f7">UnitTest::random_seed</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> impl_-&gt;random_seed(); }
<a name="l03901"></a>03901 
<a name="l03902"></a>03902 <span class="preprocessor">#if GTEST_HAS_PARAM_TEST</span>
<a name="l03903"></a>03903 <span class="preprocessor"></span><span class="comment">// Returns ParameterizedTestCaseRegistry object used to keep track of</span>
<a name="l03904"></a>03904 <span class="comment">// value-parameterized tests and instantiate and register them.</span>
<a name="l03905"></a>03905 <span class="comment">// L &lt; mutex_</span>
<a name="l03906"></a>03906 internal::ParameterizedTestCaseRegistry&amp;
<a name="l03907"></a>03907     <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a01cbd3cb2a5d607047f5f433fac08f40">UnitTest::parameterized_test_registry</a>() {
<a name="l03908"></a>03908   <span class="keywordflow">return</span> impl_-&gt;parameterized_test_registry();
<a name="l03909"></a>03909 }
<a name="l03910"></a>03910 <span class="preprocessor">#endif  // GTEST_HAS_PARAM_TEST</span>
<a name="l03911"></a>03911 <span class="preprocessor"></span>
<a name="l03912"></a>03912 <span class="comment">// Creates an empty UnitTest.</span>
<a name="l03913"></a>03913 <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a3c5dacde37a0ec6c0bf79322f7e355ed">UnitTest::UnitTest</a>() {
<a name="l03914"></a>03914   impl_ = <span class="keyword">new</span> internal::UnitTestImpl(<span class="keyword">this</span>);
<a name="l03915"></a>03915 }
<a name="l03916"></a>03916 
<a name="l03917"></a>03917 <span class="comment">// Destructor of UnitTest.</span>
<a name="l03918"></a>03918 <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a103aeda10e620c4427e2196b705bb64b">UnitTest::~UnitTest</a>() {
<a name="l03919"></a>03919   <span class="keyword">delete</span> impl_;
<a name="l03920"></a>03920 }
<a name="l03921"></a>03921 
<a name="l03922"></a>03922 <span class="comment">// Pushes a trace defined by SCOPED_TRACE() on to the per-thread</span>
<a name="l03923"></a>03923 <span class="comment">// Google Test trace stack.</span>
<a name="l03924"></a>03924 <span class="comment">// L &lt; mutex_</span>
<a name="l03925"></a>03925 <span class="keywordtype">void</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a5ea77a45b0cd359476236407bff9bb51">UnitTest::PushGTestTrace</a>(<span class="keyword">const</span> internal::TraceInfo&amp; trace) {
<a name="l03926"></a>03926   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0ceb93bd27638edfa3ced2469951fd99">internal::MutexLock</a> lock(&amp;mutex_);
<a name="l03927"></a>03927   impl_-&gt;gtest_trace_stack().push_back(trace);
<a name="l03928"></a>03928 }
<a name="l03929"></a>03929 
<a name="l03930"></a>03930 <span class="comment">// Pops a trace from the per-thread Google Test trace stack.</span>
<a name="l03931"></a>03931 <span class="comment">// L &lt; mutex_</span>
<a name="l03932"></a>03932 <span class="keywordtype">void</span> <a class="code" href="../../d5/d21/classtesting_1_1UnitTest.html#a89acfaaaf4015731b91b26fd8a6f0887">UnitTest::PopGTestTrace</a>() {
<a name="l03933"></a>03933   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0ceb93bd27638edfa3ced2469951fd99">internal::MutexLock</a> lock(&amp;mutex_);
<a name="l03934"></a>03934   impl_-&gt;gtest_trace_stack().pop_back();
<a name="l03935"></a>03935 }
<a name="l03936"></a>03936 
<a name="l03937"></a>03937 <span class="keyword">namespace </span>internal {
<a name="l03938"></a>03938 
<a name="l03939"></a>03939 <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#aee362cac8540779d6b2287bd44f15444">UnitTestImpl::UnitTestImpl</a>(UnitTest* parent)
<a name="l03940"></a>03940     : parent_(parent),
<a name="l03941"></a>03941 #ifdef _MSC_VER
<a name="l03942"></a>03942 # pragma warning(push)                    <span class="comment">// Saves the current warning state.</span>
<a name="l03943"></a>03943 # pragma warning(disable:4355)            <span class="comment">// Temporarily disables warning 4355</span>
<a name="l03944"></a>03944                                          <span class="comment">// (using this in initializer).</span>
<a name="l03945"></a>03945       default_global_test_part_result_reporter_(this),
<a name="l03946"></a>03946       default_per_thread_test_part_result_reporter_(this),
<a name="l03947"></a>03947 # pragma warning(pop)                     <span class="comment">// Restores the warning state again.</span>
<a name="l03948"></a>03948 #else
<a name="l03949"></a>03949       default_global_test_part_result_reporter_(this),
<a name="l03950"></a>03950       default_per_thread_test_part_result_reporter_(this),
<a name="l03951"></a>03951 #endif  <span class="comment">// _MSC_VER</span>
<a name="l03952"></a>03952       global_test_part_result_repoter_(
<a name="l03953"></a>03953           &amp;default_global_test_part_result_reporter_),
<a name="l03954"></a>03954       per_thread_test_part_result_reporter_(
<a name="l03955"></a>03955           &amp;default_per_thread_test_part_result_reporter_),
<a name="l03956"></a>03956 #if <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a743ee591e0b9a044e3d7513ad5ab5ef9">GTEST_HAS_PARAM_TEST</a>
<a name="l03957"></a>03957       parameterized_test_registry_(),
<a name="l03958"></a>03958       parameterized_tests_registered_(false),
<a name="l03959"></a>03959 #endif  <span class="comment">// GTEST_HAS_PARAM_TEST</span>
<a name="l03960"></a>03960       last_death_test_case_(-1),
<a name="l03961"></a>03961       current_test_case_(NULL),
<a name="l03962"></a>03962       current_test_info_(NULL),
<a name="l03963"></a>03963       ad_hoc_test_result_(),
<a name="l03964"></a>03964       os_stack_trace_getter_(NULL),
<a name="l03965"></a>03965       post_flag_parse_init_performed_(false),
<a name="l03966"></a>03966       random_seed_(0),  <span class="comment">// Will be overridden by the flag before first use.</span>
<a name="l03967"></a>03967       random_(0),  <span class="comment">// Will be reseeded before first use.</span>
<a name="l03968"></a>03968       elapsed_time_(0),
<a name="l03969"></a>03969 #if GTEST_HAS_DEATH_TEST
<a name="l03970"></a>03970       internal_run_death_test_flag_(NULL),
<a name="l03971"></a>03971       death_test_factory_(new DefaultDeathTestFactory),
<a name="l03972"></a>03972 #endif
<a name="l03973"></a>03973       <span class="comment">// Will be overridden by the flag before first use.</span>
<a name="l03974"></a>03974       catch_exceptions_(false) {
<a name="l03975"></a>03975   listeners()-&gt;SetDefaultResultPrinter(<span class="keyword">new</span> PrettyUnitTestResultPrinter);
<a name="l03976"></a>03976 }
<a name="l03977"></a>03977 
<a name="l03978"></a>03978 <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a1cfa956ff0bfca1d1830454d0dd02f41">UnitTestImpl::~UnitTestImpl</a>() {
<a name="l03979"></a>03979   <span class="comment">// Deletes every TestCase.</span>
<a name="l03980"></a>03980   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af699259a2b1e5e06250ed075b735b1f6">ForEach</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>, internal::Delete&lt;TestCase&gt;);
<a name="l03981"></a>03981 
<a name="l03982"></a>03982   <span class="comment">// Deletes every Environment.</span>
<a name="l03983"></a>03983   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af699259a2b1e5e06250ed075b735b1f6">ForEach</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a3887eb0491f4d2221cd010aff0e9c4b6">environments_</a>, internal::Delete&lt;Environment&gt;);
<a name="l03984"></a>03984 
<a name="l03985"></a>03985   <span class="keyword">delete</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a03a75f27d552174a5ba8f477f3f4f116">os_stack_trace_getter_</a>;
<a name="l03986"></a>03986 }
<a name="l03987"></a>03987 
<a name="l03988"></a>03988 <span class="preprocessor">#if GTEST_HAS_DEATH_TEST</span>
<a name="l03989"></a>03989 <span class="preprocessor"></span><span class="comment">// Disables event forwarding if the control is currently in a death test</span>
<a name="l03990"></a>03990 <span class="comment">// subprocess. Must not be called before InitGoogleTest.</span>
<a name="l03991"></a>03991 <span class="keywordtype">void</span> UnitTestImpl::SuppressTestEventsIfInSubprocess() {
<a name="l03992"></a>03992   <span class="keywordflow">if</span> (internal_run_death_test_flag_.get() != NULL)
<a name="l03993"></a>03993     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a371c481b63deeb0ecd47f42b4720480b">listeners</a>()-&gt;<a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#ac2231ac2b553e0f6a1cc2923224b9623">SuppressEventForwarding</a>();
<a name="l03994"></a>03994 }
<a name="l03995"></a>03995 <span class="preprocessor">#endif  // GTEST_HAS_DEATH_TEST</span>
<a name="l03996"></a>03996 <span class="preprocessor"></span>
<a name="l03997"></a>03997 <span class="comment">// Initializes event listeners performing XML output as specified by</span>
<a name="l03998"></a>03998 <span class="comment">// UnitTestOptions. Must not be called before InitGoogleTest.</span>
<a name="l03999"></a>03999 <span class="keywordtype">void</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#acc7d69fbca3370bbdd13ee2b63576030">UnitTestImpl::ConfigureXmlOutput</a>() {
<a name="l04000"></a>04000   <span class="keyword">const</span> String&amp; output_format = <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#ab74136cb3ba94d7dbbda58ac081d9da2">UnitTestOptions::GetOutputFormat</a>();
<a name="l04001"></a>04001   <span class="keywordflow">if</span> (output_format == <span class="stringliteral">&quot;xml&quot;</span>) {
<a name="l04002"></a>04002     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a371c481b63deeb0ecd47f42b4720480b">listeners</a>()-&gt;<a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#a1e86c96ef131392c2b0bd302f16fb735">SetDefaultXmlGenerator</a>(<span class="keyword">new</span> XmlUnitTestResultPrinter(
<a name="l04003"></a>04003         <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a765b1715a62bfdb0eaa4063b516dbc84">UnitTestOptions::GetAbsolutePathToOutputFile</a>().c_str()));
<a name="l04004"></a>04004   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (output_format != <span class="stringliteral">&quot;&quot;</span>) {
<a name="l04005"></a>04005     printf(<span class="stringliteral">&quot;WARNING: unrecognized output format \&quot;%s\&quot; ignored.\n&quot;</span>,
<a name="l04006"></a>04006            output_format.c_str());
<a name="l04007"></a>04007     fflush(stdout);
<a name="l04008"></a>04008   }
<a name="l04009"></a>04009 }
<a name="l04010"></a>04010 
<a name="l04011"></a>04011 <span class="preprocessor">#if GTEST_CAN_STREAM_RESULTS_</span>
<a name="l04012"></a>04012 <span class="preprocessor"></span><span class="comment">// Initializes event listeners for streaming test results in String form.</span>
<a name="l04013"></a>04013 <span class="comment">// Must not be called before InitGoogleTest.</span>
<a name="l04014"></a>04014 <span class="keywordtype">void</span> UnitTestImpl::ConfigureStreamingOutput() {
<a name="l04015"></a>04015   <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; target = <a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(stream_result_to);
<a name="l04016"></a>04016   <span class="keywordflow">if</span> (!target.empty()) {
<a name="l04017"></a>04017     <span class="keyword">const</span> <span class="keywordtype">size_t</span> pos = target.find(<span class="charliteral">&#39;:&#39;</span>);
<a name="l04018"></a>04018     <span class="keywordflow">if</span> (pos != string::npos) {
<a name="l04019"></a>04019       <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a371c481b63deeb0ecd47f42b4720480b">listeners</a>()-&gt;<a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#ad98bf37c3296d62b69659734cb6c7cf8">Append</a>(<span class="keyword">new</span> StreamingListener(target.substr(0, pos),
<a name="l04020"></a>04020                                                 target.substr(pos+1)));
<a name="l04021"></a>04021     } <span class="keywordflow">else</span> {
<a name="l04022"></a>04022       printf(<span class="stringliteral">&quot;WARNING: unrecognized streaming target \&quot;%s\&quot; ignored.\n&quot;</span>,
<a name="l04023"></a>04023              target.c_str());
<a name="l04024"></a>04024       fflush(stdout);
<a name="l04025"></a>04025     }
<a name="l04026"></a>04026   }
<a name="l04027"></a>04027 }
<a name="l04028"></a>04028 <span class="preprocessor">#endif  // GTEST_CAN_STREAM_RESULTS_</span>
<a name="l04029"></a>04029 <span class="preprocessor"></span>
<a name="l04030"></a>04030 <span class="comment">// Performs initialization dependent upon flag values obtained in</span>
<a name="l04031"></a>04031 <span class="comment">// ParseGoogleTestFlagsOnly.  Is called from InitGoogleTest after the call to</span>
<a name="l04032"></a>04032 <span class="comment">// ParseGoogleTestFlagsOnly.  In case a user neglects to call InitGoogleTest</span>
<a name="l04033"></a>04033 <span class="comment">// this function is also called from RunAllTests.  Since this function can be</span>
<a name="l04034"></a>04034 <span class="comment">// called more than once, it has to be idempotent.</span>
<a name="l04035"></a>04035 <span class="keywordtype">void</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a3d68c6d1fdec822210f96171a3b57b47">UnitTestImpl::PostFlagParsingInit</a>() {
<a name="l04036"></a>04036   <span class="comment">// Ensures that this function does not execute more than once.</span>
<a name="l04037"></a>04037   <span class="keywordflow">if</span> (!<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#af27b4c10f54dbf7cf61814bd71e2f71d">post_flag_parse_init_performed_</a>) {
<a name="l04038"></a>04038     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#af27b4c10f54dbf7cf61814bd71e2f71d">post_flag_parse_init_performed_</a> = <span class="keyword">true</span>;
<a name="l04039"></a>04039 
<a name="l04040"></a>04040 <span class="preprocessor">#if GTEST_HAS_DEATH_TEST</span>
<a name="l04041"></a>04041 <span class="preprocessor"></span>    InitDeathTestSubprocessControlInfo();
<a name="l04042"></a>04042     SuppressTestEventsIfInSubprocess();
<a name="l04043"></a>04043 <span class="preprocessor">#endif  // GTEST_HAS_DEATH_TEST</span>
<a name="l04044"></a>04044 <span class="preprocessor"></span>
<a name="l04045"></a>04045     <span class="comment">// Registers parameterized tests. This makes parameterized tests</span>
<a name="l04046"></a>04046     <span class="comment">// available to the UnitTest reflection API without running</span>
<a name="l04047"></a>04047     <span class="comment">// RUN_ALL_TESTS.</span>
<a name="l04048"></a>04048     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a42dd6cc650b930bbf73f665fbb13d515">RegisterParameterizedTests</a>();
<a name="l04049"></a>04049 
<a name="l04050"></a>04050     <span class="comment">// Configures listeners for XML output. This makes it possible for users</span>
<a name="l04051"></a>04051     <span class="comment">// to shut down the default XML output before invoking RUN_ALL_TESTS.</span>
<a name="l04052"></a>04052     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#acc7d69fbca3370bbdd13ee2b63576030">ConfigureXmlOutput</a>();
<a name="l04053"></a>04053 
<a name="l04054"></a>04054 <span class="preprocessor">#if GTEST_CAN_STREAM_RESULTS_</span>
<a name="l04055"></a>04055 <span class="preprocessor"></span>    <span class="comment">// Configures listeners for streaming test results to the specified server.</span>
<a name="l04056"></a>04056     ConfigureStreamingOutput();
<a name="l04057"></a>04057 <span class="preprocessor">#endif  // GTEST_CAN_STREAM_RESULTS_</span>
<a name="l04058"></a>04058 <span class="preprocessor"></span>  }
<a name="l04059"></a>04059 }
<a name="l04060"></a>04060 
<a name="l04061"></a>04061 <span class="comment">// A predicate that checks the name of a TestCase against a known</span>
<a name="l04062"></a>04062 <span class="comment">// value.</span>
<a name="l04063"></a>04063 <span class="comment">//</span>
<a name="l04064"></a>04064 <span class="comment">// This is used for implementation of the UnitTest class only.  We put</span>
<a name="l04065"></a>04065 <span class="comment">// it in the anonymous namespace to prevent polluting the outer</span>
<a name="l04066"></a>04066 <span class="comment">// namespace.</span>
<a name="l04067"></a>04067 <span class="comment">//</span>
<a name="l04068"></a>04068 <span class="comment">// TestCaseNameIs is copyable.</span>
<a name="l04069"></a>04069 <span class="keyword">class </span>TestCaseNameIs {
<a name="l04070"></a>04070  <span class="keyword">public</span>:
<a name="l04071"></a>04071   <span class="comment">// Constructor.</span>
<a name="l04072"></a><a class="code" href="../../df/d02/classtesting_1_1internal_1_1TestCaseNameIs.html#af26113c34450ae4e37c0864c2894f30f">04072</a>   <span class="keyword">explicit</span> <a class="code" href="../../df/d02/classtesting_1_1internal_1_1TestCaseNameIs.html#af26113c34450ae4e37c0864c2894f30f">TestCaseNameIs</a>(<span class="keyword">const</span> <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html">String</a>&amp; name)
<a name="l04073"></a>04073       : <a class="code" href="../../df/d02/classtesting_1_1internal_1_1TestCaseNameIs.html#a46d25a1d56b8ab56e84b8bd0c7581e8f">name_</a>(name) {}
<a name="l04074"></a>04074 
<a name="l04075"></a>04075   <span class="comment">// Returns true iff the name of test_case matches name_.</span>
<a name="l04076"></a><a class="code" href="../../df/d02/classtesting_1_1internal_1_1TestCaseNameIs.html#abeb26d81f2810a4cd5083d4c32e58629">04076</a>   <span class="keywordtype">bool</span> <a class="code" href="../../df/d02/classtesting_1_1internal_1_1TestCaseNameIs.html#abeb26d81f2810a4cd5083d4c32e58629">operator()</a>(<span class="keyword">const</span> <a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html">TestCase</a>* test_case)<span class="keyword"> const </span>{
<a name="l04077"></a>04077     <span class="keywordflow">return</span> test_case != NULL &amp;&amp; strcmp(test_case-&gt;<a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html#a862958aa3c2b9bf36903f1f0f2e81c54">name</a>(), <a class="code" href="../../df/d02/classtesting_1_1internal_1_1TestCaseNameIs.html#a46d25a1d56b8ab56e84b8bd0c7581e8f">name_</a>.<a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a89da6be964480b4c86334e4e337d3cf2">c_str</a>()) == 0;
<a name="l04078"></a>04078   }
<a name="l04079"></a>04079 
<a name="l04080"></a>04080  <span class="keyword">private</span>:
<a name="l04081"></a>04081   <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html">String</a> <a class="code" href="../../df/d02/classtesting_1_1internal_1_1TestCaseNameIs.html#a46d25a1d56b8ab56e84b8bd0c7581e8f">name_</a>;
<a name="l04082"></a>04082 };
<a name="l04083"></a>04083 
<a name="l04084"></a>04084 <span class="comment">// Finds and returns a TestCase with the given name.  If one doesn&#39;t</span>
<a name="l04085"></a>04085 <span class="comment">// exist, creates one and returns it.  It&#39;s the CALLER&#39;S</span>
<a name="l04086"></a>04086 <span class="comment">// RESPONSIBILITY to ensure that this function is only called WHEN THE</span>
<a name="l04087"></a>04087 <span class="comment">// TESTS ARE NOT SHUFFLED.</span>
<a name="l04088"></a>04088 <span class="comment">//</span>
<a name="l04089"></a>04089 <span class="comment">// Arguments:</span>
<a name="l04090"></a>04090 <span class="comment">//</span>
<a name="l04091"></a>04091 <span class="comment">//   test_case_name: name of the test case</span>
<a name="l04092"></a>04092 <span class="comment">//   type_param:     the name of the test case&#39;s type parameter, or NULL if</span>
<a name="l04093"></a>04093 <span class="comment">//                   this is not a typed or a type-parameterized test case.</span>
<a name="l04094"></a>04094 <span class="comment">//   set_up_tc:      pointer to the function that sets up the test case</span>
<a name="l04095"></a>04095 <span class="comment">//   tear_down_tc:   pointer to the function that tears down the test case</span>
<a name="l04096"></a>04096 <a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html">TestCase</a>* <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#adced0a9df4be306d905a3f954fc3eedf">UnitTestImpl::GetTestCase</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* test_case_name,
<a name="l04097"></a>04097                                     <span class="keyword">const</span> <span class="keywordtype">char</span>* type_param,
<a name="l04098"></a>04098                                     <a class="code" href="../../db/d9f/classtesting_1_1Test.html#a2df065892efeff7ca91bb2d2fbe00975">Test::SetUpTestCaseFunc</a> set_up_tc,
<a name="l04099"></a>04099                                     <a class="code" href="../../db/d9f/classtesting_1_1Test.html#a4ae7a4e140c70dee5c9cb82e13ae570c">Test::TearDownTestCaseFunc</a> tear_down_tc) {
<a name="l04100"></a>04100   <span class="comment">// Can we find a TestCase with the given name?</span>
<a name="l04101"></a>04101   <span class="keyword">const</span> std::vector&lt;TestCase*&gt;::const_iterator test_case =
<a name="l04102"></a>04102       std::find_if(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>.begin(), <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>.end(),
<a name="l04103"></a>04103                    TestCaseNameIs(test_case_name));
<a name="l04104"></a>04104 
<a name="l04105"></a>04105   <span class="keywordflow">if</span> (test_case != <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>.end())
<a name="l04106"></a>04106     <span class="keywordflow">return</span> *test_case;
<a name="l04107"></a>04107 
<a name="l04108"></a>04108   <span class="comment">// No.  Let&#39;s create one.</span>
<a name="l04109"></a>04109   <a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html">TestCase</a>* <span class="keyword">const</span> new_test_case =
<a name="l04110"></a>04110       <span class="keyword">new</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>(test_case_name, type_param, set_up_tc, tear_down_tc);
<a name="l04111"></a>04111 
<a name="l04112"></a>04112   <span class="comment">// Is this a death test case?</span>
<a name="l04113"></a>04113   <span class="keywordflow">if</span> (<a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a2668b814cce76871ca391416634bd020">internal::UnitTestOptions::MatchesFilter</a>(String(test_case_name),
<a name="l04114"></a>04114                                                <a class="code" href="../../d0/d75/namespacetesting.html#abece2ad88f181d37c5c8fb3e9dd0675a">kDeathTestCaseFilter</a>)) {
<a name="l04115"></a>04115     <span class="comment">// Yes.  Inserts the test case after the last death test case</span>
<a name="l04116"></a>04116     <span class="comment">// defined so far.  This only works when the test cases haven&#39;t</span>
<a name="l04117"></a>04117     <span class="comment">// been shuffled.  Otherwise we may end up running a death test</span>
<a name="l04118"></a>04118     <span class="comment">// after a non-death test.</span>
<a name="l04119"></a>04119     ++<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a93b260f5e9218dd561831f3135ac9f26">last_death_test_case_</a>;
<a name="l04120"></a>04120     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>.insert(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>.begin() + <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a93b260f5e9218dd561831f3135ac9f26">last_death_test_case_</a>,
<a name="l04121"></a>04121                        new_test_case);
<a name="l04122"></a>04122   } <span class="keywordflow">else</span> {
<a name="l04123"></a>04123     <span class="comment">// No.  Appends to the end of the list.</span>
<a name="l04124"></a>04124     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>.push_back(new_test_case);
<a name="l04125"></a>04125   }
<a name="l04126"></a>04126 
<a name="l04127"></a>04127   <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a537c435021d907aafe88070abe6db7a9">test_case_indices_</a>.push_back(static_cast&lt;int&gt;(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a537c435021d907aafe88070abe6db7a9">test_case_indices_</a>.size()));
<a name="l04128"></a>04128   <span class="keywordflow">return</span> new_test_case;
<a name="l04129"></a>04129 }
<a name="l04130"></a>04130 
<a name="l04131"></a>04131 <span class="comment">// Helpers for setting up / tearing down the given environment.  They</span>
<a name="l04132"></a>04132 <span class="comment">// are for use in the ForEach() function.</span>
<a name="l04133"></a>04133 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a70bc8320887c024883c4350b40891a1f">SetUpEnvironment</a>(Environment* env) { env-&gt;SetUp(); }
<a name="l04134"></a>04134 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ad03ec49f30777e3940aac9bd7ee087fd">TearDownEnvironment</a>(Environment* env) { env-&gt;TearDown(); }
<a name="l04135"></a>04135 
<a name="l04136"></a>04136 <span class="comment">// Runs all tests in this UnitTest object, prints the result, and</span>
<a name="l04137"></a>04137 <span class="comment">// returns true if all tests are successful.  If any exception is</span>
<a name="l04138"></a>04138 <span class="comment">// thrown during a test, the test is considered to be failed, but the</span>
<a name="l04139"></a>04139 <span class="comment">// rest of the tests will still be run.</span>
<a name="l04140"></a>04140 <span class="comment">//</span>
<a name="l04141"></a>04141 <span class="comment">// When parameterized tests are enabled, it expands and registers</span>
<a name="l04142"></a>04142 <span class="comment">// parameterized tests first in RegisterParameterizedTests().</span>
<a name="l04143"></a>04143 <span class="comment">// All other functions called from RunAllTests() may safely assume that</span>
<a name="l04144"></a>04144 <span class="comment">// parameterized tests are ready to be counted and run.</span>
<a name="l04145"></a>04145 <span class="keywordtype">bool</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a4d5d6a2e8fa3b918a284252602a98279">UnitTestImpl::RunAllTests</a>() {
<a name="l04146"></a>04146   <span class="comment">// Makes sure InitGoogleTest() was called.</span>
<a name="l04147"></a>04147   <span class="keywordflow">if</span> (!<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0554a55a03dae7d40e8ba569dac7848f">GTestIsInitialized</a>()) {
<a name="l04148"></a>04148     printf(<span class="stringliteral">&quot;%s&quot;</span>,
<a name="l04149"></a>04149            <span class="stringliteral">&quot;\nThis test program did NOT call ::testing::InitGoogleTest &quot;</span>
<a name="l04150"></a>04150            <span class="stringliteral">&quot;before calling RUN_ALL_TESTS().  Please fix it.\n&quot;</span>);
<a name="l04151"></a>04151     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04152"></a>04152   }
<a name="l04153"></a>04153 
<a name="l04154"></a>04154   <span class="comment">// Do not run any test if the --help flag was specified.</span>
<a name="l04155"></a>04155   <span class="keywordflow">if</span> (<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a05b77c93e2ac596346466a00277288ca">g_help_flag</a>)
<a name="l04156"></a>04156     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04157"></a>04157 
<a name="l04158"></a>04158   <span class="comment">// Repeats the call to the post-flag parsing initialization in case the</span>
<a name="l04159"></a>04159   <span class="comment">// user didn&#39;t call InitGoogleTest.</span>
<a name="l04160"></a>04160   <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a3d68c6d1fdec822210f96171a3b57b47">PostFlagParsingInit</a>();
<a name="l04161"></a>04161 
<a name="l04162"></a>04162   <span class="comment">// Even if sharding is not on, test runners may want to use the</span>
<a name="l04163"></a>04163   <span class="comment">// GTEST_SHARD_STATUS_FILE to query whether the test supports the sharding</span>
<a name="l04164"></a>04164   <span class="comment">// protocol.</span>
<a name="l04165"></a>04165   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a656c8ec8f2ee82fa90b9ba61b6145538">internal::WriteToShardStatusFileIfNeeded</a>();
<a name="l04166"></a>04166 
<a name="l04167"></a>04167   <span class="comment">// True iff we are in a subprocess for running a thread-safe-style</span>
<a name="l04168"></a>04168   <span class="comment">// death test.</span>
<a name="l04169"></a>04169   <span class="keywordtype">bool</span> in_subprocess_for_death_test = <span class="keyword">false</span>;
<a name="l04170"></a>04170 
<a name="l04171"></a>04171 <span class="preprocessor">#if GTEST_HAS_DEATH_TEST</span>
<a name="l04172"></a>04172 <span class="preprocessor"></span>  in_subprocess_for_death_test = (internal_run_death_test_flag_.get() != NULL);
<a name="l04173"></a>04173 <span class="preprocessor">#endif  // GTEST_HAS_DEATH_TEST</span>
<a name="l04174"></a>04174 <span class="preprocessor"></span>
<a name="l04175"></a>04175   <span class="keyword">const</span> <span class="keywordtype">bool</span> should_shard = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a57e2697262a419061fc4cd3377a9271e">ShouldShard</a>(<a class="code" href="../../d0/d75/namespacetesting.html#a9d9ddd278cfbb5834dea812d0de529be">kTestTotalShards</a>, <a class="code" href="../../d0/d75/namespacetesting.html#a34e170fdd4ba4d2f80456cc37e2a8185">kTestShardIndex</a>,
<a name="l04176"></a>04176                                         in_subprocess_for_death_test);
<a name="l04177"></a>04177 
<a name="l04178"></a>04178   <span class="comment">// Compares the full test names with the filter to decide which</span>
<a name="l04179"></a>04179   <span class="comment">// tests to run.</span>
<a name="l04180"></a>04180   <span class="keyword">const</span> <span class="keywordtype">bool</span> has_tests_to_run = <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#af8cfcffb71cba69a55105ddac96786aa">FilterTests</a>(should_shard
<a name="l04181"></a>04181                                               ? <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ac8d671a300e2bd293e21f8ad1612543ca6f368a6bc21fd5d834c62e4624353e3b">HONOR_SHARDING_PROTOCOL</a>
<a name="l04182"></a>04182                                               : <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ac8d671a300e2bd293e21f8ad1612543cab68bd993c6f106edad941b182a42c36a">IGNORE_SHARDING_PROTOCOL</a>) &gt; 0;
<a name="l04183"></a>04183 
<a name="l04184"></a>04184   <span class="comment">// Lists the tests and exits if the --gtest_list_tests flag was specified.</span>
<a name="l04185"></a>04185   <span class="keywordflow">if</span> (<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(list_tests)) {
<a name="l04186"></a>04186     <span class="comment">// This must be called *after* FilterTests() has been called.</span>
<a name="l04187"></a>04187     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#abc77b71cd244096a75b13b8a2d9f7d14">ListTestsMatchingFilter</a>();
<a name="l04188"></a>04188     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04189"></a>04189   }
<a name="l04190"></a>04190 
<a name="l04191"></a>04191   <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a3076e24cbd93ed76f370a5a2fce53403">random_seed_</a> = <a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(shuffle) ?
<a name="l04192"></a>04192       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a968b1b4479cfbc49079f9a06fe37d5ba">GetRandomSeedFromFlag</a>(<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ac0bcee84bdc839bfabd0a829642ab4f7">random_seed</a>)) : 0;
<a name="l04193"></a>04193 
<a name="l04194"></a>04194   <span class="comment">// True iff at least one test has failed.</span>
<a name="l04195"></a>04195   <span class="keywordtype">bool</span> failed = <span class="keyword">false</span>;
<a name="l04196"></a>04196 
<a name="l04197"></a>04197   TestEventListener* repeater = <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a371c481b63deeb0ecd47f42b4720480b">listeners</a>()-&gt;<a class="code" href="../../db/d70/classtesting_1_1TestEventListeners.html#af7cfacdf90b4ba59566c16d95ee5d6cc">repeater</a>();
<a name="l04198"></a>04198 
<a name="l04199"></a>04199   repeater-&gt;<a class="code" href="../../d0/d51/classtesting_1_1TestEventListener.html#a1dceff89a70d9e37ca025e8db3674eac">OnTestProgramStart</a>(*<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a83d5f098f3d26888da5c556f26076159">parent_</a>);
<a name="l04200"></a>04200 
<a name="l04201"></a>04201   <span class="comment">// How many times to repeat the tests?  We don&#39;t want to repeat them</span>
<a name="l04202"></a>04202   <span class="comment">// when we are inside the subprocess of a death test.</span>
<a name="l04203"></a>04203   <span class="keyword">const</span> <span class="keywordtype">int</span> repeat = in_subprocess_for_death_test ? 1 : <a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(repeat);
<a name="l04204"></a>04204   <span class="comment">// Repeats forever if the repeat count is negative.</span>
<a name="l04205"></a>04205   <span class="keyword">const</span> <span class="keywordtype">bool</span> forever = repeat &lt; 0;
<a name="l04206"></a>04206   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; forever || i != repeat; i++) {
<a name="l04207"></a>04207     <span class="comment">// We want to preserve failures generated by ad-hoc test</span>
<a name="l04208"></a>04208     <span class="comment">// assertions executed before RUN_ALL_TESTS().</span>
<a name="l04209"></a>04209     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a3f7a43dd50595257ac958e7ec9112945">ClearNonAdHocTestResult</a>();
<a name="l04210"></a>04210 
<a name="l04211"></a>04211     <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a9e0fb32f592d143f031a3431366adae0">TimeInMillis</a> start = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae0c6fd4543c65945515c42d6f43cc138">GetTimeInMillis</a>();
<a name="l04212"></a>04212 
<a name="l04213"></a>04213     <span class="comment">// Shuffles test cases and tests if requested.</span>
<a name="l04214"></a>04214     <span class="keywordflow">if</span> (has_tests_to_run &amp;&amp; <a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(shuffle)) {
<a name="l04215"></a>04215       <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a485dc510d5b4af5835231d23e5510b25">random</a>()-&gt;<a class="code" href="../../dc/d5a/classtesting_1_1internal_1_1Random.html#aaca1e9a7a7bc2a613347117db7ab28b1">Reseed</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a3076e24cbd93ed76f370a5a2fce53403">random_seed_</a>);
<a name="l04216"></a>04216       <span class="comment">// This should be done before calling OnTestIterationStart(),</span>
<a name="l04217"></a>04217       <span class="comment">// such that a test event listener can see the actual test order</span>
<a name="l04218"></a>04218       <span class="comment">// in the event.</span>
<a name="l04219"></a>04219       <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a1835112b5b9bb3931956c68f05a3cf69">ShuffleTests</a>();
<a name="l04220"></a>04220     }
<a name="l04221"></a>04221 
<a name="l04222"></a>04222     <span class="comment">// Tells the unit test event listeners that the tests are about to start.</span>
<a name="l04223"></a>04223     repeater-&gt;OnTestIterationStart(*<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a83d5f098f3d26888da5c556f26076159">parent_</a>, i);
<a name="l04224"></a>04224 
<a name="l04225"></a>04225     <span class="comment">// Runs each test case if there is at least one test to run.</span>
<a name="l04226"></a>04226     <span class="keywordflow">if</span> (has_tests_to_run) {
<a name="l04227"></a>04227       <span class="comment">// Sets up all environments beforehand.</span>
<a name="l04228"></a>04228       repeater-&gt;OnEnvironmentsSetUpStart(*<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a83d5f098f3d26888da5c556f26076159">parent_</a>);
<a name="l04229"></a>04229       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af699259a2b1e5e06250ed075b735b1f6">ForEach</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a3887eb0491f4d2221cd010aff0e9c4b6">environments_</a>, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a70bc8320887c024883c4350b40891a1f">SetUpEnvironment</a>);
<a name="l04230"></a>04230       repeater-&gt;OnEnvironmentsSetUpEnd(*<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a83d5f098f3d26888da5c556f26076159">parent_</a>);
<a name="l04231"></a>04231 
<a name="l04232"></a>04232       <span class="comment">// Runs the tests only if there was no fatal failure during global</span>
<a name="l04233"></a>04233       <span class="comment">// set-up.</span>
<a name="l04234"></a>04234       <span class="keywordflow">if</span> (!<a class="code" href="../../db/d9f/classtesting_1_1Test.html#a4f237fa994f623a704494cd821fb761f">Test::HasFatalFailure</a>()) {
<a name="l04235"></a>04235         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> test_index = 0; test_index &lt; <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#aba8c18261c58f301e1e80049a0781d84">total_test_case_count</a>();
<a name="l04236"></a>04236              test_index++) {
<a name="l04237"></a>04237           <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a04b94a3c825711103b247aa87d6b76e3">GetMutableTestCase</a>(test_index)-&gt;<a class="code" href="../../d0/d9a/classtesting_1_1TestCase.html#aa3eca255b6be227d7d901cc2a72017a5">Run</a>();
<a name="l04238"></a>04238         }
<a name="l04239"></a>04239       }
<a name="l04240"></a>04240 
<a name="l04241"></a>04241       <span class="comment">// Tears down all environments in reverse order afterwards.</span>
<a name="l04242"></a>04242       repeater-&gt;OnEnvironmentsTearDownStart(*<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a83d5f098f3d26888da5c556f26076159">parent_</a>);
<a name="l04243"></a>04243       std::for_each(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a3887eb0491f4d2221cd010aff0e9c4b6">environments_</a>.rbegin(), <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a3887eb0491f4d2221cd010aff0e9c4b6">environments_</a>.rend(),
<a name="l04244"></a>04244                     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ad03ec49f30777e3940aac9bd7ee087fd">TearDownEnvironment</a>);
<a name="l04245"></a>04245       repeater-&gt;OnEnvironmentsTearDownEnd(*<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a83d5f098f3d26888da5c556f26076159">parent_</a>);
<a name="l04246"></a>04246     }
<a name="l04247"></a>04247 
<a name="l04248"></a>04248     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a97b9c166ebee95ae4c9ef26cf3155617">elapsed_time_</a> = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae0c6fd4543c65945515c42d6f43cc138">GetTimeInMillis</a>() - start;
<a name="l04249"></a>04249 
<a name="l04250"></a>04250     <span class="comment">// Tells the unit test event listener that the tests have just finished.</span>
<a name="l04251"></a>04251     repeater-&gt;OnTestIterationEnd(*<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a83d5f098f3d26888da5c556f26076159">parent_</a>, i);
<a name="l04252"></a>04252 
<a name="l04253"></a>04253     <span class="comment">// Gets the result and clears it.</span>
<a name="l04254"></a>04254     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ac97d5073365af8a73262fd9f6bf18656">Passed</a>()) {
<a name="l04255"></a>04255       failed = <span class="keyword">true</span>;
<a name="l04256"></a>04256     }
<a name="l04257"></a>04257 
<a name="l04258"></a>04258     <span class="comment">// Restores the original test order after the iteration.  This</span>
<a name="l04259"></a>04259     <span class="comment">// allows the user to quickly repro a failure that happens in the</span>
<a name="l04260"></a>04260     <span class="comment">// N-th iteration without repeating the first (N - 1) iterations.</span>
<a name="l04261"></a>04261     <span class="comment">// This is not enclosed in &quot;if (GTEST_FLAG(shuffle)) { ... }&quot;, in</span>
<a name="l04262"></a>04262     <span class="comment">// case the user somehow changes the value of the flag somewhere</span>
<a name="l04263"></a>04263     <span class="comment">// (it&#39;s always safe to unshuffle the tests).</span>
<a name="l04264"></a>04264     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ae4c0afbfb6a7d13aece4c3a256a5d01d">UnshuffleTests</a>();
<a name="l04265"></a>04265 
<a name="l04266"></a>04266     <span class="keywordflow">if</span> (<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(shuffle)) {
<a name="l04267"></a>04267       <span class="comment">// Picks a new random seed for each iteration.</span>
<a name="l04268"></a>04268       <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a3076e24cbd93ed76f370a5a2fce53403">random_seed_</a> = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae2fa5c0c84f0feabbd41ebc1dc208c84">GetNextRandomSeed</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a3076e24cbd93ed76f370a5a2fce53403">random_seed_</a>);
<a name="l04269"></a>04269     }
<a name="l04270"></a>04270   }
<a name="l04271"></a>04271 
<a name="l04272"></a>04272   repeater-&gt;OnTestProgramEnd(*<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a83d5f098f3d26888da5c556f26076159">parent_</a>);
<a name="l04273"></a>04273 
<a name="l04274"></a>04274   <span class="keywordflow">return</span> !failed;
<a name="l04275"></a>04275 }
<a name="l04276"></a>04276 
<a name="l04277"></a>04277 <span class="comment">// Reads the GTEST_SHARD_STATUS_FILE environment variable, and creates the file</span>
<a name="l04278"></a>04278 <span class="comment">// if the variable is present. If a file already exists at this location, this</span>
<a name="l04279"></a>04279 <span class="comment">// function will write over it. If the variable is present, but the file cannot</span>
<a name="l04280"></a>04280 <span class="comment">// be created, prints an error and exits.</span>
<a name="l04281"></a>04281 <span class="keywordtype">void</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a656c8ec8f2ee82fa90b9ba61b6145538">WriteToShardStatusFileIfNeeded</a>() {
<a name="l04282"></a>04282   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> test_shard_file = <a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#a7ed11bcd211f76641b16e60b5f0594eb">posix::GetEnv</a>(<a class="code" href="../../d0/d75/namespacetesting.html#a9f1ab5ec024bf19381dff00e824f6ba7">kTestShardStatusFile</a>);
<a name="l04283"></a>04283   <span class="keywordflow">if</span> (test_shard_file != NULL) {
<a name="l04284"></a>04284     FILE* <span class="keyword">const</span> file = <a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#a71d8d763c7a5feba8bbb9a65fdc4cc87">posix::FOpen</a>(test_shard_file, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l04285"></a>04285     <span class="keywordflow">if</span> (file == NULL) {
<a name="l04286"></a>04286       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a55978b2a4d309f4f009fd1baa7808358">COLOR_RED</a>,
<a name="l04287"></a>04287                     <span class="stringliteral">&quot;Could not write to the test shard status file \&quot;%s\&quot; &quot;</span>
<a name="l04288"></a>04288                     <span class="stringliteral">&quot;specified by the %s environment variable.\n&quot;</span>,
<a name="l04289"></a>04289                     test_shard_file, <a class="code" href="../../d0/d75/namespacetesting.html#a9f1ab5ec024bf19381dff00e824f6ba7">kTestShardStatusFile</a>);
<a name="l04290"></a>04290       fflush(stdout);
<a name="l04291"></a>04291       exit(EXIT_FAILURE);
<a name="l04292"></a>04292     }
<a name="l04293"></a>04293     fclose(file);
<a name="l04294"></a>04294   }
<a name="l04295"></a>04295 }
<a name="l04296"></a>04296 
<a name="l04297"></a>04297 <span class="comment">// Checks whether sharding is enabled by examining the relevant</span>
<a name="l04298"></a>04298 <span class="comment">// environment variable values. If the variables are present,</span>
<a name="l04299"></a>04299 <span class="comment">// but inconsistent (i.e., shard_index &gt;= total_shards), prints</span>
<a name="l04300"></a>04300 <span class="comment">// an error and exits. If in_subprocess_for_death_test, sharding is</span>
<a name="l04301"></a>04301 <span class="comment">// disabled because it must only be applied to the original test</span>
<a name="l04302"></a>04302 <span class="comment">// process. Otherwise, we could filter out death tests we intended to execute.</span>
<a name="l04303"></a>04303 <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a57e2697262a419061fc4cd3377a9271e">ShouldShard</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* total_shards_env,
<a name="l04304"></a>04304                  <span class="keyword">const</span> <span class="keywordtype">char</span>* shard_index_env,
<a name="l04305"></a>04305                  <span class="keywordtype">bool</span> in_subprocess_for_death_test) {
<a name="l04306"></a>04306   <span class="keywordflow">if</span> (in_subprocess_for_death_test) {
<a name="l04307"></a>04307     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04308"></a>04308   }
<a name="l04309"></a>04309 
<a name="l04310"></a>04310   <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a8d84339888eecdb29b3d8f7607af3ecc">Int32</a> total_shards = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#afec7cf2eb159fa969f88d192ee507d23">Int32FromEnvOrDie</a>(total_shards_env, -1);
<a name="l04311"></a>04311   <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a8d84339888eecdb29b3d8f7607af3ecc">Int32</a> shard_index = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#afec7cf2eb159fa969f88d192ee507d23">Int32FromEnvOrDie</a>(shard_index_env, -1);
<a name="l04312"></a>04312 
<a name="l04313"></a>04313   <span class="keywordflow">if</span> (total_shards == -1 &amp;&amp; shard_index == -1) {
<a name="l04314"></a>04314     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04315"></a>04315   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (total_shards == -1 &amp;&amp; shard_index != -1) {
<a name="l04316"></a>04316     <span class="keyword">const</span> Message msg = Message()
<a name="l04317"></a>04317       &lt;&lt; <span class="stringliteral">&quot;Invalid environment variables: you have &quot;</span>
<a name="l04318"></a>04318       &lt;&lt; <a class="code" href="../../d0/d75/namespacetesting.html#a34e170fdd4ba4d2f80456cc37e2a8185">kTestShardIndex</a> &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; shard_index
<a name="l04319"></a>04319       &lt;&lt; <span class="stringliteral">&quot;, but have left &quot;</span> &lt;&lt; <a class="code" href="../../d0/d75/namespacetesting.html#a9d9ddd278cfbb5834dea812d0de529be">kTestTotalShards</a> &lt;&lt; <span class="stringliteral">&quot; unset.\n&quot;</span>;
<a name="l04320"></a>04320     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a55978b2a4d309f4f009fd1baa7808358">COLOR_RED</a>, msg.GetString().c_str());
<a name="l04321"></a>04321     fflush(stdout);
<a name="l04322"></a>04322     exit(EXIT_FAILURE);
<a name="l04323"></a>04323   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (total_shards != -1 &amp;&amp; shard_index == -1) {
<a name="l04324"></a>04324     <span class="keyword">const</span> Message msg = Message()
<a name="l04325"></a>04325       &lt;&lt; <span class="stringliteral">&quot;Invalid environment variables: you have &quot;</span>
<a name="l04326"></a>04326       &lt;&lt; kTestTotalShards &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; total_shards
<a name="l04327"></a>04327       &lt;&lt; <span class="stringliteral">&quot;, but have left &quot;</span> &lt;&lt; <a class="code" href="../../d0/d75/namespacetesting.html#a34e170fdd4ba4d2f80456cc37e2a8185">kTestShardIndex</a> &lt;&lt; <span class="stringliteral">&quot; unset.\n&quot;</span>;
<a name="l04328"></a>04328     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a55978b2a4d309f4f009fd1baa7808358">COLOR_RED</a>, msg.GetString().c_str());
<a name="l04329"></a>04329     fflush(stdout);
<a name="l04330"></a>04330     exit(EXIT_FAILURE);
<a name="l04331"></a>04331   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shard_index &lt; 0 || shard_index &gt;= total_shards) {
<a name="l04332"></a>04332     <span class="keyword">const</span> Message msg = Message()
<a name="l04333"></a>04333       &lt;&lt; <span class="stringliteral">&quot;Invalid environment variables: we require 0 &lt;= &quot;</span>
<a name="l04334"></a>04334       &lt;&lt; kTestShardIndex &lt;&lt; <span class="stringliteral">&quot; &lt; &quot;</span> &lt;&lt; kTestTotalShards
<a name="l04335"></a>04335       &lt;&lt; <span class="stringliteral">&quot;, but you have &quot;</span> &lt;&lt; kTestShardIndex &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; shard_index
<a name="l04336"></a>04336       &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; kTestTotalShards &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; total_shards &lt;&lt; <span class="stringliteral">&quot;.\n&quot;</span>;
<a name="l04337"></a>04337     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a55978b2a4d309f4f009fd1baa7808358">COLOR_RED</a>, msg.GetString().c_str());
<a name="l04338"></a>04338     fflush(stdout);
<a name="l04339"></a>04339     exit(EXIT_FAILURE);
<a name="l04340"></a>04340   }
<a name="l04341"></a>04341 
<a name="l04342"></a>04342   <span class="keywordflow">return</span> total_shards &gt; 1;
<a name="l04343"></a>04343 }
<a name="l04344"></a>04344 
<a name="l04345"></a>04345 <span class="comment">// Parses the environment variable var as an Int32. If it is unset,</span>
<a name="l04346"></a>04346 <span class="comment">// returns default_val. If it is not an Int32, prints an error</span>
<a name="l04347"></a>04347 <span class="comment">// and aborts.</span>
<a name="l04348"></a>04348 <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a8d84339888eecdb29b3d8f7607af3ecc">Int32</a> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#afec7cf2eb159fa969f88d192ee507d23">Int32FromEnvOrDie</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* var, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a8d84339888eecdb29b3d8f7607af3ecc">Int32</a> default_val) {
<a name="l04349"></a>04349   <span class="keyword">const</span> <span class="keywordtype">char</span>* str_val = <a class="code" href="../../d0/d81/namespacetesting_1_1internal_1_1posix.html#a7ed11bcd211f76641b16e60b5f0594eb">posix::GetEnv</a>(var);
<a name="l04350"></a>04350   <span class="keywordflow">if</span> (str_val == NULL) {
<a name="l04351"></a>04351     <span class="keywordflow">return</span> default_val;
<a name="l04352"></a>04352   }
<a name="l04353"></a>04353 
<a name="l04354"></a>04354   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a8d84339888eecdb29b3d8f7607af3ecc">Int32</a> result;
<a name="l04355"></a>04355   <span class="keywordflow">if</span> (!<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3bd151d0274b216f9c2e6275ccc4a9a3">ParseInt32</a>(Message() &lt;&lt; <span class="stringliteral">&quot;The value of environment variable &quot;</span> &lt;&lt; var,
<a name="l04356"></a>04356                   str_val, &amp;result)) {
<a name="l04357"></a>04357     exit(EXIT_FAILURE);
<a name="l04358"></a>04358   }
<a name="l04359"></a>04359   <span class="keywordflow">return</span> result;
<a name="l04360"></a>04360 }
<a name="l04361"></a>04361 
<a name="l04362"></a>04362 <span class="comment">// Given the total number of shards, the shard index, and the test id,</span>
<a name="l04363"></a>04363 <span class="comment">// returns true iff the test should be run on this shard. The test id is</span>
<a name="l04364"></a>04364 <span class="comment">// some arbitrary but unique non-negative integer assigned to each test</span>
<a name="l04365"></a>04365 <span class="comment">// method. Assumes that 0 &lt;= shard_index &lt; total_shards.</span>
<a name="l04366"></a>04366 <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac05861de55e638fa73ea70a3f2f6f622">ShouldRunTestOnShard</a>(<span class="keywordtype">int</span> total_shards, <span class="keywordtype">int</span> shard_index, <span class="keywordtype">int</span> test_id) {
<a name="l04367"></a>04367   <span class="keywordflow">return</span> (test_id % total_shards) == shard_index;
<a name="l04368"></a>04368 }
<a name="l04369"></a>04369 
<a name="l04370"></a>04370 <span class="comment">// Compares the name of each test with the user-specified filter to</span>
<a name="l04371"></a>04371 <span class="comment">// decide whether the test should be run, then records the result in</span>
<a name="l04372"></a>04372 <span class="comment">// each TestCase and TestInfo object.</span>
<a name="l04373"></a>04373 <span class="comment">// If shard_tests == true, further filters tests based on sharding</span>
<a name="l04374"></a>04374 <span class="comment">// variables in the environment - see</span>
<a name="l04375"></a>04375 <span class="comment">// http://code.google.com/p/googletest/wiki/GoogleTestAdvancedGuide.</span>
<a name="l04376"></a>04376 <span class="comment">// Returns the number of tests that should run.</span>
<a name="l04377"></a>04377 <span class="keywordtype">int</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#af8cfcffb71cba69a55105ddac96786aa">UnitTestImpl::FilterTests</a>(ReactionToSharding shard_tests) {
<a name="l04378"></a>04378   <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a8d84339888eecdb29b3d8f7607af3ecc">Int32</a> total_shards = shard_tests == <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ac8d671a300e2bd293e21f8ad1612543ca6f368a6bc21fd5d834c62e4624353e3b">HONOR_SHARDING_PROTOCOL</a> ?
<a name="l04379"></a>04379       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#afec7cf2eb159fa969f88d192ee507d23">Int32FromEnvOrDie</a>(kTestTotalShards, -1) : -1;
<a name="l04380"></a>04380   <span class="keyword">const</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a8d84339888eecdb29b3d8f7607af3ecc">Int32</a> shard_index = shard_tests == <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ac8d671a300e2bd293e21f8ad1612543ca6f368a6bc21fd5d834c62e4624353e3b">HONOR_SHARDING_PROTOCOL</a> ?
<a name="l04381"></a>04381       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#afec7cf2eb159fa969f88d192ee507d23">Int32FromEnvOrDie</a>(kTestShardIndex, -1) : -1;
<a name="l04382"></a>04382 
<a name="l04383"></a>04383   <span class="comment">// num_runnable_tests are the number of tests that will</span>
<a name="l04384"></a>04384   <span class="comment">// run across all shards (i.e., match filter and are not disabled).</span>
<a name="l04385"></a>04385   <span class="comment">// num_selected_tests are the number of tests to be run on</span>
<a name="l04386"></a>04386   <span class="comment">// this shard.</span>
<a name="l04387"></a>04387   <span class="keywordtype">int</span> num_runnable_tests = 0;
<a name="l04388"></a>04388   <span class="keywordtype">int</span> num_selected_tests = 0;
<a name="l04389"></a>04389   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>.size(); i++) {
<a name="l04390"></a>04390     <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>* <span class="keyword">const</span> test_case = <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>[i];
<a name="l04391"></a>04391     <span class="keyword">const</span> String &amp;test_case_name = test_case-&gt;name();
<a name="l04392"></a>04392     test_case-&gt;set_should_run(<span class="keyword">false</span>);
<a name="l04393"></a>04393 
<a name="l04394"></a>04394     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; test_case-&gt;test_info_list().size(); j++) {
<a name="l04395"></a>04395       TestInfo* <span class="keyword">const</span> test_info = test_case-&gt;test_info_list()[j];
<a name="l04396"></a>04396       <span class="keyword">const</span> String test_name(test_info-&gt;name());
<a name="l04397"></a>04397       <span class="comment">// A test is disabled if test case name or test name matches</span>
<a name="l04398"></a>04398       <span class="comment">// kDisableTestFilter.</span>
<a name="l04399"></a>04399       <span class="keyword">const</span> <span class="keywordtype">bool</span> is_disabled =
<a name="l04400"></a>04400           <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a2668b814cce76871ca391416634bd020">internal::UnitTestOptions::MatchesFilter</a>(test_case_name,
<a name="l04401"></a>04401                                                    <a class="code" href="../../d0/d75/namespacetesting.html#a838f9d2c93a072f193aeb34809047179">kDisableTestFilter</a>) ||
<a name="l04402"></a>04402           <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a2668b814cce76871ca391416634bd020">internal::UnitTestOptions::MatchesFilter</a>(test_name,
<a name="l04403"></a>04403                                                    <a class="code" href="../../d0/d75/namespacetesting.html#a838f9d2c93a072f193aeb34809047179">kDisableTestFilter</a>);
<a name="l04404"></a>04404       test_info-&gt;is_disabled_ = is_disabled;
<a name="l04405"></a>04405 
<a name="l04406"></a>04406       <span class="keyword">const</span> <span class="keywordtype">bool</span> matches_filter =
<a name="l04407"></a>04407           <a class="code" href="../../d3/d9a/classtesting_1_1internal_1_1UnitTestOptions.html#a5729694202f5ce85701d892a6c65f921">internal::UnitTestOptions::FilterMatchesTest</a>(test_case_name,
<a name="l04408"></a>04408                                                        test_name);
<a name="l04409"></a>04409       test_info-&gt;matches_filter_ = matches_filter;
<a name="l04410"></a>04410 
<a name="l04411"></a>04411       <span class="keyword">const</span> <span class="keywordtype">bool</span> is_runnable =
<a name="l04412"></a>04412           (<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(also_run_disabled_tests) || !is_disabled) &amp;&amp;
<a name="l04413"></a>04413           matches_filter;
<a name="l04414"></a>04414 
<a name="l04415"></a>04415       <span class="keyword">const</span> <span class="keywordtype">bool</span> is_selected = is_runnable &amp;&amp;
<a name="l04416"></a>04416           (shard_tests == <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ac8d671a300e2bd293e21f8ad1612543cab68bd993c6f106edad941b182a42c36a">IGNORE_SHARDING_PROTOCOL</a> ||
<a name="l04417"></a>04417            <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac05861de55e638fa73ea70a3f2f6f622">ShouldRunTestOnShard</a>(total_shards, shard_index,
<a name="l04418"></a>04418                                 num_runnable_tests));
<a name="l04419"></a>04419 
<a name="l04420"></a>04420       num_runnable_tests += is_runnable;
<a name="l04421"></a>04421       num_selected_tests += is_selected;
<a name="l04422"></a>04422 
<a name="l04423"></a>04423       test_info-&gt;should_run_ = is_selected;
<a name="l04424"></a>04424       test_case-&gt;set_should_run(test_case-&gt;should_run() || is_selected);
<a name="l04425"></a>04425     }
<a name="l04426"></a>04426   }
<a name="l04427"></a>04427   <span class="keywordflow">return</span> num_selected_tests;
<a name="l04428"></a>04428 }
<a name="l04429"></a>04429 
<a name="l04430"></a>04430 <span class="comment">// Prints the names of the tests matching the user-specified filter flag.</span>
<a name="l04431"></a>04431 <span class="keywordtype">void</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#abc77b71cd244096a75b13b8a2d9f7d14">UnitTestImpl::ListTestsMatchingFilter</a>() {
<a name="l04432"></a>04432   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>.size(); i++) {
<a name="l04433"></a>04433     <span class="keyword">const</span> <a class="code" href="../../d2/d4a/namespacegtest__test__utils.html#a61fe0349d692eb6d4f5b94e35049b2e9">TestCase</a>* <span class="keyword">const</span> test_case = <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>[i];
<a name="l04434"></a>04434     <span class="keywordtype">bool</span> printed_test_case_name = <span class="keyword">false</span>;
<a name="l04435"></a>04435 
<a name="l04436"></a>04436     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; test_case-&gt;test_info_list().size(); j++) {
<a name="l04437"></a>04437       <span class="keyword">const</span> TestInfo* <span class="keyword">const</span> test_info =
<a name="l04438"></a>04438           test_case-&gt;test_info_list()[j];
<a name="l04439"></a>04439       <span class="keywordflow">if</span> (test_info-&gt;matches_filter_) {
<a name="l04440"></a>04440         <span class="keywordflow">if</span> (!printed_test_case_name) {
<a name="l04441"></a>04441           printed_test_case_name = <span class="keyword">true</span>;
<a name="l04442"></a>04442           printf(<span class="stringliteral">&quot;%s.\n&quot;</span>, test_case-&gt;name());
<a name="l04443"></a>04443         }
<a name="l04444"></a>04444         printf(<span class="stringliteral">&quot;  %s\n&quot;</span>, test_info-&gt;name());
<a name="l04445"></a>04445       }
<a name="l04446"></a>04446     }
<a name="l04447"></a>04447   }
<a name="l04448"></a>04448   fflush(stdout);
<a name="l04449"></a>04449 }
<a name="l04450"></a>04450 
<a name="l04451"></a>04451 <span class="comment">// Sets the OS stack trace getter.</span>
<a name="l04452"></a>04452 <span class="comment">//</span>
<a name="l04453"></a>04453 <span class="comment">// Does nothing if the input and the current OS stack trace getter are</span>
<a name="l04454"></a>04454 <span class="comment">// the same; otherwise, deletes the old getter and makes the input the</span>
<a name="l04455"></a>04455 <span class="comment">// current getter.</span>
<a name="l04456"></a>04456 <span class="keywordtype">void</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a965c4bc292baeaefc41238f86f36f67c">UnitTestImpl::set_os_stack_trace_getter</a>(
<a name="l04457"></a>04457     OsStackTraceGetterInterface* getter) {
<a name="l04458"></a>04458   <span class="keywordflow">if</span> (<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a03a75f27d552174a5ba8f477f3f4f116">os_stack_trace_getter_</a> != getter) {
<a name="l04459"></a>04459     <span class="keyword">delete</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a03a75f27d552174a5ba8f477f3f4f116">os_stack_trace_getter_</a>;
<a name="l04460"></a>04460     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a03a75f27d552174a5ba8f477f3f4f116">os_stack_trace_getter_</a> = getter;
<a name="l04461"></a>04461   }
<a name="l04462"></a>04462 }
<a name="l04463"></a>04463 
<a name="l04464"></a>04464 <span class="comment">// Returns the current OS stack trace getter if it is not NULL;</span>
<a name="l04465"></a>04465 <span class="comment">// otherwise, creates an OsStackTraceGetter, makes it the current</span>
<a name="l04466"></a>04466 <span class="comment">// getter, and returns it.</span>
<a name="l04467"></a>04467 OsStackTraceGetterInterface* <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#accb552ad4af910904a9e48c49c5c79a2">UnitTestImpl::os_stack_trace_getter</a>() {
<a name="l04468"></a>04468   <span class="keywordflow">if</span> (<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a03a75f27d552174a5ba8f477f3f4f116">os_stack_trace_getter_</a> == NULL) {
<a name="l04469"></a>04469     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a03a75f27d552174a5ba8f477f3f4f116">os_stack_trace_getter_</a> = <span class="keyword">new</span> OsStackTraceGetter;
<a name="l04470"></a>04470   }
<a name="l04471"></a>04471 
<a name="l04472"></a>04472   <span class="keywordflow">return</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a03a75f27d552174a5ba8f477f3f4f116">os_stack_trace_getter_</a>;
<a name="l04473"></a>04473 }
<a name="l04474"></a>04474 
<a name="l04475"></a>04475 <span class="comment">// Returns the TestResult for the test that&#39;s currently running, or</span>
<a name="l04476"></a>04476 <span class="comment">// the TestResult for the ad hoc test if no test is running.</span>
<a name="l04477"></a>04477 TestResult* <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a385bee93ae6043262a860574aa59ba1a">UnitTestImpl::current_test_result</a>() {
<a name="l04478"></a>04478   <span class="keywordflow">return</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a4c974b2eb5da1b40919bb6118c3a33f8">current_test_info_</a> ?
<a name="l04479"></a>04479       &amp;(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a4c974b2eb5da1b40919bb6118c3a33f8">current_test_info_</a>-&gt;<a class="code" href="../../df/d65/classtesting_1_1TestInfo.html#afb2ec6cf0ab3f3e57bc2304e0df97c29">result_</a>) : &amp;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ae5fbed6752ae31d54b7db28c8a84df0a">ad_hoc_test_result_</a>;
<a name="l04480"></a>04480 }
<a name="l04481"></a>04481 
<a name="l04482"></a>04482 <span class="comment">// Shuffles all test cases, and the tests within each test case,</span>
<a name="l04483"></a>04483 <span class="comment">// making sure that death tests are still run first.</span>
<a name="l04484"></a>04484 <span class="keywordtype">void</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a1835112b5b9bb3931956c68f05a3cf69">UnitTestImpl::ShuffleTests</a>() {
<a name="l04485"></a>04485   <span class="comment">// Shuffles the death test cases.</span>
<a name="l04486"></a>04486   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af0e4357002b5772a92cb960ea611e80c">ShuffleRange</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a485dc510d5b4af5835231d23e5510b25">random</a>(), 0, <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a93b260f5e9218dd561831f3135ac9f26">last_death_test_case_</a> + 1, &amp;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a537c435021d907aafe88070abe6db7a9">test_case_indices_</a>);
<a name="l04487"></a>04487 
<a name="l04488"></a>04488   <span class="comment">// Shuffles the non-death test cases.</span>
<a name="l04489"></a>04489   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#af0e4357002b5772a92cb960ea611e80c">ShuffleRange</a>(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a485dc510d5b4af5835231d23e5510b25">random</a>(), <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a93b260f5e9218dd561831f3135ac9f26">last_death_test_case_</a> + 1,
<a name="l04490"></a>04490                static_cast&lt;int&gt;(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>.size()), &amp;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a537c435021d907aafe88070abe6db7a9">test_case_indices_</a>);
<a name="l04491"></a>04491 
<a name="l04492"></a>04492   <span class="comment">// Shuffles the tests inside each test case.</span>
<a name="l04493"></a>04493   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>.size(); i++) {
<a name="l04494"></a>04494     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>[i]-&gt;ShuffleTests(<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a485dc510d5b4af5835231d23e5510b25">random</a>());
<a name="l04495"></a>04495   }
<a name="l04496"></a>04496 }
<a name="l04497"></a>04497 
<a name="l04498"></a>04498 <span class="comment">// Restores the test cases and tests to their order before the first shuffle.</span>
<a name="l04499"></a>04499 <span class="keywordtype">void</span> <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ae4c0afbfb6a7d13aece4c3a256a5d01d">UnitTestImpl::UnshuffleTests</a>() {
<a name="l04500"></a>04500   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>.size(); i++) {
<a name="l04501"></a>04501     <span class="comment">// Unshuffles the tests in each test case.</span>
<a name="l04502"></a>04502     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#ab62e4e13580e882140f8bf78a94ce669">test_cases_</a>[i]-&gt;UnshuffleTests();
<a name="l04503"></a>04503     <span class="comment">// Resets the index of each test case.</span>
<a name="l04504"></a>04504     <a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a537c435021d907aafe88070abe6db7a9">test_case_indices_</a>[i] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(i);
<a name="l04505"></a>04505   }
<a name="l04506"></a>04506 }
<a name="l04507"></a>04507 
<a name="l04508"></a>04508 <span class="comment">// Returns the current OS stack trace as a String.</span>
<a name="l04509"></a>04509 <span class="comment">//</span>
<a name="l04510"></a>04510 <span class="comment">// The maximum number of stack frames to be included is specified by</span>
<a name="l04511"></a>04511 <span class="comment">// the gtest_stack_trace_depth flag.  The skip_count parameter</span>
<a name="l04512"></a>04512 <span class="comment">// specifies the number of top frames to be skipped, which doesn&#39;t</span>
<a name="l04513"></a>04513 <span class="comment">// count against the number of frames to be included.</span>
<a name="l04514"></a>04514 <span class="comment">//</span>
<a name="l04515"></a>04515 <span class="comment">// For example, if Foo() calls Bar(), which in turn calls</span>
<a name="l04516"></a>04516 <span class="comment">// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in</span>
<a name="l04517"></a>04517 <span class="comment">// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won&#39;t.</span>
<a name="l04518"></a>04518 String <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#aa233c580f5aa0ac5abf54608bc3366bc">GetCurrentOsStackTraceExceptTop</a>(UnitTest* <span class="comment">/*unit_test*/</span>,
<a name="l04519"></a>04519                                        <span class="keywordtype">int</span> skip_count) {
<a name="l04520"></a>04520   <span class="comment">// We pass skip_count + 1 to skip this wrapper function in addition</span>
<a name="l04521"></a>04521   <span class="comment">// to what the user really wants to skip.</span>
<a name="l04522"></a>04522   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3ae874a4030c4aa27d77d67bf08d9e1d">GetUnitTestImpl</a>()-&gt;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a131dbc639dae87df46e7f92daad7c183">CurrentOsStackTraceExceptTop</a>(skip_count + 1);
<a name="l04523"></a>04523 }
<a name="l04524"></a>04524 
<a name="l04525"></a>04525 <span class="comment">// Used by the GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_ macro to</span>
<a name="l04526"></a>04526 <span class="comment">// suppress unreachable code warnings.</span>
<a name="l04527"></a>04527 <span class="keyword">namespace </span>{
<a name="l04528"></a>04528 <span class="keyword">class </span>ClassUniqueToAlwaysTrue {};
<a name="l04529"></a>04529 }
<a name="l04530"></a>04530 
<a name="l04531"></a>04531 <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a68c8009eb16c787f90cd989f57fb3a9a">IsTrue</a>(<span class="keywordtype">bool</span> condition) { <span class="keywordflow">return</span> condition; }
<a name="l04532"></a>04532 
<a name="l04533"></a>04533 <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a7b125f3952e08530aedb98a650ee73c1">AlwaysTrue</a>() {
<a name="l04534"></a>04534 <span class="preprocessor">#if GTEST_HAS_EXCEPTIONS</span>
<a name="l04535"></a>04535 <span class="preprocessor"></span>  <span class="comment">// This condition is always false so AlwaysTrue() never actually throws,</span>
<a name="l04536"></a>04536   <span class="comment">// but it makes the compiler think that it may throw.</span>
<a name="l04537"></a>04537   <span class="keywordflow">if</span> (<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a68c8009eb16c787f90cd989f57fb3a9a">IsTrue</a>(<span class="keyword">false</span>))
<a name="l04538"></a>04538     <span class="keywordflow">throw</span> ClassUniqueToAlwaysTrue();
<a name="l04539"></a>04539 <span class="preprocessor">#endif  // GTEST_HAS_EXCEPTIONS</span>
<a name="l04540"></a>04540 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04541"></a>04541 }
<a name="l04542"></a>04542 
<a name="l04543"></a>04543 <span class="comment">// If *pstr starts with the given prefix, modifies *pstr to be right</span>
<a name="l04544"></a>04544 <span class="comment">// past the prefix and returns true; otherwise leaves *pstr unchanged</span>
<a name="l04545"></a>04545 <span class="comment">// and returns false.  None of pstr, *pstr, and prefix can be NULL.</span>
<a name="l04546"></a>04546 <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac490e9b0963689436d4c483653b3f93f">SkipPrefix</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* prefix, <span class="keyword">const</span> <span class="keywordtype">char</span>** pstr) {
<a name="l04547"></a>04547   <span class="keyword">const</span> <span class="keywordtype">size_t</span> prefix_len = strlen(prefix);
<a name="l04548"></a>04548   <span class="keywordflow">if</span> (strncmp(*pstr, prefix, prefix_len) == 0) {
<a name="l04549"></a>04549     *pstr += prefix_len;
<a name="l04550"></a>04550     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04551"></a>04551   }
<a name="l04552"></a>04552   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04553"></a>04553 }
<a name="l04554"></a>04554 
<a name="l04555"></a>04555 <span class="comment">// Parses a string as a command line flag.  The string should have</span>
<a name="l04556"></a>04556 <span class="comment">// the format &quot;--flag=value&quot;.  When def_optional is true, the &quot;=value&quot;</span>
<a name="l04557"></a>04557 <span class="comment">// part can be omitted.</span>
<a name="l04558"></a>04558 <span class="comment">//</span>
<a name="l04559"></a>04559 <span class="comment">// Returns the value of the flag, or NULL if the parsing failed.</span>
<a name="l04560"></a>04560 <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5e4e5aab56cf1d77b5bf092c875142ef">ParseFlagValue</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str,
<a name="l04561"></a>04561                            <span class="keyword">const</span> <span class="keywordtype">char</span>* flag,
<a name="l04562"></a>04562                            <span class="keywordtype">bool</span> def_optional) {
<a name="l04563"></a>04563   <span class="comment">// str and flag must not be NULL.</span>
<a name="l04564"></a>04564   <span class="keywordflow">if</span> (str == NULL || flag == NULL) <span class="keywordflow">return</span> NULL;
<a name="l04565"></a>04565 
<a name="l04566"></a>04566   <span class="comment">// The flag must start with &quot;--&quot; followed by GTEST_FLAG_PREFIX_.</span>
<a name="l04567"></a>04567   <span class="keyword">const</span> String flag_str = <a class="code" href="../../d2/df8/classtesting_1_1internal_1_1String.html#a8a1b50faf1d091441d626e123630b87a">String::Format</a>(<span class="stringliteral">&quot;--%s%s&quot;</span>, <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a>, flag);
<a name="l04568"></a>04568   <span class="keyword">const</span> <span class="keywordtype">size_t</span> flag_len = flag_str.length();
<a name="l04569"></a>04569   <span class="keywordflow">if</span> (strncmp(str, flag_str.c_str(), flag_len) != 0) <span class="keywordflow">return</span> NULL;
<a name="l04570"></a>04570 
<a name="l04571"></a>04571   <span class="comment">// Skips the flag name.</span>
<a name="l04572"></a>04572   <span class="keyword">const</span> <span class="keywordtype">char</span>* flag_end = str + flag_len;
<a name="l04573"></a>04573 
<a name="l04574"></a>04574   <span class="comment">// When def_optional is true, it&#39;s OK to not have a &quot;=value&quot; part.</span>
<a name="l04575"></a>04575   <span class="keywordflow">if</span> (def_optional &amp;&amp; (flag_end[0] == <span class="charliteral">&#39;\0&#39;</span>)) {
<a name="l04576"></a>04576     <span class="keywordflow">return</span> flag_end;
<a name="l04577"></a>04577   }
<a name="l04578"></a>04578 
<a name="l04579"></a>04579   <span class="comment">// If def_optional is true and there are more characters after the</span>
<a name="l04580"></a>04580   <span class="comment">// flag name, or if def_optional is false, there must be a &#39;=&#39; after</span>
<a name="l04581"></a>04581   <span class="comment">// the flag name.</span>
<a name="l04582"></a>04582   <span class="keywordflow">if</span> (flag_end[0] != <span class="charliteral">&#39;=&#39;</span>) <span class="keywordflow">return</span> NULL;
<a name="l04583"></a>04583 
<a name="l04584"></a>04584   <span class="comment">// Returns the string after &quot;=&quot;.</span>
<a name="l04585"></a>04585   <span class="keywordflow">return</span> flag_end + 1;
<a name="l04586"></a>04586 }
<a name="l04587"></a>04587 
<a name="l04588"></a>04588 <span class="comment">// Parses a string for a bool flag, in the form of either</span>
<a name="l04589"></a>04589 <span class="comment">// &quot;--flag=value&quot; or &quot;--flag&quot;.</span>
<a name="l04590"></a>04590 <span class="comment">//</span>
<a name="l04591"></a>04591 <span class="comment">// In the former case, the value is taken as true as long as it does</span>
<a name="l04592"></a>04592 <span class="comment">// not start with &#39;0&#39;, &#39;f&#39;, or &#39;F&#39;.</span>
<a name="l04593"></a>04593 <span class="comment">//</span>
<a name="l04594"></a>04594 <span class="comment">// In the latter case, the value is taken as true.</span>
<a name="l04595"></a>04595 <span class="comment">//</span>
<a name="l04596"></a>04596 <span class="comment">// On success, stores the value of the flag in *value, and returns</span>
<a name="l04597"></a>04597 <span class="comment">// true.  On failure, returns false without changing *value.</span>
<a name="l04598"></a>04598 <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a777a3b389d36aa43396bab9e42286d0e">ParseBoolFlag</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keyword">const</span> <span class="keywordtype">char</span>* flag, <span class="keywordtype">bool</span>* value) {
<a name="l04599"></a>04599   <span class="comment">// Gets the value of the flag as a string.</span>
<a name="l04600"></a>04600   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> value_str = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5e4e5aab56cf1d77b5bf092c875142ef">ParseFlagValue</a>(str, flag, <span class="keyword">true</span>);
<a name="l04601"></a>04601 
<a name="l04602"></a>04602   <span class="comment">// Aborts if the parsing failed.</span>
<a name="l04603"></a>04603   <span class="keywordflow">if</span> (value_str == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04604"></a>04604 
<a name="l04605"></a>04605   <span class="comment">// Converts the string value to a bool.</span>
<a name="l04606"></a>04606   *value = !(*value_str == <span class="charliteral">&#39;0&#39;</span> || *value_str == <span class="charliteral">&#39;f&#39;</span> || *value_str == <span class="charliteral">&#39;F&#39;</span>);
<a name="l04607"></a>04607   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04608"></a>04608 }
<a name="l04609"></a>04609 
<a name="l04610"></a>04610 <span class="comment">// Parses a string for an Int32 flag, in the form of</span>
<a name="l04611"></a>04611 <span class="comment">// &quot;--flag=value&quot;.</span>
<a name="l04612"></a>04612 <span class="comment">//</span>
<a name="l04613"></a>04613 <span class="comment">// On success, stores the value of the flag in *value, and returns</span>
<a name="l04614"></a>04614 <span class="comment">// true.  On failure, returns false without changing *value.</span>
<a name="l04615"></a>04615 <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a082f2d6b59adc025b035b2c51b0fc47e">ParseInt32Flag</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keyword">const</span> <span class="keywordtype">char</span>* flag, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a8d84339888eecdb29b3d8f7607af3ecc">Int32</a>* value) {
<a name="l04616"></a>04616   <span class="comment">// Gets the value of the flag as a string.</span>
<a name="l04617"></a>04617   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> value_str = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5e4e5aab56cf1d77b5bf092c875142ef">ParseFlagValue</a>(str, flag, <span class="keyword">false</span>);
<a name="l04618"></a>04618 
<a name="l04619"></a>04619   <span class="comment">// Aborts if the parsing failed.</span>
<a name="l04620"></a>04620   <span class="keywordflow">if</span> (value_str == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04621"></a>04621 
<a name="l04622"></a>04622   <span class="comment">// Sets *value to the value of the flag.</span>
<a name="l04623"></a>04623   <span class="keywordflow">return</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3bd151d0274b216f9c2e6275ccc4a9a3">ParseInt32</a>(Message() &lt;&lt; <span class="stringliteral">&quot;The value of flag --&quot;</span> &lt;&lt; flag,
<a name="l04624"></a>04624                     value_str, value);
<a name="l04625"></a>04625 }
<a name="l04626"></a>04626 
<a name="l04627"></a>04627 <span class="comment">// Parses a string for a string flag, in the form of</span>
<a name="l04628"></a>04628 <span class="comment">// &quot;--flag=value&quot;.</span>
<a name="l04629"></a>04629 <span class="comment">//</span>
<a name="l04630"></a>04630 <span class="comment">// On success, stores the value of the flag in *value, and returns</span>
<a name="l04631"></a>04631 <span class="comment">// true.  On failure, returns false without changing *value.</span>
<a name="l04632"></a>04632 <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac43d360c9021a4fd0bd939f7c99e61a0">ParseStringFlag</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keyword">const</span> <span class="keywordtype">char</span>* flag, String* value) {
<a name="l04633"></a>04633   <span class="comment">// Gets the value of the flag as a string.</span>
<a name="l04634"></a>04634   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> value_str = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5e4e5aab56cf1d77b5bf092c875142ef">ParseFlagValue</a>(str, flag, <span class="keyword">false</span>);
<a name="l04635"></a>04635 
<a name="l04636"></a>04636   <span class="comment">// Aborts if the parsing failed.</span>
<a name="l04637"></a>04637   <span class="keywordflow">if</span> (value_str == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04638"></a>04638 
<a name="l04639"></a>04639   <span class="comment">// Sets *value to the value of the flag.</span>
<a name="l04640"></a>04640   *value = value_str;
<a name="l04641"></a>04641   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04642"></a>04642 }
<a name="l04643"></a>04643 
<a name="l04644"></a>04644 <span class="comment">// Determines whether a string has a prefix that Google Test uses for its</span>
<a name="l04645"></a>04645 <span class="comment">// flags, i.e., starts with GTEST_FLAG_PREFIX_ or GTEST_FLAG_PREFIX_DASH_.</span>
<a name="l04646"></a>04646 <span class="comment">// If Google Test detects that a command line flag has its prefix but is not</span>
<a name="l04647"></a>04647 <span class="comment">// recognized, it will print its help message. Flags starting with</span>
<a name="l04648"></a>04648 <span class="comment">// GTEST_INTERNAL_PREFIX_ followed by &quot;internal_&quot; are considered Google Test</span>
<a name="l04649"></a>04649 <span class="comment">// internal flags and do not trigger the help message.</span>
<a name="l04650"></a>04650 <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#aa90ded545c69ff0535f9f6a70ab45612">HasGoogleTestFlagPrefix</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str) {
<a name="l04651"></a>04651   <span class="keywordflow">return</span> (<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac490e9b0963689436d4c483653b3f93f">SkipPrefix</a>(<span class="stringliteral">&quot;--&quot;</span>, &amp;str) ||
<a name="l04652"></a>04652           <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac490e9b0963689436d4c483653b3f93f">SkipPrefix</a>(<span class="stringliteral">&quot;-&quot;</span>, &amp;str) ||
<a name="l04653"></a>04653           <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac490e9b0963689436d4c483653b3f93f">SkipPrefix</a>(<span class="stringliteral">&quot;/&quot;</span>, &amp;str)) &amp;&amp;
<a name="l04654"></a>04654          !<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac490e9b0963689436d4c483653b3f93f">SkipPrefix</a>(<a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;internal_&quot;</span>, &amp;str) &amp;&amp;
<a name="l04655"></a>04655          (<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac490e9b0963689436d4c483653b3f93f">SkipPrefix</a>(<a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a>, &amp;str) ||
<a name="l04656"></a>04656           <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac490e9b0963689436d4c483653b3f93f">SkipPrefix</a>(<a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a4251ff898f9f94ec6b8b9402c3436759">GTEST_FLAG_PREFIX_DASH_</a>, &amp;str));
<a name="l04657"></a>04657 }
<a name="l04658"></a>04658 
<a name="l04659"></a>04659 <span class="comment">// Prints a string containing code-encoded text.  The following escape</span>
<a name="l04660"></a>04660 <span class="comment">// sequences can be used in the string to control the text color:</span>
<a name="l04661"></a>04661 <span class="comment">//</span>
<a name="l04662"></a>04662 <span class="comment">//   @@    prints a single &#39;@&#39; character.</span>
<a name="l04663"></a>04663 <span class="comment">//   @R    changes the color to red.</span>
<a name="l04664"></a>04664 <span class="comment">//   @G    changes the color to green.</span>
<a name="l04665"></a>04665 <span class="comment">//   @Y    changes the color to yellow.</span>
<a name="l04666"></a>04666 <span class="comment">//   @D    changes to the default terminal text color.</span>
<a name="l04667"></a>04667 <span class="comment">//</span>
<a name="l04668"></a>04668 <span class="comment">// TODO(wan@google.com): Write tests for this once we add stdout</span>
<a name="l04669"></a>04669 <span class="comment">// capturing to Google Test.</span>
<a name="l04670"></a>04670 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ad448973e8494343c56ae947eb38f21a7">PrintColorEncoded</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str) {
<a name="l04671"></a>04671   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965">GTestColor</a> color = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965aaeda96851415e6bb57229cf139545439">COLOR_DEFAULT</a>;  <span class="comment">// The current color.</span>
<a name="l04672"></a>04672 
<a name="l04673"></a>04673   <span class="comment">// Conceptually, we split the string into segments divided by escape</span>
<a name="l04674"></a>04674   <span class="comment">// sequences.  Then we print one segment at a time.  At the end of</span>
<a name="l04675"></a>04675   <span class="comment">// each iteration, the str pointer advances to the beginning of the</span>
<a name="l04676"></a>04676   <span class="comment">// next segment.</span>
<a name="l04677"></a>04677   <span class="keywordflow">for</span> (;;) {
<a name="l04678"></a>04678     <span class="keyword">const</span> <span class="keywordtype">char</span>* p = strchr(str, <span class="charliteral">&#39;@&#39;</span>);
<a name="l04679"></a>04679     <span class="keywordflow">if</span> (p == NULL) {
<a name="l04680"></a>04680       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(color, <span class="stringliteral">&quot;%s&quot;</span>, str);
<a name="l04681"></a>04681       <span class="keywordflow">return</span>;
<a name="l04682"></a>04682     }
<a name="l04683"></a>04683 
<a name="l04684"></a>04684     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(color, <span class="stringliteral">&quot;%s&quot;</span>, String(str, p - str).c_str());
<a name="l04685"></a>04685 
<a name="l04686"></a>04686     <span class="keyword">const</span> <span class="keywordtype">char</span> ch = p[1];
<a name="l04687"></a>04687     str = p + 2;
<a name="l04688"></a>04688     <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;@&#39;</span>) {
<a name="l04689"></a>04689       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a50a94fd99435d0a4dc57b7ca17860d92">ColoredPrintf</a>(color, <span class="stringliteral">&quot;@&quot;</span>);
<a name="l04690"></a>04690     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;D&#39;</span>) {
<a name="l04691"></a>04691       color = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965aaeda96851415e6bb57229cf139545439">COLOR_DEFAULT</a>;
<a name="l04692"></a>04692     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;R&#39;</span>) {
<a name="l04693"></a>04693       color = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a55978b2a4d309f4f009fd1baa7808358">COLOR_RED</a>;
<a name="l04694"></a>04694     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;G&#39;</span>) {
<a name="l04695"></a>04695       color = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a125edbdad9257143fc1fabf1c686d959">COLOR_GREEN</a>;
<a name="l04696"></a>04696     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;Y&#39;</span>) {
<a name="l04697"></a>04697       color = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae78c352c52b710a680c35b87b1c5d965a220df2a47a11552fb8631253ef7c3f10">COLOR_YELLOW</a>;
<a name="l04698"></a>04698     } <span class="keywordflow">else</span> {
<a name="l04699"></a>04699       --str;
<a name="l04700"></a>04700     }
<a name="l04701"></a>04701   }
<a name="l04702"></a>04702 }
<a name="l04703"></a>04703 
<a name="l04704"></a>04704 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5d9d2135a9f157ab41418c0e0c3f0b4f">kColorEncodedHelpMessage</a>[] =
<a name="l04705"></a>04705 <span class="stringliteral">&quot;This program contains tests written using &quot;</span> GTEST_NAME_ <span class="stringliteral">&quot;. You can use the\n&quot;</span>
<a name="l04706"></a>04706 <span class="stringliteral">&quot;following command line flags to control its behavior:\n&quot;</span>
<a name="l04707"></a>04707 <span class="stringliteral">&quot;\n&quot;</span>
<a name="l04708"></a>04708 <span class="stringliteral">&quot;Test Selection:\n&quot;</span>
<a name="l04709"></a>04709 <span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;list_tests@D\n&quot;</span>
<a name="l04710"></a>04710 <span class="stringliteral">&quot;      List the names of all tests instead of running them. The name of\n&quot;</span>
<a name="l04711"></a>04711 <span class="stringliteral">&quot;      TEST(Foo, Bar) is \&quot;Foo.Bar\&quot;.\n&quot;</span>
<a name="l04712"></a>04712 <span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;filter=@YPOSTIVE_PATTERNS&quot;</span>
<a name="l04713"></a>04713     <span class="stringliteral">&quot;[@G-@YNEGATIVE_PATTERNS]@D\n&quot;</span>
<a name="l04714"></a>04714 <span class="stringliteral">&quot;      Run only the tests whose name matches one of the positive patterns but\n&quot;</span>
<a name="l04715"></a>04715 <span class="stringliteral">&quot;      none of the negative patterns. &#39;?&#39; matches any single character; &#39;*&#39;\n&quot;</span>
<a name="l04716"></a>04716 <span class="stringliteral">&quot;      matches any substring; &#39;:&#39; separates two patterns.\n&quot;</span>
<a name="l04717"></a>04717 <span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;also_run_disabled_tests@D\n&quot;</span>
<a name="l04718"></a>04718 <span class="stringliteral">&quot;      Run all disabled tests too.\n&quot;</span>
<a name="l04719"></a>04719 <span class="stringliteral">&quot;\n&quot;</span>
<a name="l04720"></a>04720 <span class="stringliteral">&quot;Test Execution:\n&quot;</span>
<a name="l04721"></a>04721 <span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;repeat=@Y[COUNT]@D\n&quot;</span>
<a name="l04722"></a>04722 <span class="stringliteral">&quot;      Run the tests repeatedly; use a negative count to repeat forever.\n&quot;</span>
<a name="l04723"></a>04723 <span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;shuffle@D\n&quot;</span>
<a name="l04724"></a>04724 <span class="stringliteral">&quot;      Randomize tests&#39; orders on every iteration.\n&quot;</span>
<a name="l04725"></a>04725 <span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;random_seed=@Y[NUMBER]@D\n&quot;</span>
<a name="l04726"></a>04726 <span class="stringliteral">&quot;      Random number seed to use for shuffling test orders (between 1 and\n&quot;</span>
<a name="l04727"></a>04727 <span class="stringliteral">&quot;      99999, or 0 to use a seed based on the current time).\n&quot;</span>
<a name="l04728"></a>04728 <span class="stringliteral">&quot;\n&quot;</span>
<a name="l04729"></a>04729 <span class="stringliteral">&quot;Test Output:\n&quot;</span>
<a name="l04730"></a>04730 <span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;color=@Y(@Gyes@Y|@Gno@Y|@Gauto@Y)@D\n&quot;</span>
<a name="l04731"></a>04731 <span class="stringliteral">&quot;      Enable/disable colored output. The default is @Gauto@D.\n&quot;</span>
<a name="l04732"></a>04732 <span class="stringliteral">&quot;  -@G-&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;print_time=0@D\n&quot;</span>
<a name="l04733"></a>04733 <span class="stringliteral">&quot;      Don&#39;t print the elapsed time of each test.\n&quot;</span>
<a name="l04734"></a>04734 <span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;output=xml@Y[@G:@YDIRECTORY_PATH@G&quot;</span>
<a name="l04735"></a>04735     <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#afbb636e91bdd50267dbef11a50490b29">GTEST_PATH_SEP_</a> <span class="stringliteral">&quot;@Y|@G:@YFILE_PATH]@D\n&quot;</span>
<a name="l04736"></a>04736 <span class="stringliteral">&quot;      Generate an XML report in the given directory or with the given file\n&quot;</span>
<a name="l04737"></a>04737 <span class="stringliteral">&quot;      name. @YFILE_PATH@D defaults to @Gtest_details.xml@D.\n&quot;</span>
<a name="l04738"></a>04738 <span class="preprocessor">#if GTEST_CAN_STREAM_RESULTS_</span>
<a name="l04739"></a>04739 <span class="preprocessor"></span><span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;stream_result_to=@YHOST@G:@YPORT@D\n&quot;</span>
<a name="l04740"></a>04740 <span class="stringliteral">&quot;      Stream test results to the given server.\n&quot;</span>
<a name="l04741"></a>04741 <span class="preprocessor">#endif  // GTEST_CAN_STREAM_RESULTS_</span>
<a name="l04742"></a>04742 <span class="preprocessor"></span><span class="stringliteral">&quot;\n&quot;</span>
<a name="l04743"></a>04743 <span class="stringliteral">&quot;Assertion Behavior:\n&quot;</span>
<a name="l04744"></a>04744 <span class="preprocessor">#if GTEST_HAS_DEATH_TEST &amp;&amp; !GTEST_OS_WINDOWS</span>
<a name="l04745"></a>04745 <span class="preprocessor"></span><span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;death_test_style=@Y(@Gfast@Y|@Gthreadsafe@Y)@D\n&quot;</span>
<a name="l04746"></a>04746 <span class="stringliteral">&quot;      Set the default death test style.\n&quot;</span>
<a name="l04747"></a>04747 <span class="preprocessor">#endif  // GTEST_HAS_DEATH_TEST &amp;&amp; !GTEST_OS_WINDOWS</span>
<a name="l04748"></a>04748 <span class="preprocessor"></span><span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;break_on_failure@D\n&quot;</span>
<a name="l04749"></a>04749 <span class="stringliteral">&quot;      Turn assertion failures into debugger break-points.\n&quot;</span>
<a name="l04750"></a>04750 <span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;throw_on_failure@D\n&quot;</span>
<a name="l04751"></a>04751 <span class="stringliteral">&quot;      Turn assertion failures into C++ exceptions.\n&quot;</span>
<a name="l04752"></a>04752 <span class="stringliteral">&quot;  @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;catch_exceptions=0@D\n&quot;</span>
<a name="l04753"></a>04753 <span class="stringliteral">&quot;      Do not report exceptions as test failures. Instead, allow them\n&quot;</span>
<a name="l04754"></a>04754 <span class="stringliteral">&quot;      to crash the program or throw a pop-up (on Windows).\n&quot;</span>
<a name="l04755"></a>04755 <span class="stringliteral">&quot;\n&quot;</span>
<a name="l04756"></a>04756 <span class="stringliteral">&quot;Except for @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a> <span class="stringliteral">&quot;list_tests@D, you can alternatively set &quot;</span>
<a name="l04757"></a>04757     <span class="stringliteral">&quot;the corresponding\n&quot;</span>
<a name="l04758"></a>04758 <span class="stringliteral">&quot;environment variable of a flag (all letters in upper-case). For example, to\n&quot;</span>
<a name="l04759"></a>04759 <span class="stringliteral">&quot;disable colored text output, you can either specify @G--&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a088e84784c589ba9b1fc48602ad8eabf">GTEST_FLAG_PREFIX_</a>
<a name="l04760"></a>04760     <span class="stringliteral">&quot;color=no@D or set\n&quot;</span>
<a name="l04761"></a>04761 <span class="stringliteral">&quot;the @G&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a4018b7f288f974d022df397e2730633a">GTEST_FLAG_PREFIX_UPPER_</a> <span class="stringliteral">&quot;COLOR@D environment variable to @Gno@D.\n&quot;</span>
<a name="l04762"></a>04762 <span class="stringliteral">&quot;\n&quot;</span>
<a name="l04763"></a>04763 <span class="stringliteral">&quot;For more information, please read the &quot;</span> GTEST_NAME_ <span class="stringliteral">&quot; documentation at\n&quot;</span>
<a name="l04764"></a>04764 <span class="stringliteral">&quot;@G&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a5aa3c938fc1d049f1d9c5332f6a0b1d4">GTEST_PROJECT_URL_</a> <span class="stringliteral">&quot;@D. If you find a bug in &quot;</span> GTEST_NAME_ <span class="stringliteral">&quot;\n&quot;</span>
<a name="l04765"></a>04765 <span class="stringliteral">&quot;(not one in your own code or tests), please report it to\n&quot;</span>
<a name="l04766"></a>04766 <span class="stringliteral">&quot;@G&lt;&quot;</span> <a class="code" href="../../d2/dc6/fused-src_2gtest_2gtest_8h.html#a21086d276b1a64d6763ee8a94b12c1b8">GTEST_DEV_EMAIL_</a> <span class="stringliteral">&quot;&gt;@D.\n&quot;</span>;
<a name="l04767"></a>04767 
<a name="l04768"></a>04768 <span class="comment">// Parses the command line for Google Test flags, without initializing</span>
<a name="l04769"></a>04769 <span class="comment">// other parts of Google Test.  The type parameter CharType can be</span>
<a name="l04770"></a>04770 <span class="comment">// instantiated to either char or wchar_t.</span>
<a name="l04771"></a>04771 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType&gt;
<a name="l04772"></a>04772 <span class="keywordtype">void</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ad2d2daedebbf18eb13fb9deb1f069f6e">ParseGoogleTestFlagsOnlyImpl</a>(<span class="keywordtype">int</span>* argc, CharType** argv) {
<a name="l04773"></a>04773   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; *argc; i++) {
<a name="l04774"></a>04774     <span class="keyword">const</span> String arg_string = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a66c1c8bcb19e8562b79bd8ef9bab2aa9">StreamableToString</a>(argv[i]);
<a name="l04775"></a>04775     <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> arg = arg_string.c_str();
<a name="l04776"></a>04776 
<a name="l04777"></a>04777     <span class="keyword">using</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a777a3b389d36aa43396bab9e42286d0e">internal::ParseBoolFlag</a>;
<a name="l04778"></a>04778     <span class="keyword">using</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a082f2d6b59adc025b035b2c51b0fc47e">internal::ParseInt32Flag</a>;
<a name="l04779"></a>04779     <span class="keyword">using</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac43d360c9021a4fd0bd939f7c99e61a0">internal::ParseStringFlag</a>;
<a name="l04780"></a>04780 
<a name="l04781"></a>04781     <span class="comment">// Do we see a Google Test flag?</span>
<a name="l04782"></a>04782     <span class="keywordflow">if</span> (<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a777a3b389d36aa43396bab9e42286d0e">ParseBoolFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a6ede7eecc363c348aba14d8b41f73b8f">kAlsoRunDisabledTestsFlag</a>,
<a name="l04783"></a>04783                       &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(also_run_disabled_tests)) ||
<a name="l04784"></a>04784         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a777a3b389d36aa43396bab9e42286d0e">ParseBoolFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a7428ba6fee0b44acbd1d308cd7804beb">kBreakOnFailureFlag</a>,
<a name="l04785"></a>04785                       &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(break_on_failure)) ||
<a name="l04786"></a>04786         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a777a3b389d36aa43396bab9e42286d0e">ParseBoolFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a1a9e7362cafa5838b6cae9fb1a861ada">kCatchExceptionsFlag</a>,
<a name="l04787"></a>04787                       &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(catch_exceptions)) ||
<a name="l04788"></a>04788         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac43d360c9021a4fd0bd939f7c99e61a0">ParseStringFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a0794d62b77bae59a9082ba4b7ea1fc90">kColorFlag</a>, &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(color)) ||
<a name="l04789"></a>04789         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac43d360c9021a4fd0bd939f7c99e61a0">ParseStringFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac0febb92c715571e1de67b6202c9cdf0">kDeathTestStyleFlag</a>,
<a name="l04790"></a>04790                         &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(death_test_style)) ||
<a name="l04791"></a>04791         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a777a3b389d36aa43396bab9e42286d0e">ParseBoolFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a273ce8e6e8fd1876e73ea69c279c9889">kDeathTestUseFork</a>,
<a name="l04792"></a>04792                       &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(death_test_use_fork)) ||
<a name="l04793"></a>04793         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac43d360c9021a4fd0bd939f7c99e61a0">ParseStringFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae8ede5b14ce6f96fff7e0aabe86aceef">kFilterFlag</a>, &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(filter)) ||
<a name="l04794"></a>04794         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac43d360c9021a4fd0bd939f7c99e61a0">ParseStringFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a29105b980c57e381b8f5ce94122829e3">kInternalRunDeathTestFlag</a>,
<a name="l04795"></a>04795                         &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(internal_run_death_test)) ||
<a name="l04796"></a>04796         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a777a3b389d36aa43396bab9e42286d0e">ParseBoolFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ae3a6eeb3de16a5f69f3bc0568c8e9da0">kListTestsFlag</a>, &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(list_tests)) ||
<a name="l04797"></a>04797         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac43d360c9021a4fd0bd939f7c99e61a0">ParseStringFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#add148191334fbc797c9a2cc2fff82670">kOutputFlag</a>, &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(output)) ||
<a name="l04798"></a>04798         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a777a3b389d36aa43396bab9e42286d0e">ParseBoolFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a75c069f656d8436272be49ad7024bb1b">kPrintTimeFlag</a>, &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(print_time)) ||
<a name="l04799"></a>04799         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a082f2d6b59adc025b035b2c51b0fc47e">ParseInt32Flag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#aa59cb88e76f5f3649a22dd1c32666671">kRandomSeedFlag</a>, &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(random_seed)) ||
<a name="l04800"></a>04800         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a082f2d6b59adc025b035b2c51b0fc47e">ParseInt32Flag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a16c8fa0cc0f7bae57e88cfcbdf46cd57">kRepeatFlag</a>, &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(repeat)) ||
<a name="l04801"></a>04801         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a777a3b389d36aa43396bab9e42286d0e">ParseBoolFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a49a373cb8c0bc9eae2a39e8122e753cc">kShuffleFlag</a>, &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(shuffle)) ||
<a name="l04802"></a>04802         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a082f2d6b59adc025b035b2c51b0fc47e">ParseInt32Flag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a8dc0484b79056e6319003f4a933c7c9b">kStackTraceDepthFlag</a>,
<a name="l04803"></a>04803                        &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(stack_trace_depth)) ||
<a name="l04804"></a>04804         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ac43d360c9021a4fd0bd939f7c99e61a0">ParseStringFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a146c6b52bb1400ba13d45c539034af16">kStreamResultToFlag</a>,
<a name="l04805"></a>04805                         &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(stream_result_to)) ||
<a name="l04806"></a>04806         <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a777a3b389d36aa43396bab9e42286d0e">ParseBoolFlag</a>(arg, <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a2ada1f0b59f090f1791291c533c793f2">kThrowOnFailureFlag</a>,
<a name="l04807"></a>04807                       &amp;<a class="code" href="../../de/db0/gtest__output__test___8cc.html#a448e05d56107d7550bea141e0f7a73d3">GTEST_FLAG</a>(throw_on_failure))
<a name="l04808"></a>04808         ) {
<a name="l04809"></a>04809       <span class="comment">// Yes.  Shift the remainder of the argv list left by one.  Note</span>
<a name="l04810"></a>04810       <span class="comment">// that argv has (*argc + 1) elements, the last one always being</span>
<a name="l04811"></a>04811       <span class="comment">// NULL.  The following loop moves the trailing NULL element as</span>
<a name="l04812"></a>04812       <span class="comment">// well.</span>
<a name="l04813"></a>04813       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i; j != *argc; j++) {
<a name="l04814"></a>04814         argv[j] = argv[j + 1];
<a name="l04815"></a>04815       }
<a name="l04816"></a>04816 
<a name="l04817"></a>04817       <span class="comment">// Decrements the argument count.</span>
<a name="l04818"></a>04818       (*argc)--;
<a name="l04819"></a>04819 
<a name="l04820"></a>04820       <span class="comment">// We also need to decrement the iterator as we just removed</span>
<a name="l04821"></a>04821       <span class="comment">// an element.</span>
<a name="l04822"></a>04822       i--;
<a name="l04823"></a>04823     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (arg_string == <span class="stringliteral">&quot;--help&quot;</span> || arg_string == <span class="stringliteral">&quot;-h&quot;</span> ||
<a name="l04824"></a>04824                arg_string == <span class="stringliteral">&quot;-?&quot;</span> || arg_string == <span class="stringliteral">&quot;/?&quot;</span> ||
<a name="l04825"></a>04825                <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#aa90ded545c69ff0535f9f6a70ab45612">HasGoogleTestFlagPrefix</a>(arg)) {
<a name="l04826"></a>04826       <span class="comment">// Both help flag and unrecognized Google Test flags (excluding</span>
<a name="l04827"></a>04827       <span class="comment">// internal ones) trigger help display.</span>
<a name="l04828"></a>04828       <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a05b77c93e2ac596346466a00277288ca">g_help_flag</a> = <span class="keyword">true</span>;
<a name="l04829"></a>04829     }
<a name="l04830"></a>04830   }
<a name="l04831"></a>04831 
<a name="l04832"></a>04832   <span class="keywordflow">if</span> (<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a05b77c93e2ac596346466a00277288ca">g_help_flag</a>) {
<a name="l04833"></a>04833     <span class="comment">// We print the help here instead of in RUN_ALL_TESTS(), as the</span>
<a name="l04834"></a>04834     <span class="comment">// latter may not be called at all if the user is using Google</span>
<a name="l04835"></a>04835     <span class="comment">// Test with another testing framework.</span>
<a name="l04836"></a>04836     <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ad448973e8494343c56ae947eb38f21a7">PrintColorEncoded</a>(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5d9d2135a9f157ab41418c0e0c3f0b4f">kColorEncodedHelpMessage</a>);
<a name="l04837"></a>04837   }
<a name="l04838"></a>04838 }
<a name="l04839"></a>04839 
<a name="l04840"></a>04840 <span class="comment">// Parses the command line for Google Test flags, without initializing</span>
<a name="l04841"></a>04841 <span class="comment">// other parts of Google Test.</span>
<a name="l04842"></a>04842 <span class="keywordtype">void</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5655276556ac09c8d184920553da3e90">ParseGoogleTestFlagsOnly</a>(<span class="keywordtype">int</span>* argc, <span class="keywordtype">char</span>** argv) {
<a name="l04843"></a>04843   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ad2d2daedebbf18eb13fb9deb1f069f6e">ParseGoogleTestFlagsOnlyImpl</a>(argc, argv);
<a name="l04844"></a>04844 }
<a name="l04845"></a>04845 <span class="keywordtype">void</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5655276556ac09c8d184920553da3e90">ParseGoogleTestFlagsOnly</a>(<span class="keywordtype">int</span>* argc, <span class="keywordtype">wchar_t</span>** argv) {
<a name="l04846"></a>04846   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#ad2d2daedebbf18eb13fb9deb1f069f6e">ParseGoogleTestFlagsOnlyImpl</a>(argc, argv);
<a name="l04847"></a>04847 }
<a name="l04848"></a>04848 
<a name="l04849"></a>04849 <span class="comment">// The internal implementation of InitGoogleTest().</span>
<a name="l04850"></a>04850 <span class="comment">//</span>
<a name="l04851"></a>04851 <span class="comment">// The type parameter CharType can be instantiated to either char or</span>
<a name="l04852"></a>04852 <span class="comment">// wchar_t.</span>
<a name="l04853"></a>04853 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharType&gt;
<a name="l04854"></a>04854 <span class="keywordtype">void</span> <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#aa955365c835d1a8f1659369249b5b1e4">InitGoogleTestImpl</a>(<span class="keywordtype">int</span>* argc, CharType** argv) {
<a name="l04855"></a>04855   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5d56c8e20bffcfc3a4c2c1805f815ab5">g_init_gtest_count</a>++;
<a name="l04856"></a>04856 
<a name="l04857"></a>04857   <span class="comment">// We don&#39;t want to run the initialization code twice.</span>
<a name="l04858"></a>04858   <span class="keywordflow">if</span> (<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5d56c8e20bffcfc3a4c2c1805f815ab5">g_init_gtest_count</a> != 1) <span class="keywordflow">return</span>;
<a name="l04859"></a>04859 
<a name="l04860"></a>04860   <span class="keywordflow">if</span> (*argc &lt;= 0) <span class="keywordflow">return</span>;
<a name="l04861"></a>04861 
<a name="l04862"></a>04862   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a00eb28c08b6a4da5387d466add2f742a">internal::g_executable_path</a> = <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a66c1c8bcb19e8562b79bd8ef9bab2aa9">internal::StreamableToString</a>(argv[0]);
<a name="l04863"></a>04863 
<a name="l04864"></a>04864 <span class="preprocessor">#if GTEST_HAS_DEATH_TEST</span>
<a name="l04865"></a>04865 <span class="preprocessor"></span>
<a name="l04866"></a>04866   g_argvs.clear();
<a name="l04867"></a>04867   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != *argc; i++) {
<a name="l04868"></a>04868     g_argvs.push_back(<a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a66c1c8bcb19e8562b79bd8ef9bab2aa9">StreamableToString</a>(argv[i]));
<a name="l04869"></a>04869   }
<a name="l04870"></a>04870 
<a name="l04871"></a>04871 <span class="preprocessor">#endif  // GTEST_HAS_DEATH_TEST</span>
<a name="l04872"></a>04872 <span class="preprocessor"></span>
<a name="l04873"></a>04873   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a5655276556ac09c8d184920553da3e90">ParseGoogleTestFlagsOnly</a>(argc, argv);
<a name="l04874"></a>04874   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#a3ae874a4030c4aa27d77d67bf08d9e1d">GetUnitTestImpl</a>()-&gt;<a class="code" href="../../d0/de3/classtesting_1_1internal_1_1UnitTestImpl.html#a3d68c6d1fdec822210f96171a3b57b47">PostFlagParsingInit</a>();
<a name="l04875"></a>04875 }
<a name="l04876"></a>04876 
<a name="l04877"></a>04877 }  <span class="comment">// namespace internal</span>
<a name="l04878"></a>04878 
<a name="l04879"></a>04879 <span class="comment">// Initializes Google Test.  This must be called before calling</span>
<a name="l04880"></a>04880 <span class="comment">// RUN_ALL_TESTS().  In particular, it parses a command line for the</span>
<a name="l04881"></a>04881 <span class="comment">// flags that Google Test recognizes.  Whenever a Google Test flag is</span>
<a name="l04882"></a>04882 <span class="comment">// seen, it is removed from argv, and *argc is decremented.</span>
<a name="l04883"></a>04883 <span class="comment">//</span>
<a name="l04884"></a>04884 <span class="comment">// No value is returned.  Instead, the Google Test flag variables are</span>
<a name="l04885"></a>04885 <span class="comment">// updated.</span>
<a name="l04886"></a>04886 <span class="comment">//</span>
<a name="l04887"></a>04887 <span class="comment">// Calling the function for the second time has no user-visible effect.</span>
<a name="l04888"></a>04888 <span class="keywordtype">void</span> <a class="code" href="../../d0/d75/namespacetesting.html#a2ba4fda7f4d403cbcdf289327009a2da">InitGoogleTest</a>(<span class="keywordtype">int</span>* argc, <span class="keywordtype">char</span>** argv) {
<a name="l04889"></a>04889   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#aa955365c835d1a8f1659369249b5b1e4">internal::InitGoogleTestImpl</a>(argc, argv);
<a name="l04890"></a>04890 }
<a name="l04891"></a>04891 
<a name="l04892"></a>04892 <span class="comment">// This overloaded version can be used in Windows programs compiled in</span>
<a name="l04893"></a>04893 <span class="comment">// UNICODE mode.</span>
<a name="l04894"></a>04894 <span class="keywordtype">void</span> <a class="code" href="../../d0/d75/namespacetesting.html#a2ba4fda7f4d403cbcdf289327009a2da">InitGoogleTest</a>(<span class="keywordtype">int</span>* argc, <span class="keywordtype">wchar_t</span>** argv) {
<a name="l04895"></a>04895   <a class="code" href="../../d0/da7/namespacetesting_1_1internal.html#aa955365c835d1a8f1659369249b5b1e4">internal::InitGoogleTestImpl</a>(argc, argv);
<a name="l04896"></a>04896 }
<a name="l04897"></a>04897 
<a name="l04898"></a>04898 }  <span class="comment">// namespace testing</span>
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="../../df/d5b/gtest_8cc.html">gtest.cc</a>      </li>

    <li class="footer">Generated on Sun Aug 19 2012 21:32:25 for yuh library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
